<!DOCTYPE html>
<html lang="zh-Hans">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="DPDK" />
    <meta name="hexo-theme-A4" content="v1.8.8" />
    <link rel="alternate icon" type="image/webp" href="/images/Neurothingy.jpg">
    <title>Wuffaa | Blog</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>
    
    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/images/Neurothingy.jpg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Wuffaa</a> 
            <span class="description">el psy congroo</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            DPDK
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%BC%96%E8%AF%91"><span class="post-toc-text">编译</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="post-toc-text">运行参数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#EAL-Environment-Abstraction-Layer"><span class="post-toc-text">EAL(Environment Abstraction Layer)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Log"><span class="post-toc-text">Log</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Command-line"><span class="post-toc-text">Command-line</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Ring-Queue"><span class="post-toc-text">Ring(Queue)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Stack"><span class="post-toc-text">Stack</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RCU-Read-Copy-Update"><span class="post-toc-text">RCU(Read, Copy, Update)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Mempool"><span class="post-toc-text">Mempool</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Mbuf"><span class="post-toc-text">Mbuf</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Timer"><span class="post-toc-text">Timer</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Hash"><span class="post-toc-text">Hash</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#LPM-Longest-Prefix-Match"><span class="post-toc-text">LPM(Longest Prefix Match)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#LPM6"><span class="post-toc-text">LPM6</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RIB-Routing-Information-Base"><span class="post-toc-text">RIB(Routing Information Base)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#FIB-Forwarding-Information-Base"><span class="post-toc-text">FIB(Forwarding Information Base)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ACL-Access-Control-Lists"><span class="post-toc-text">ACL(Access Control Lists)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#EFD-Elastic-Flow-Distributor"><span class="post-toc-text">EFD(Elastic Flow Distributor)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Packet-Distributor"><span class="post-toc-text">Packet Distributor</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Reorder"><span class="post-toc-text">Reorder</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#IP-Frag"><span class="post-toc-text">IP Frag</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Membership"><span class="post-toc-text">Membership</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Graph"><span class="post-toc-text">Graph</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#PacketFrame"><span class="post-toc-text">PacketFrame</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Ethdev"><span class="post-toc-text">Ethdev</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Misc"><span class="post-toc-text">Misc</span></a></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译目录为<code>build</code>的情况下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meson configure build			<span class="comment">#查看编译选项</span></span><br><span class="line">meson configure build -Dxxx=xxx	<span class="comment">#更改编译选项</span></span><br></pre></td></tr></table></figure>



<h1 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h1><h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><ol>
<li>lcore指的是处理器的逻辑执行单元，更多的被认为是一个线程。编号从0开始，最大<strong>RTE_MAX_LCORE - 1</strong>，可通过编译选项<code>max_lcore</code>修改支持的最大lcore数量</li>
<li>在主板上一个物理cpu对应一个插槽（CPU Socket），而每个物理cpu中又有多个核心（Core），如果cpu支持超线程（core内共享ALU）且开启超线程的话，每个核心会对应两个逻辑核（Logical core），否则每个核心对应一个逻辑核。</li>
</ol>
<h2 id="lcore相关选项"><a href="#lcore相关选项" class="headerlink" title="lcore相关选项"></a>lcore相关选项</h2><table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c</td>
<td align="left">设置所启用的lcore，16进制掩码，lcore与其所使用的cpu的逻辑核一一对应。</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="left">设置所启用的lcore，列表形式（例：<code>-l 0-5,7</code>），lcore与其所使用的cpu的逻辑核一一对应。</td>
</tr>
<tr>
<td align="center">–lcores</td>
<td align="left">设置所启用的lcore，同时设置lcore所使用的cpu的逻辑核。<br>例如：<code>--lcores 1,2@(5-7),(3-5)@(0,2),(0,6),7-8</code><br>lcore 0 runs on cpuset 0x41 (cpu 0,6) <br>lcore 1 runs on cpuset 0x2 (cpu 1) <br>lcore 2 runs on cpuset 0xe0 (cpu 5,6,7) <br>lcore 3,4,5 runs on cpuset 0x5 (cpu 0,2) <br>lcore 6 runs on cpuset 0x41 (cpu 0,6) <br>lcore 7 runs on cpuset 0x80 (cpu 7) <br>lcore 8 runs on cpuset 0x100 (cpu 8)</td>
</tr>
</tbody></table>
<h2 id="多进程相关选项"><a href="#多进程相关选项" class="headerlink" title="多进程相关选项"></a>多进程相关选项</h2><table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–proc-type</td>
<td align="left">主副进程设置，不设置的话默认作为主进程</td>
</tr>
<tr>
<td align="center">–file-prefix</td>
<td align="left">1. 运行目录（用于多进程数据共享）下创建指定名称的运行子目录<br>2. 大页文件名前缀<br>不配置的情况下默认为rte，该选项允许多个独立的dpdk运行。<br>例：<br>DPDK-A使用<code>/user/1000/dpdk/a/</code>共享数据<br>DPDK-B使用<code>/user/1000/dpdk/b/</code>共享数据</td>
</tr>
</tbody></table>
<blockquote>
<p>多进程时要保证主副进程所使用的lcore互斥，否则会产生内存池缓存损坏等问题</p>
</blockquote>
<h2 id="内存相关选项"><a href="#内存相关选项" class="headerlink" title="内存相关选项"></a>内存相关选项</h2><table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–in-memory</td>
<td align="left">不创建任何共享数据，完全运行在内存中。配置了该选项默认配置了–no-shconf和–huge-unlink=always。<br>该选项支持大页映射，不需要挂载hugetlbfs，不支持多进程</td>
</tr>
<tr>
<td align="center">–huge-dir</td>
<td align="left">指定该程序使用大页的目录，该目录要求已经挂载hugetlbfs文件系统，不指定该选项默认选择挂载hugetlbfs文件系统的根目录作为该程序使用大页的目录。需要注意的是，一旦设置了该选项，就表明该程序只能使用一种大页</td>
</tr>
<tr>
<td align="center">–match-allocations</td>
<td align="left">回收内存时如果相邻块空闲能够进行合并，则仅合并为最初分配时的块大小。不支持<code>--legacy-mem</code>，也不支持<code>--no-huge</code></td>
</tr>
<tr>
<td align="center">–huge-worker-stack</td>
<td align="left">可以指定使用大页内存作为worker线程的堆栈</td>
</tr>
<tr>
<td align="center">–huge-unlink</td>
<td align="left">always：dpdk在创建大页文件时，若待创建的大页文件存在，则删除后创建。创建后后就执行unlink函数，删除对应大页文件。因此多进程模式不能配置该选项。<br>existing：dpdk在创建大页文件时，若待创建的大页文件存在，则删除后创建。并且dpdk退出后依然保留大页文件(若主进程挂掉，此时副进程仍可使用对应大页文件，也是dpdk默认的配置)<br>never：dpdk在创建大页文件时，若待创建的大页文件存在，则使用该大页文件，并对使用该大页的内存标记为脏页</td>
</tr>
<tr>
<td align="center">–no-huge</td>
<td align="left">不使用大页，配置了该选项就默认配置了<code>--legacy-mem</code></td>
</tr>
<tr>
<td align="center">–legacy-mem</td>
<td align="left">若配置了-m，则映射时不考虑大页所属的node节点；若配置了–socket-mem，则按照每numa的内存数要求去映射</td>
</tr>
</tbody></table>
<blockquote>
<p>–huge-unlink=never虽然可以加速dpdk的restart，但restart后无法得知保留文件所处的socket节点，dpdk在统计操作系统中大页信息时默认就直接将大页数量统计到socket0上，如果dpdk application配置了–socket-mem，restart时很可能无法满足需求；若配置了-m，很可能restart时都申请成socket0上的内存，实际socket0上所配置的大页还可能无法满足。</p>
</blockquote>
<h2 id="Debugging选项"><a href="#Debugging选项" class="headerlink" title="Debugging选项"></a>Debugging选项</h2><h2 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h2><table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-s</td>
<td align="left">设置所启用的service core，16进制掩码，该选项需要在lcore相关选项之后配置，将对应的lcore替换为service core。</td>
</tr>
</tbody></table>
<h1 id="EAL-Environment-Abstraction-Layer"><a href="#EAL-Environment-Abstraction-Layer" class="headerlink" title="EAL(Environment Abstraction Layer)"></a>EAL(Environment Abstraction Layer)</h1><p>dpdk的基本运行流程如下：</p>
<p><a href="/images/linuxapp_launch.svg" title="init" class="gallery-item" style="box-shadow: none;"> <img src="/images/linuxapp_launch.svg" alt="init"></a></p>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>用于加载各类用户态驱动，这些驱动so放在<code>/usr/local/lib/x86_64-linux-gnu/dpdk/pmds-24.1</code>目录下，该目录下所有的so都将被加载到该进程中。(静态编译的程序会跳过plugin加载)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eal_plugins_init</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>



<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>当我们想要调试分析程序，特别是想要知道程序在运行时多核同步情况，这时使用DPDK所提供的Trace功能是一个很好的选择。Trace模块通过注册追踪点，在代码中设置追踪函数来记录程序的运行数据，这与内核中的<strong>静态探针</strong>类似。程序启动时必须配置<code>--trace=</code>选项才可使能trace功能，程序退出时将记录的信息以<a target="_blank" rel="noopener" href="https://diamon.org/ctf/">CTF</a>（Common Trace Format）格式存放在<code>$/HOME/dpdk-traces</code>或者用户配置<code>--trace-dir</code>指定的目录中。</p>
<p>使用<code>babeltrace</code>命令查看trace信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[wtc@wufa ~]$ babeltrace <span class="variable">$HOME</span>/dpdk-traces/rte-2023-12-30-PM-12-27-51</span><br><span class="line">[12:27:50.328509331] (+?.?????????) lib.eal.thread.lcore.ready: { cpu_id = 0x1, name = <span class="string">"dpdk-worker1"</span> }, { lcore_id = 0x1, cpuset = <span class="string">"1"</span> }</span><br><span class="line">[12:27:50.328567752] (+0.000058421) lib.eal.thread.lcore.ready: { cpu_id = 0x2, name = <span class="string">"dpdk-worker2"</span> }, { lcore_id = 0x2, cpuset = <span class="string">"2"</span> }</span><br><span class="line">[12:27:50.328584117] (+0.000016365) lib.eal.thread.lcore.running: { cpu_id = 0x1, name = <span class="string">"dpdk-worker1"</span> }, { lcore_id = 0x1, f = 0x7F2D9A54E362 }</span><br><span class="line">[12:27:50.328584343] (+0.000000226) lib.eal.thread.lcore.stopped: { cpu_id = 0x1, name = <span class="string">"dpdk-worker1"</span> }, { lcore_id = 0x1 }</span><br><span class="line">[12:27:50.328591812] (+0.000007469) lib.eal.thread.remote.launch: { cpu_id = 0x0, name = <span class="string">"dpdk-test"</span> }, { f = 0x7F2D9A54E362, arg = 0x0, worker_id = 0x1, rc = 0 }</span><br></pre></td></tr></table></figure>



<h3 id="追踪点的建立"><a href="#追踪点的建立" class="headerlink" title="追踪点的建立"></a>追踪点的建立</h3><p>追踪点被定义为一个函数（inline），通过在代码中调用追踪点函数来实现追踪信息的记录。以<code>test_trace.h</code>文件来举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_trace_point.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//追踪点函数定义宏</span></span><br><span class="line">RTE_TRACE_POINT(</span><br><span class="line">	app_dpdk_test_tp,						<span class="comment">//追踪点函数</span></span><br><span class="line">	RTE_TRACE_POINT_ARGS(<span class="type">const</span> <span class="type">char</span> *str),	<span class="comment">//追踪点函数入参（该入参就是需要追踪的变量）</span></span><br><span class="line">	rte_trace_point_emit_string(str);		<span class="comment">//追踪点函数内部的入参记录函数（每个入参都需要对应入参类型的记录函数）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//追踪点函数定义宏，用该宏定义的追踪点函数，仅在编译时使能enable_trace_fp选项时，追踪点函数才会生效，否则该函数定义为空函数</span></span><br><span class="line">RTE_TRACE_POINT_FP(</span><br><span class="line">	app_dpdk_test_fp,</span><br><span class="line">	RTE_TRACE_POINT_ARGS(<span class="type">void</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在头文件没有包含<code>rte_trace_point_register.h</code>的情况下，<code>app_dpdk_test_tp</code>函数定义为追踪点函数，运行时调用。在需要追踪的代码中直接包含该头文件，调用该函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;test_trace.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">char</span> *t = <span class="string">"This is test"</span>;</span><br><span class="line">    app_dpdk_test_tp(t);</span><br><span class="line">}</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h3 id="追踪点的注册"><a href="#追踪点的注册" class="headerlink" title="追踪点的注册"></a>追踪点的注册</h3><p>一个追踪点要想工作，光是在代码中调用追踪点函数是不够的，还需要将每个追踪点注册到Trace模块上。以<code>test_trace_register.c</code>文件来举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_trace_point_register.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"test_trace.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//追踪点的注册宏</span></span><br><span class="line">RTE_TRACE_POINT_REGISTER(</span><br><span class="line">    app_dpdk_test_tp, 		<span class="comment">//追踪点注册函数</span></span><br><span class="line">    app.dpdk.test.tp		<span class="comment">//追踪点名称，运行时通过'--trace='选项来使能该注册点</span></span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line">RTE_TRACE_POINT_REGISTER(</span><br><span class="line">    app_dpdk_test_fp, </span><br><span class="line">    app.dpdk.test.fp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在头文件包含<code>rte_trace_point_register.h</code>的情况下，<code>app_dpdk_test_tp</code>函数定义为追踪点注册函数，注册时调用。虽然名字一样，但这与上面所定义的追踪点函数是两个函数，不要将两者混淆。</p>
<h3 id="Trace原理"><a href="#Trace原理" class="headerlink" title="Trace原理"></a>Trace原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_TRACE_POINT_REGISTER(trace, name) \</span></span><br><span class="line"><span class="meta">rte_trace_point_t __attribute__((section(<span class="string">"__rte_trace_point"</span>))) __##trace; \</span></span><br><span class="line"><span class="meta">static const char __##trace##_name[] = RTE_STR(name); \</span></span><br><span class="line"><span class="meta">RTE_INIT(trace##_init) \</span></span><br><span class="line"><span class="meta">{ \</span></span><br><span class="line"><span class="meta">	__rte_trace_point_register(&amp;__##trace, __##trace##_name, \</span></span><br><span class="line"><span class="meta">		(void (*)(void)) trace); \</span></span><br><span class="line"><span class="meta">}</span></span><br></pre></td></tr></table></figure>

<p>其中<code>rte_trace_point_t</code>类型就是对追踪点的抽象，该类型各位的含义如下：</p>
<ul>
<li>0~15位记录该tracepoint需要记录的数据长度</li>
<li>16~47位记录在trace链表中处于第几个（用作ctf中的事件id）</li>
<li>62位记录trace模式（overwrite/discard）,63位记录该tracepoint是否使能</li>
</ul>
<p>重要的是<code>__rte_trace_point_register</code>函数，该函数主要的工作如下：</p>
<ul>
<li>是生成event CTF metadata</li>
<li>设置该追踪点的<code>rte_trace_point_t</code></li>
<li>将上述内容封装成<code>struct trace_point</code>结构挂到<code>tp_list</code>这个全局链表上</li>
</ul>
<p>这些追踪点的注册都是在main之前完成，而后会在<code>eal_trace_init</code>中做最终的初始化</p>
<p><code>eal_trace_init()</code>主要工作如下：</p>
<ul>
<li>生成CTF TSDL(<em>Trace Stream Description Language</em>) metadata，包含<code>tp_list</code>上的event metadata</li>
<li>根据运行参数使能对应的追踪点</li>
</ul>
<p>初始化完成后，trace模块就开始运行了。在运行期间每个lcore都会有一个<code>struct __rte_trace_header</code>变量，该结构用于记录CTF的stream data，也就是我们所追踪的运行期间的数据了。</p>
<p>最终CTF文件的生成可通过调用<code>rte_trace_save()</code>函数，或者直接结束程序从而将trace数据dump到指定目录中进行查看。</p>
<h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h2><p>用于进行中断处理，包括device中断和alarm中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rte_eal_intr_init()</span><br></pre></td></tr></table></figure>

<p>创建中断处理线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_noreturn <span class="type">uint32_t</span> <span class="title function_">eal_intr_thread_main</span><span class="params">(__rte_unused <span class="type">void</span> *arg)</span></span><br></pre></td></tr></table></figure>



<h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>使用中断源<code>intr_handle</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_alarm_set</span><span class="params">(<span class="type">uint64_t</span> us, rte_eal_alarm_callback cb_fn, <span class="type">void</span> *cb_arg)</span>	<span class="comment">//alarm注册</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_alarm_cancel</span><span class="params">(rte_eal_alarm_callback cb_fn, <span class="type">void</span> *cb_arg)</span>			<span class="comment">//alarm取消</span></span><br></pre></td></tr></table></figure>

<p>alarm注册后默认只运行一次<code>cb_fn</code>，要想使用周期性的alarm，需要手动在<code>cb_fn</code>中调用<code>rte_eal_alarm_set</code>函数。</p>
<h2 id="Multi-process"><a href="#Multi-process" class="headerlink" title="Multi-process"></a>Multi-process</h2><h3 id="多进程通讯"><a href="#多进程通讯" class="headerlink" title="多进程通讯"></a>多进程通讯</h3><p>多进程通讯，包含两种通讯模式：</p>
<ul>
<li>单播通讯：secondary向primary的通讯方式</li>
<li>广播通讯：primary向secondary的通讯方式</li>
</ul>
<p>DPDK的IPC分为3类：</p>
<ol>
<li>Message：通知，不需要回复。</li>
<li>Synchronous request：同步的请求，发送端发送请求后进入阻塞（需设置响应超时时间），直到接收到所有响应或者阻塞超时返回到请求函数中进行处理，处理完成后从请求中返回。</li>
<li>Asynchronous request：异步的请求，发送端发送请求后，设置响应超时alarm以及回调函数，而后立即从请求中返回。当收到所有响应或者alarm超时时，调用回调函数进行处理（收到所有响应的处理在<code>mp-msg</code>线程中处理，alarm超时在<code>intr</code>线程中处理）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_mp_action_register</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rte_mp_t</span> action)</span>	<span class="comment">//接收端注册需要处理的信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">mp_handle</span><span class="params">(<span class="type">void</span> *arg __rte_unused)</span>				<span class="comment">//多进程通讯控制函数，负责接收和处理收到数据</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//请求</span></span><br><span class="line"><span class="keyword">struct</span> rte_mp_msg {</span><br><span class="line">	<span class="type">char</span> name[RTE_MP_MAX_NAME_LEN];</span><br><span class="line">	<span class="type">int</span> len_param;</span><br><span class="line">	<span class="type">int</span> num_fds;</span><br><span class="line">	<span class="type">uint8_t</span> param[RTE_MP_MAX_PARAM_LEN];</span><br><span class="line">	<span class="type">int</span> fds[RTE_MP_MAX_FD_NUM];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mp_reply</span> {</span></span><br><span class="line">	<span class="type">int</span> nb_sent;</span><br><span class="line">	<span class="type">int</span> nb_received;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mp_msg</span> *<span class="title">msgs</span>;</span> <span class="comment">/* caller to free */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送端发送通知</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_mp_sendmsg</span><span class="params">(<span class="keyword">struct</span> rte_mp_msg *msg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送端发送同步的请求，阻塞的请求挂在mp_request_list上</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_mp_request_sync</span><span class="params">(<span class="keyword">struct</span> rte_mp_msg *req, 		<span class="comment">//请求的信息</span></span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> rte_mp_reply *reply,		<span class="comment">//响应的信息</span></span></span><br><span class="line"><span class="params">						<span class="type">const</span> <span class="keyword">struct</span> timespec *ts		<span class="comment">//超时时间</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">rte_mp_async_reply_t</span>)</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_mp_msg *request,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> rte_mp_reply *reply)</span></span><br><span class="line"><span class="comment">//发送端发送异步的请求，异步的请求挂在pending_requests上</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_mp_request_async</span><span class="params">(<span class="keyword">struct</span> rte_mp_msg *req, 		<span class="comment">//请求的信息</span></span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="keyword">struct</span> timespec *ts,		<span class="comment">//超时时间</span></span></span><br><span class="line"><span class="params">                         <span class="type">rte_mp_async_reply_t</span> clb		<span class="comment">//回调函数</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>在使用IPC进行进程间通讯时，不能使用dpdk的malloc和free，因为dpdk的malloc和free内部也使用了IPC，这样做可能会导致死锁。</p>
<h3 id="多进程内存共享"><a href="#多进程内存共享" class="headerlink" title="多进程内存共享"></a>多进程内存共享</h3><ul>
<li>primary进程：进行大页内存的初始化</li>
<li>secondary进程：进行大页内存的同步</li>
</ul>
<p>在Dynamic Memory Mode下，大页内存的申请/释放只在primary进程中处理，secondary在进行堆内存申请/释放时，如果需要对堆大小做更新（也就是需要对大页内存做申请或释放），就需要利用DPDK的IPC机制向primary进程请求大页内存的申请或释放，而后通过大页内存的同步，完成对堆大小的调整，进而满足对内存申请/释放的要求。</p>
<blockquote>
<p>Note：禁止使用函数指针作为共享数据（因为内核默认开启ASLR（Address space layout randomization）地址随机化，gcc默认配置了PIE（Position-Independent Executable file），会使得代码段和数据段也可以适用ASLR的随机化，这样就导致了代码段的函数的地址在各进程中不同，因此禁止使用函数指针作为共享数据）</p>
<p>readelf –headers XXX  可以查看该elf文件是否启用了PIE（Type字段）。</p>
</blockquote>
<p>secondary对大页内存申请/释放的流程有些复杂，下面列出其工作流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General workflow is the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocation:</span></span><br><span class="line"><span class="comment"> * S: send request to primary</span></span><br><span class="line"><span class="comment"> * P: attempt to allocate memory</span></span><br><span class="line"><span class="comment"> *    if failed, sendmsg failure</span></span><br><span class="line"><span class="comment"> *    if success, send sync request</span></span><br><span class="line"><span class="comment"> * S: if received msg of failure, quit</span></span><br><span class="line"><span class="comment"> *    if received sync request, synchronize memory map and reply with result</span></span><br><span class="line"><span class="comment"> * P: if received sync request result</span></span><br><span class="line"><span class="comment"> *    if success, sendmsg success</span></span><br><span class="line"><span class="comment"> *    if failure, roll back allocation and send a rollback request</span></span><br><span class="line"><span class="comment"> * S: if received msg of success, quit</span></span><br><span class="line"><span class="comment"> *    if received rollback request, synchronize memory map and reply with result</span></span><br><span class="line"><span class="comment"> * P: if received sync request result</span></span><br><span class="line"><span class="comment"> *    sendmsg sync request result</span></span><br><span class="line"><span class="comment"> * S: if received msg, quit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Aside from timeouts, there are three points where we can quit:</span></span><br><span class="line"><span class="comment"> *  - if allocation failed straight away</span></span><br><span class="line"><span class="comment"> *  - if allocation and sync request succeeded</span></span><br><span class="line"><span class="comment"> *  - if allocation succeeded, sync request failed, allocation rolled back and</span></span><br><span class="line"><span class="comment"> *    rollback request received (irrespective of whether it succeeded or failed)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Deallocation:</span></span><br><span class="line"><span class="comment"> * S: send request to primary</span></span><br><span class="line"><span class="comment"> * P: attempt to deallocate memory</span></span><br><span class="line"><span class="comment"> *    if failed, sendmsg failure</span></span><br><span class="line"><span class="comment"> *    if success, send sync request</span></span><br><span class="line"><span class="comment"> * S: if received msg of failure, quit</span></span><br><span class="line"><span class="comment"> *    if received sync request, synchronize memory map and reply with result</span></span><br><span class="line"><span class="comment"> * P: if received sync request result</span></span><br><span class="line"><span class="comment"> *    sendmsg sync request result</span></span><br><span class="line"><span class="comment"> * S: if received msg, quit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is no "rollback" from deallocation, as it's safe to have some memory</span></span><br><span class="line"><span class="comment"> * mapped in some processes - it's absent from the heap, so it won't get used.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>secondary对大页内存的同步：</p>
<p>secondary为什么要单独复制一份<code>local_memsegs[]</code>？</p>
<p>dpdk仅在需要使用大页内存的时候向memsegs申请并映射大页内存，在memsegs中并不是所有的地址都进行了大页映射。在多进程下会导致一个问题，就是辅进程无法得知共享内存所映射的memsegs中的内存哪些是已经进行大页映射了的，哪些没有进行大页映射。因此需要一个进程间同步的机制，在主进程进行大页内存的申请和映射时，告知所有辅进程。辅进程想要申请大页内存时，通知主进程进行大页内存的申请和映射，主进程申请完毕后告知辅进程。</p>
<p>dpdk次进程需要单独复制一份local_memsegs[]的原因就在于此，次进程拥有一份本地的memsegs，当主进程更新memsegs的映射关系时，次进程可以通过local_memsegs这个本地的memsegs与主进程中的memsegs进行比较，找出需要同步的内存，然后在次进程完成映射关系。</p>
<p>如果次进程不使用local_memsegs，在每次主进程进行memsegs更新时(可能是申请大页，也可能是释放大页)，次进程就无法得知memsegs哪部分内存做了更新，也就无法做到主次进程的大页内存的同步。</p>
<h2 id="Memory-Hugepage"><a href="#Memory-Hugepage" class="headerlink" title="Memory&Hugepage"></a>Memory&amp;Hugepage</h2><p>DPDK目前支持两种内存模式：</p>
<ul>
<li><p>Legacy Memory Mode：如果配置了<code>-m</code>或者<code>--socket-mem</code>选项，则预先占用所配置的大页内存作为堆内存，否则占用系统中所有的大页内存。该模式下连续的va对应的iova一定连续。</p>
</li>
<li><p>Dynamic Memory Mode：如果配置了<code>-m</code>或者<code>--socket-mem</code>选项，则预先占用所配置的大页内存作为堆内存（这些内存程序运行期间不会释放），否则按需申请释放内存。该模式下连续的va对应的iova不一定连续。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录大页信息，不使用大页的情况下无需配置该数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hugepage_info</span> {</span></span><br><span class="line">	<span class="type">uint64_t</span> hugepage_sz;   <span class="comment">/**&lt; size of a huge page */</span></span><br><span class="line">	<span class="comment">//若指定了挂载点则更新为指定的挂载点</span></span><br><span class="line">	<span class="type">char</span> hugedir[PATH_MAX];    <span class="comment">/**&lt; dir where hugetlbfs is mounted */</span></span><br><span class="line">	<span class="type">uint32_t</span> num_pages[RTE_MAX_NUMA_NODES];</span><br><span class="line">	<span class="comment">/**&lt; number of hugepages of that size on each socket */</span></span><br><span class="line">	<span class="type">int</span> lock_descriptor;    <span class="comment">/**&lt; file descriptor for hugepage dir */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>VA地址空间的分配（没有使能<code>--no-huge</code>的情况下，在<code>rte_eal_hugepage_init()</code>之前运行）：</p>
<ol>
<li><p>根据系统的numa数和pagesize数产生numa*pagesize种类型（保证了每个segment所对应的保留文件所处的socket在application restart后不变）</p>
</li>
<li><p>每种类型包含多个segment list，每个segment list包含多个segment，每个segment对应一个page</p>
</li>
<li><p>所有segment list存储在memsegs[RTE_MAX_MEMSEG_LISTS]中</p>
</li>
<li><p>每个segment list中的segment采用rte_fbarray管理，每个segment list会一次性申请所有的segment，这些segment是va连续的。</p>
</li>
<li><p>fd_list[RTE_MAX_MEMSEG_LISTS]存储对应segment list的fd</p>
</li>
</ol>
<p>rte_fbarray(File-backed shared indexed array)：数组末尾存储位图，记录数组分配状况。创建文件，实现数组共享。</p>
<p>mem_area_tailq：记录用于共享内存的文件fd及其相关信息（用于查看待映射的地址是否与以映射的地址冲突，解除映射时用于查找fd并删除该文件）</p>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>dpdk的所映射的大页内存是通过heap来进行管理的，heap将大页内存封装成一个个<code>struct malloc_elem</code>块，块大小包括结构体本身。</p>
<p><a href="/images/malloc_heap.svg" title="heap" class="gallery-item" style="box-shadow: none;"> <img src="/images/malloc_heap.svg" alt="heap"></a></p>
<h3 id="Memory-Zone"><a href="#Memory-Zone" class="headerlink" title="Memory Zone"></a>Memory Zone</h3><p>用于记录从Heap中申请的大片VA连续的内存，每个memzone都有唯一的名字。memzone本身使用rte_fbarray管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reserve a portion of physical memory with specified alignment and</span></span><br><span class="line"><span class="comment"> * boundary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function reserves some memory with specified alignment and</span></span><br><span class="line"><span class="comment"> * boundary, and returns a pointer to a correctly filled memzone</span></span><br><span class="line"><span class="comment"> * descriptor. If the allocation cannot be done or if the alignment</span></span><br><span class="line"><span class="comment"> * or boundary are not a power of 2, returns NULL.</span></span><br><span class="line"><span class="comment"> * Memory buffer is reserved in a way, that it wouldn't cross specified</span></span><br><span class="line"><span class="comment"> * boundary. That implies that requested length should be less or equal</span></span><br><span class="line"><span class="comment"> * then boundary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note Reserving memzones with len set to 0 will only attempt to allocate</span></span><br><span class="line"><span class="comment"> *   memzones from memory that is already available. It will not trigger any</span></span><br><span class="line"><span class="comment"> *   new allocations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note: When reserving memzones with len set to 0, it is preferable to also</span></span><br><span class="line"><span class="comment"> *   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but</span></span><br><span class="line"><span class="comment"> *   will likely not yield expected results. Specifically, the resulting memzone</span></span><br><span class="line"><span class="comment"> *   may not necessarily be the biggest memzone available, but rather biggest</span></span><br><span class="line"><span class="comment"> *   memzone available on socket id corresponding to an lcore from which</span></span><br><span class="line"><span class="comment"> *   reservation was called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name</span></span><br><span class="line"><span class="comment"> *   The name of the memzone. If it already exists, the function will</span></span><br><span class="line"><span class="comment"> *   fail and return NULL.</span></span><br><span class="line"><span class="comment"> * @param len</span></span><br><span class="line"><span class="comment"> *   The size of the memory to be reserved. If it</span></span><br><span class="line"><span class="comment"> *   is 0, the biggest contiguous zone will be reserved.</span></span><br><span class="line"><span class="comment"> * @param socket_id</span></span><br><span class="line"><span class="comment"> *   The socket identifier in the case of</span></span><br><span class="line"><span class="comment"> *   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA</span></span><br><span class="line"><span class="comment"> *   constraint for the reserved zone.</span></span><br><span class="line"><span class="comment"> * @param flags</span></span><br><span class="line"><span class="comment"> *   The flags parameter is used to request memzones to be</span></span><br><span class="line"><span class="comment"> *   taken from specifically sized hugepages.</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_2MB - Reserved from 2MB pages</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_1GB - Reserved from 1GB pages</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_16MB - Reserved from 16MB pages</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_16GB - Reserved from 16GB pages</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_256KB - Reserved from 256KB pages</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_256MB - Reserved from 256MB pages</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_512MB - Reserved from 512MB pages</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_4GB - Reserved from 4GB pages</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if</span></span><br><span class="line"><span class="comment"> *                                  the requested page size is unavailable.</span></span><br><span class="line"><span class="comment"> *                                  If this flag is not set, the function</span></span><br><span class="line"><span class="comment"> *                                  will return error on an unavailable size</span></span><br><span class="line"><span class="comment"> *                                  request.</span></span><br><span class="line"><span class="comment"> *   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous.</span></span><br><span class="line"><span class="comment"> *                               This option should be used when allocating</span></span><br><span class="line"><span class="comment"> *                               memory intended for hardware rings etc.</span></span><br><span class="line"><span class="comment"> * @param align</span></span><br><span class="line"><span class="comment"> *   Alignment for resulting memzone. Must be a power of 2.</span></span><br><span class="line"><span class="comment"> * @param bound</span></span><br><span class="line"><span class="comment"> *   Boundary for resulting memzone. Must be a power of 2 or zero.</span></span><br><span class="line"><span class="comment"> *   Zero value implies no boundary condition.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   A pointer to a correctly-filled read-only memzone descriptor, or NULL</span></span><br><span class="line"><span class="comment"> *   on error.</span></span><br><span class="line"><span class="comment"> *   On error case, rte_errno will be set appropriately:</span></span><br><span class="line"><span class="comment"> *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure</span></span><br><span class="line"><span class="comment"> *    - ENOSPC - the maximum number of memzones has already been allocated</span></span><br><span class="line"><span class="comment"> *    - EEXIST - a memzone with the same name already exists</span></span><br><span class="line"><span class="comment"> *    - ENOMEM - no appropriate memory area found in which to create memzone</span></span><br><span class="line"><span class="comment"> *    - EINVAL - invalid parameters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> rte_memzone *<span class="title function_">rte_memzone_reserve_bounded</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">			<span class="type">size_t</span> len, <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> flags, <span class="type">unsigned</span> align, <span class="type">unsigned</span> bound)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Legacy-Memory-Mode"><a href="#Legacy-Memory-Mode" class="headerlink" title="Legacy Memory Mode"></a>Legacy Memory Mode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eal_legacy_hugepage_init</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>不使用大页的情况下：</p>
<ol>
<li>使能single-file，利用memfd_create创建匿名内存</li>
<li>不考虑多numa且只使用4k的page</li>
<li>将所需要的内存数都配置到<code>segments[0]</code>上</li>
<li>segment的iova只支持配置va</li>
</ol>
</li>
<li><p>使用大页的情况下</p>
<ol>
<li><p>每个大页文件对应一个<code>struct hugepage_file</code>用于多进程共享</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//primary设置，secondary读取</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hugepage_file</span> {</span></span><br><span class="line">	<span class="comment">//第一次先映射所有大页内存，用于寻找iova连续的大页组</span></span><br><span class="line">	<span class="type">void</span> *orig_va;      <span class="comment">/**&lt; virtual addr of first mmap() */</span></span><br><span class="line">	<span class="comment">//第二次将iova连续的大页内存映射到va连续的地址上</span></span><br><span class="line">	<span class="type">void</span> *final_va;     <span class="comment">/**&lt; virtual addr of 2nd mmap() */</span></span><br><span class="line">	<span class="comment">//iova</span></span><br><span class="line">	<span class="type">uint64_t</span> physaddr;  <span class="comment">/**&lt; physical addr */</span></span><br><span class="line">	<span class="type">size_t</span> size;        <span class="comment">/**&lt; the page size */</span></span><br><span class="line">	<span class="type">int</span> socket_id;      <span class="comment">/**&lt; NUMA socket ID */</span></span><br><span class="line">	<span class="type">int</span> file_id;        <span class="comment">/**&lt; the '%d' in HUGEFILE_FMT */</span></span><br><span class="line">	<span class="type">char</span> filepath[MAX_HUGEPAGE_PATH]; <span class="comment">/**&lt; path to backing file on filesystem */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</li>
<li><p>先申请系统中所有的大页内存（是否采用numa感知取决于配置参数）</p>
</li>
<li><p>读取<code>/proc/self/numa_maps</code>文件确定大页所处的socket_id</p>
</li>
<li><p>根据所申请到的大页数更新<code>internal_conf-&gt;hugepage_info</code></p>
</li>
<li><p>根据配置计算各numa所需要的不同尺寸的大页数（若没有配置<code>--socket-num</code>，则尽可能按照lcore在各node的比例来分配）</p>
</li>
<li><p>根据要求释放不需要的大页</p>
</li>
<li><p>遍历<code>struct hugepage_file</code>，找出iova连续的大页组，并将其映射到segments中（也就是将iova连续的大页内存映射到va连续的地址上）</p>
</li>
<li><p>各大页组所对应的segment之间会留出一个空闲的segment，使得iova连续与va连续一一对应</p>
</li>
<li><p>由于后续不再进行大页的分配与释放，因此释放没有用到的<code>segment list</code></p>
</li>
</ol>
</li>
</ul>
<h3 id="Dynamic-Memory-Mode"><a href="#Dynamic-Memory-Mode" class="headerlink" title="Dynamic Memory Mode"></a>Dynamic Memory Mode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eal_dynmem_hugepage_init</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>



<h2 id="Tailq"><a href="#Tailq" class="headerlink" title="Tailq"></a>Tailq</h2><p>位于<code>rte_eal_get_configuration()-&gt;mem_config</code>的<code>tailq_head[]</code>字段，用于多进程数据共享。</p>
<h2 id="Service-Core"><a href="#Service-Core" class="headerlink" title="Service Core"></a>Service Core</h2><p>service：服务，可视为需要CPU运行的任务</p>
<p>service core：服务核，运行服务的线程</p>
<p>使得用户所设置的任务和执行任务的线程可以更加灵活的配置，服务核通过调用<code>service_runner_func()</code>去运行注册到该核上的服务，而服务本身，可以通过注册，启动等流程，将其放到指定的服务核上运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于管理服务的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_service_spec_impl</span> {</span></span><br><span class="line">	<span class="comment">/* public part of the struct */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_service_spec</span> <span class="title">spec</span>;</span>	<span class="comment">//用户注册的服务</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* spin lock that when set indicates a service core is currently</span></span><br><span class="line"><span class="comment">	 * running this service callback. When not set, a core may take the</span></span><br><span class="line"><span class="comment">	 * lock and then run the service callback.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">rte_spinlock_t</span> execute_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* API set/get-able variables */</span></span><br><span class="line">	RTE_ATOMIC(<span class="type">int8_t</span>) app_runstate;	<span class="comment">//表示服务是否要执行，应用程序设置</span></span><br><span class="line">	RTE_ATOMIC(<span class="type">int8_t</span>) comp_runstate;	<span class="comment">//表示服务是否可运行，服务本身设置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVICE_F_REGISTERED    (1 &lt;&lt; 0)	<span class="comment">//服务注册</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVICE_F_STATS_ENABLED (1 &lt;&lt; 1)	<span class="comment">//服务统计功能</span></span></span><br><span class="line"><span class="comment">/* 判断服务是否在service core上运行时，用到了该标志位。</span></span><br><span class="line"><span class="comment"> * 为1时表示需要检查该服务是否有绑定到service core去运行。</span></span><br><span class="line"><span class="comment"> * 为0时表示不需要检查，这种情况下可能是应用程序手动调用rte_service_run_iter_on_app_lcore()函数执行服务，</span></span><br><span class="line"><span class="comment"> * 并没有将该服务绑定到service core上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVICE_F_START_CHECK   (1 &lt;&lt; 2)</span></span><br><span class="line">	<span class="type">uint8_t</span> internal_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* per service statistics */</span></span><br><span class="line">	<span class="comment">/* Indicates how many cores the service is mapped to run on.</span></span><br><span class="line"><span class="comment">	 * It does not indicate the number of cores the service is running</span></span><br><span class="line"><span class="comment">	 * on currently.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_ATOMIC(<span class="type">uint32_t</span>) num_mapped_cores;</span><br><span class="line">} __rte_cache_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户所设置的服务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_service_spec</span> {</span></span><br><span class="line">	<span class="comment">/** The name of the service. This should be used by the application to</span></span><br><span class="line"><span class="comment">	 * understand what purpose this service provides.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> name[RTE_SERVICE_NAME_MAX];</span><br><span class="line">	<span class="comment">/** The callback to invoke to run one iteration of the service. */</span></span><br><span class="line">	rte_service_func callback;</span><br><span class="line">	<span class="comment">/** The userdata pointer provided to the service callback. */</span></span><br><span class="line">	<span class="type">void</span> *callback_userdata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Flags to indicate the capabilities of this service. See defines in</span></span><br><span class="line"><span class="comment"> * the public header file for values of RTE_SERVICE_CAP_*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_SERVICE_CAP_MT_SAFE (1 &lt;&lt; 0)</span></span><br><span class="line">	<span class="type">uint32_t</span> capabilities;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** NUMA socket ID that this service is affinitized to */</span></span><br><span class="line">	<span class="type">int</span> socket_id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务注册，默认注册后服务处于不可运行状态</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_component_register</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_service_spec *spec,</span></span><br><span class="line"><span class="params">		<span class="type">uint32_t</span> *service_id)</span>;	<span class="comment">//服务id，用户可使用id来表示该服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由服务本身设置，表示该服务处于可运行状态</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_component_runstate_set</span><span class="params">(<span class="type">uint32_t</span> id, <span class="type">uint32_t</span> runstate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由应用程序设置，表示是否运行该服务</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_runstate_set</span><span class="params">(<span class="type">uint32_t</span> id, <span class="type">uint32_t</span> runstate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为服务分配service core</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_map_lcore_set</span><span class="params">(<span class="type">uint32_t</span> service_id, <span class="type">uint32_t</span> lcore,</span></span><br><span class="line"><span class="params">		<span class="type">uint32_t</span> enable)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于管理服务核的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> {</span></span><br><span class="line">	<span class="comment">/* map of services IDs are run on this core */</span></span><br><span class="line">	<span class="type">uint64_t</span> service_mask;</span><br><span class="line">	RTE_ATOMIC(<span class="type">uint8_t</span>) runstate; <span class="comment">/* running or stopped */</span></span><br><span class="line">	RTE_ATOMIC(<span class="type">uint8_t</span>) thread_active; <span class="comment">/* indicates when thread is in service_run() */</span></span><br><span class="line">	<span class="type">uint8_t</span> is_service_core; <span class="comment">/* set if core is currently a service core */</span></span><br><span class="line">	<span class="type">uint8_t</span> service_active_on_lcore[RTE_SERVICE_NUM_MAX];</span><br><span class="line">	RTE_ATOMIC(<span class="type">uint64_t</span>) loops;</span><br><span class="line">	RTE_ATOMIC(<span class="type">uint64_t</span>) cycles;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">service_stats</span> <span class="title">service_stats</span>[<span class="title">RTE_SERVICE_NUM_MAX</span>];</span>	<span class="comment">//各服务在该核上的统计信息</span></span><br><span class="line">} __rte_cache_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务核的添加</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_add</span><span class="params">(<span class="type">uint32_t</span> lcore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务核的运行</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_service_lcore_start</span><span class="params">(<span class="type">uint32_t</span> lcore_id)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总体来说API使用较为繁琐，不是很好用。</p>
</blockquote>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><p>DPDK日志支持syslog的配置，ubuntu系统可通过下面命令查看syslog日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -t dpdk-test</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志初始化函数，添加内置的日志类型</span></span><br><span class="line">RTE_INIT_PRIO(log_init, LOG)</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志类型注册</span></span><br><span class="line">RTE_LOG_REGISTER(type, name, level)</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志打印函数，l指定日志等级，t指定日志类型，后面为日志内容</span></span><br><span class="line">RTE_LOG(l, t, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志打印函数，与上面不同的是，如果l的等级低于RTE_LOG_DP_LEVEL，则该宏会在编译时展开为空</span></span><br><span class="line">RTE_LOG_DP(l, t, ...)</span><br></pre></td></tr></table></figure>



<h1 id="Command-line"><a href="#Command-line" class="headerlink" title="Command-line"></a>Command-line</h1><h2 id="命令参数类型"><a href="#命令参数类型" class="headerlink" title="命令参数类型"></a>命令参数类型</h2><ul>
<li><p>字符串</p>
<ul>
<li>cmdline_fixed_string_t，一个token</li>
<li>cmdline_multi_string_t，任意个token，只能作为命令的最后一个参数</li>
</ul>
</li>
<li><p>IP地址</p>
<ul>
<li>cmdline_ipaddr_t，ipv4/ipv6</li>
</ul>
</li>
<li><p>MAC地址</p>
<ul>
<li>struct rte_ether_addr</li>
</ul>
</li>
<li><p>数字</p>
<ul>
<li><p>uint8_t、uint16_t、uint32_t、uint64_t、int8_t、int16_t、int32_t、int64_t</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cmdline_numtype</span> {</span></span><br><span class="line">	RTE_UINT8 = <span class="number">0</span>,</span><br><span class="line">	RTE_UINT16,</span><br><span class="line">	RTE_UINT32,</span><br><span class="line">	RTE_UINT64,</span><br><span class="line">	RTE_INT8,</span><br><span class="line">	RTE_INT16,</span><br><span class="line">	RTE_INT32,</span><br><span class="line">	RTE_INT64</span><br><span class="line">};</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="命令注册"><a href="#命令注册" class="headerlink" title="命令注册"></a>命令注册</h2><ol>
<li><p>确定要注册命令的格式，例：<code>echo string_mac_ip_number/smin &lt;STRING&gt;str &lt;MAC&gt;mac &lt;IP&gt;ip &lt;INT64&gt;n</code></p>
</li>
<li><p>定义命令结果结构体，该结构体用于存储解析后的各字段的内容</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_echo_string_mac_ip_number_result</span> {</span></span><br><span class="line">   <span class="type">cmdline_fixed_string_t</span> echo;</span><br><span class="line">   <span class="type">cmdline_fixed_string_t</span> string_mac_ip_number;</span><br><span class="line">   <span class="type">cmdline_fixed_string_t</span> str;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span>  <span class="title">mac</span>;</span></span><br><span class="line">   <span class="type">cmdline_ipaddr_t</span>       ip;</span><br><span class="line">   <span class="type">int64_t</span>                n;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供命令各字段的初始化</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">cmdline_parse_token_string_t</span> cmd_echo_string_mac_ip_number_echo_tok =</span><br><span class="line">   TOKEN_STRING_INITIALIZER(<span class="keyword">struct</span> cmd_echo_string_mac_ip_number_result, echo, <span class="string">"echo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">cmdline_parse_token_string_t</span> cmd_echo_string_mac_ip_number_string_mac_ip_number_tok =</span><br><span class="line">   TOKEN_STRING_INITIALIZER(<span class="keyword">struct</span> cmd_echo_string_mac_ip_number_result, string_mac_ip_number, <span class="string">"string_mac_ip_number#smin"</span>);	<span class="comment">//若该token可以匹配多个字符串，字符串之间可用#分割</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">cmdline_parse_token_string_t</span> cmd_echo_string_mac_ip_number_str_tok =</span><br><span class="line">   TOKEN_STRING_INITIALIZER(<span class="keyword">struct</span> cmd_echo_string_mac_ip_number_result, str, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">cmdline_parse_token_etheraddr_t</span> cmd_echo_string_mac_ip_number_mac_tok =</span><br><span class="line">   TOKEN_ETHERADDR_INITIALIZER(<span class="keyword">struct</span> cmd_echo_string_mac_ip_number_result, mac);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">cmdline_parse_token_ipaddr_t</span> cmd_echo_string_mac_ip_number_ip_tok =</span><br><span class="line">   TOKEN_IPADDR_INITIALIZER(<span class="keyword">struct</span> cmd_echo_string_mac_ip_number_result, ip);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">cmdline_parse_token_num_t</span> cmd_echo_string_mac_ip_number_n_tok =</span><br><span class="line">   TOKEN_NUM_INITIALIZER(<span class="keyword">struct</span> cmd_echo_string_mac_ip_number_result, n, RTE_INT64);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义命令回调函数</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cmd_echo_string_mac_ip_number_parsed</span><span class="params">(<span class="type">void</span> *parsed_result, 	<span class="comment">//命令结果结构体</span></span></span><br><span class="line"><span class="params">                                     <span class="keyword">struct</span> cmdline *cl, 	<span class="comment">//命令行实例使用，可以无视该参数</span></span></span><br><span class="line"><span class="params">                                     <span class="type">void</span> *data)</span>			<span class="comment">//用户自定义数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义该命令的解析实例，用于最终的命令注册</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">cmdline_parse_inst_t</span> cmd_echo_string_mac_ip_number = {</span><br><span class="line">    .f = cmd_echo_string_mac_ip_number_parsed,</span><br><span class="line">    .data = <span class="literal">NULL</span>,	<span class="comment">//用户自定义数据，回调函数使用</span></span><br><span class="line">    .help_str = <span class="string">"Echo string and mac and ip and number"</span>,</span><br><span class="line">    .tokens = {</span><br><span class="line">        (<span class="type">void</span> *)&amp;cmd_echo_string_mac_ip_number_echo_tok,</span><br><span class="line">        (<span class="type">void</span> *)&amp;cmd_echo_string_mac_ip_number_string_mac_ip_number_tok,</span><br><span class="line">        (<span class="type">void</span> *)&amp;cmd_echo_string_mac_ip_number_str_tok,</span><br><span class="line">        (<span class="type">void</span> *)&amp;cmd_echo_string_mac_ip_number_mac_tok,</span><br><span class="line">        (<span class="type">void</span> *)&amp;cmd_echo_string_mac_ip_number_ip_tok,</span><br><span class="line">        (<span class="type">void</span> *)&amp;cmd_echo_string_mac_ip_number_n_tok,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</li>
<li><p>将该命令添加到命令解析上下文中，该上下文存储着需要注册的所有命令</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static cmdline_parse_ctx_t ctx[] = {</span><br><span class="line">    &amp;cmd_echo_string_mac_ip_number,</span><br><span class="line">    ...</span><br><span class="line">    NULL</span><br><span class="line">};</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="命令行实例的创建与运行"><a href="#命令行实例的创建与运行" class="headerlink" title="命令行实例的创建与运行"></a>命令行实例的创建与运行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmdline</span> *<span class="title">cl</span>;</span></span><br><span class="line"><span class="type">int</span> fd = open(startup_file, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) {</span><br><span class="line">    cl = cmdline_new(ctx, <span class="string">""</span>, fd, STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">/* error handling */</span></span><br><span class="line">    }</span><br><span class="line">    cmdline_interact(cl);</span><br><span class="line">    cmdline_quit(cl);</span><br><span class="line">    close(fd);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cl = cmdline_stdin_new(ctx, <span class="string">"Proxy&gt;&gt; "</span>);</span><br><span class="line"><span class="keyword">if</span> (cl == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="comment">/* error handling */</span></span><br><span class="line">}</span><br><span class="line">cmdline_interact(cl);</span><br><span class="line">cmdline_stdin_exit(cl);</span><br></pre></td></tr></table></figure>



<h2 id="Generator-Script"><a href="#Generator-Script" class="headerlink" title="Generator Script"></a>Generator Script</h2><p>此外还可以通过执行<code>dpdk-cmdline-gen.py</code>脚本来生成命令注册的代码，该脚本以命令列表文件作为输入，并输出相应代码（<code>--stubs</code>还可以生成回调函数的模板）。命令列表文件的内容格式要求如下：</p>
<ul>
<li>每行对应一条命令</li>
<li>行首为<code>#</code>的行为注释行</li>
<li>命令后可加<code>#</code>，注释符后面的内容为该命令的帮助字段</li>
<li>仅支持参数为：<ul>
<li>单token的字符串</li>
<li>IP地址</li>
<li>数字</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># example list file</span><br><span class="line">list                     # show all entries</span><br><span class="line">add &lt;UINT16&gt;x &lt;UINT16&gt;y  # add x and y</span><br><span class="line">echo &lt;STRING&gt;message     # print message to screen</span><br><span class="line">add socket &lt;STRING&gt;path  # add unix socket with the given path</span><br><span class="line">set mode &lt;(rx,tx)&gt;rxtx   # set Rx-only or Tx-only mode</span><br><span class="line">quit                     # close the application</span><br></pre></td></tr></table></figure>



<h1 id="Ring-Queue"><a href="#Ring-Queue" class="headerlink" title="Ring(Queue)"></a>Ring(Queue)</h1><p>循环队列，支持多生产者入队和多消费者出队，无锁化实现。</p>
<p>单消费者入队：</p>
<ol>
<li><p>复制<code>ring-&gt;prod_head</code>和<code>ring-&gt;cons_tail</code> 到本地变量中，判断是否有足够空间并且将本地变量<code>prod_next</code>指向待更新的位置</p>
<p><a href="/images/ring-enqueue1.svg" title="enqueue1" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-enqueue1.svg" alt="enqueue1"></a></p>
</li>
<li><p>将<code>ring-&gt;prod_head</code>更新为本地变量<code>prod_next</code>所指向的位置，并将待入队的元素obj4拷贝到ring中</p>
<p> <a href="/images/ring-enqueue2.svg" title="enqueue2" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-enqueue2.svg" alt="enqueue2"></a></p>
</li>
<li><p>将<code>ring-&gt;prod_tail</code>更新为<code>ring-&gt;prod_head</code>所指向的位置</p>
<p> <a href="/images/ring-enqueue3.svg" title="enqueue3" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-enqueue3.svg" alt="enqueue3"></a></p>
</li>
</ol>
<p>多消费者入队：</p>
<ol>
<li><p>所有core，都复制<code>ring-&gt;prod_head</code>和<code>ring-&gt;cons_tail</code> 到本地变量中，判断是否有足够空间并且将本地变量<code>prod_next</code>指向待更新的位置</p>
<p> <a href="/images/ring-mp-enqueue1.svg" title="mp_enqueue1" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-mp-enqueue1.svg" alt="mp_enqueue1"></a></p>
</li>
<li><p>所有core都使用CAS指令更新<code>ring-&gt;prod_head</code>为本地变量<code>prod_next</code>所指向的位置，这可能会产生两种结果：</p>
<ol>
<li>CAS失败，返回到第一步</li>
<li>CAS成功，继续下一步</li>
</ol>
<p> 这里假设core1成功，core2失败</p>
<p> <a href="/images/ring-mp-enqueue2.svg" title="mp_enqueue2" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-mp-enqueue2.svg" alt="mp_enqueue2"></a></p>
</li>
<li><p>core2在第二次执行CAS时成功，然后core1入队一个元素obj4，core2入队一个元素obj5</p>
<p> <a href="/images/ring-mp-enqueue3.svg" title="mp_enqueue3" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-mp-enqueue3.svg" alt="mp_enqueue3"></a></p>
</li>
<li><p>现在所有core都想要更新<code>ring-&gt;prod_tail</code>为本地变量<code>prod_next</code>所指向的位置，但只有<code>ring-&gt;prod_tail</code>和本地变量<code>prod_head </code>相等的core才被允许更新。因此这个操作在core1上完成</p>
<p> <a href="/images/ring-mp-enqueue4.svg" title="mp_enqueue4" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-mp-enqueue4.svg" alt="mp_enqueue4"></a></p>
</li>
<li><p>一旦core1上完成对<code>ring-&gt;prod_tail</code>的更新，core2也满足更新条件，因此这个操作也会在core2上完成</p>
<p> <a href="/images/ring-mp-enqueue5.svg" title="mp_enqueue5" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-mp-enqueue5.svg" alt="mp_enqueue5"></a></p>
</li>
</ol>
<p>在实际实现中，<code>prod_head</code>，<code>prod_tail</code>， <code>cons_head</code>和<code>cons_tail</code>使用32位无符号整数表示，并且通过与<code>ring-&gt;mask</code>进行位与操作来获取它们在ring中的位置。下面两个例子采用16位而非32位来说明：</p>
<p><a href="/images/ring-modulo1.svg" title="modulo1" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-modulo1.svg" alt="modulo1"></a></p>
<p><a href="/images/ring-modulo2.svg" title="modulo2" class="gallery-item" style="box-shadow: none;"> <img src="/images/ring-modulo2.svg" alt="modulo2"></a></p>
<blockquote>
<p>为了方便理解，例子中使用了模65535的运算，实际执行中这是多余的，因为结果溢出时会自动取模。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> {</span></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//ring的实际大小，为2的整数次幂</span></span><br><span class="line">	<span class="type">uint32_t</span> size;           <span class="comment">/**&lt; Size of ring. */</span></span><br><span class="line">    <span class="comment">//通过将head位与mask获得ring中的实际索引</span></span><br><span class="line">	<span class="type">uint32_t</span> mask;           <span class="comment">/**&lt; Mask (size-1) of ring. */</span></span><br><span class="line">    <span class="comment">//用户设置的ring的大小，小于size</span></span><br><span class="line">	<span class="type">uint32_t</span> capacity;       <span class="comment">/**&lt; Usable size of ring */</span></span><br><span class="line">	...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">*entries = (prod_tail - *old_head);	<span class="comment">//出队时计算</span></span><br><span class="line"><span class="comment">//因为生产者和消费者之间的距离总是保持在0~(capacity-1)之间，所以这里的减法不会导致溢出</span></span><br><span class="line">*free_entries = (capacity + cons_tail - *old_head);	<span class="comment">//入队时计算</span></span><br></pre></td></tr></table></figure>



<h2 id="生产者-消费者同步模式"><a href="#生产者-消费者同步模式" class="headerlink" title="生产者/消费者同步模式"></a>生产者/消费者同步模式</h2><p>dpdk支持不同的生产者消费者同步模式，以适应不同的使用环境：</p>
<ul>
<li><p>MP/MC(默认模式)：多生产者/多消费者模式，这在每lcore对应一个cpu的core时是最合适和最快速的同步模式。</p>
</li>
<li><p>SP/SC：单生产者/单消费者模式，仅在一次只会有一个线程操作ring时使用。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_headtail</span> {</span></span><br><span class="line">    <span class="comment">// MP/MC模式下head更新需要CAS，失败需要重新计算head值</span></span><br><span class="line">    <span class="comment">// SP/SC模式下head直接更新</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="title function_">RTE_ATOMIC</span><span class="params">(<span class="type">uint32_t</span>)</span> head;      <span class="comment">/**&lt; prod/consumer head. */</span></span><br><span class="line">    <span class="comment">// MP/MC模式下需要等到tail与本地head相等时才可更新</span></span><br><span class="line">    <span class="comment">// SP/SC模式下tail直接更新</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="title function_">RTE_ATOMIC</span><span class="params">(<span class="type">uint32_t</span>)</span> tail;      <span class="comment">/**&lt; prod/consumer tail. */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="comment">/** sync type of prod/cons */</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">rte_ring_sync_type</span> <span class="title">sync_type</span>;</span></span><br><span class="line">        <span class="comment">/** deprecated -  True if single prod/cons */</span></span><br><span class="line">        <span class="type">uint32_t</span> single;</span><br><span class="line">    };</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</li>
<li><p>MP_RTS/MC_RTS(Relaxed Tail Sync)：与MP/MC不同的是在多个生产者/消费者同时操作ring时，仅最后一个生产者/消费者更新<code>tail</code>，其他生产者/消费者不会等待更新<code>tail</code>。这避免了在多生产者/多消费者对ring操作过于频繁的情况下导致的Lock-Waiter-Preemption (LWP)问题。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> __<span class="title">rte_ring_rts_poscnt</span> {</span></span><br><span class="line">	<span class="comment">/** raw 8B value to read/write *cnt* and *pos* as one atomic op */</span></span><br><span class="line">	RTE_ATOMIC(<span class="type">uint64_t</span>) raw __rte_aligned(<span class="number">8</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="comment">//每更新一次cnt加一</span></span><br><span class="line">		<span class="type">uint32_t</span> cnt; <span class="comment">/**&lt; head/tail reference counter */</span></span><br><span class="line">		<span class="type">uint32_t</span> pos; <span class="comment">/**&lt; head/tail position */</span></span><br><span class="line">	} val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_rts_headtail</span> {</span></span><br><span class="line">    <span class="comment">// 非最后一个线程更新cnt，最后一个线程同时更新cnt和pos</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> __<span class="title">rte_ring_rts_poscnt</span> <span class="title">tail</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_ring_sync_type</span> <span class="title">sync_type</span>;</span>  <span class="comment">/**&lt; sync type of prod/cons */</span></span><br><span class="line">    <span class="comment">// 避免频繁的入队/出队所导致的tail迟迟不更新</span></span><br><span class="line">	<span class="type">uint32_t</span> htd_max;   <span class="comment">/**&lt; max allowed distance between head/tail */</span></span><br><span class="line">    <span class="comment">// 更新pos的同时更新cnt</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> __<span class="title">rte_ring_rts_poscnt</span> <span class="title">head</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</li>
<li><p>MP_HTS/MC_HTS(Head/Tail Sync)：在多生产者/多消费者情况下，保证了入队/出队操作的序列化，即每次仅允许一个生产者/消费者进行操作。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> __<span class="title">rte_ring_hts_pos</span> {</span></span><br><span class="line">	<span class="comment">/** raw 8B value to read/write *head* and *tail* as one atomic op */</span></span><br><span class="line">	RTE_ATOMIC(<span class="type">uint64_t</span>) raw __rte_aligned(<span class="number">8</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="comment">// 只有在head等于tail时才能更新head</span></span><br><span class="line">		RTE_ATOMIC(<span class="type">uint32_t</span>) head; <span class="comment">/**&lt; head position */</span></span><br><span class="line">		RTE_ATOMIC(<span class="type">uint32_t</span>) tail; <span class="comment">/**&lt; tail position */</span></span><br><span class="line">	} pos;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_hts_headtail</span> {</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> __<span class="title">rte_ring_hts_pos</span> <span class="title">ht</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_ring_sync_type</span> <span class="title">sync_type</span>;</span>  <span class="comment">/**&lt; sync type of prod/cons */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Ring的创建"><a href="#Ring的创建" class="headerlink" title="Ring的创建"></a>Ring的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RING_F_SP_ENQ 0x0001 <span class="comment">/**&lt; The default enqueue is "single-producer". */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_F_SC_DEQ 0x0002 <span class="comment">/**&lt; The default dequeue is "single-consumer". */</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ring is to hold exactly requested number of entries.</span></span><br><span class="line"><span class="comment"> * Without this flag set, the ring size requested must be a power of 2, and the</span></span><br><span class="line"><span class="comment"> * usable space will be that size - 1. With the flag, the requested size will</span></span><br><span class="line"><span class="comment"> * be rounded up to the next power of two, but the usable space will be exactly</span></span><br><span class="line"><span class="comment"> * that requested. Worst case, if a power-of-2 size is requested, half the</span></span><br><span class="line"><span class="comment"> * ring space will be wasted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_F_EXACT_SZ 0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_F_MP_RTS_ENQ 0x0008 <span class="comment">/**&lt; The default enqueue is "MP RTS". */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_F_MC_RTS_DEQ 0x0010 <span class="comment">/**&lt; The default dequeue is "MC RTS". */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_F_MP_HTS_ENQ 0x0020 <span class="comment">/**&lt; The default enqueue is "MP HTS". */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RING_F_MC_HTS_DEQ 0x0040 <span class="comment">/**&lt; The default dequeue is "MC HTS". */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在flag没有配置RING_F_EXACT_SZ的情况下，count只能选择2的整数次幂，且可用ring的容量为count-1（空出来的那个元素用于判断队满和队空）</span></span><br><span class="line"><span class="keyword">struct</span> rte_ring *<span class="title function_">rte_ring_create_elem</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> esize,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">int</span> socket_id, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="Ring的入队"><a href="#Ring的入队" class="headerlink" title="Ring的入队"></a>Ring的入队</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量入队，入队数量 = n</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_enqueue_bulk_elem</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">const</span> <span class="type">void</span> *obj_table,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> esize, <span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span> *free_space)</span></span><br><span class="line"><span class="comment">//突发入队，入队数量 &lt;= n</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_mp_rts_enqueue_burst_elem</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">const</span> <span class="type">void</span> *obj_table,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> esize, <span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span> *free_space)</span></span><br><span class="line"><span class="comment">//批量预入队，先预保留n个队列元素，而后根据用户行为来决定实际入队的个数</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_enqueue_bulk_elem_start</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">unsigned</span> <span class="type">int</span> n,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> *free_space)</span></span><br><span class="line"><span class="comment">//批量入队完成，实际入队个数可能小于预保留个数</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_ring_enqueue_elem_finish</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">const</span> <span class="type">void</span> *obj_table,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> esize, <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rte_ring_zc_data {</span><br><span class="line">	<span class="comment">/* Pointer to the first space in the ring */</span></span><br><span class="line">	<span class="type">void</span> *ptr1;</span><br><span class="line">	<span class="comment">/* Pointer to the second space in the ring if there is wrap-around.</span></span><br><span class="line"><span class="comment">	 * It contains valid value only if wrap-around happens.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> *ptr2;</span><br><span class="line">	<span class="comment">/* Number of elements in the first pointer. If this is equal to</span></span><br><span class="line"><span class="comment">	 * the number of elements requested, then ptr2 is NULL.</span></span><br><span class="line"><span class="comment">	 * Otherwise, subtracting n1 from number of elements requested</span></span><br><span class="line"><span class="comment">	 * will give the number of elements available at ptr2.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> n1;</span><br><span class="line">} __rte_cache_aligned;</span><br><span class="line"><span class="comment">//零拷贝的批量预入队</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_ring_enqueue_zc_bulk_elem_start</span><span class="params">(<span class="keyword">struct</span> rte_ring *r, <span class="type">unsigned</span> <span class="type">int</span> esize,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> n, <span class="keyword">struct</span> rte_ring_zc_data *zcd, <span class="type">unsigned</span> <span class="type">int</span> *free_space)</span></span><br></pre></td></tr></table></figure>



<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>后进先出的数据结构，提供了两种实现方式</p>
<ul>
<li>standard：利用数组存储stack元素，spin锁控制并发</li>
<li>lock-free：利用单向链表存储stack元素(表头即为栈顶)，且内部同时使用两个栈，一个栈为used栈；另一个栈为free栈。(使用两个栈解决了push和pop之间的无锁化同步)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stack的创建</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_STACK_F_LF 0x0001	<span class="comment">//指明栈使用哪种实现方式</span></span></span><br><span class="line"><span class="keyword">struct</span> rte_stack *</span><br><span class="line"><span class="title function_">rte_stack_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">		 <span class="type">uint32_t</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_stack_push</span><span class="params">(<span class="keyword">struct</span> rte_stack *s, <span class="type">void</span> * <span class="type">const</span> *obj_table, <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_stack_pop</span><span class="params">(<span class="keyword">struct</span> rte_stack *s, <span class="type">void</span> **obj_table, <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>



<h3 id="无锁化方式下ABA问题"><a href="#无锁化方式下ABA问题" class="headerlink" title="无锁化方式下ABA问题"></a>无锁化方式下ABA问题</h3><p>下面通过一个例子来了解下ABA问题的产生，这里为了方便理解，每次仅push/pop一个元素，且忽略对free栈的操作：</p>
<p>1：A线程执行pop操作，通过栈顶指针读取到used栈顶元素的地址<code>X</code>、栈顶元素的内容<code>X-&gt;data</code>和、新的栈顶元素的地址<code>X-&gt;next</code>，并将其记录下来</p>
<p>2：其他线程执行了一些pop和push操作，且操作后used栈顶指针所指向的元素的地址恰好是<code>X</code></p>
<p>3：A线程使用CAS，成功的将<code>X-&gt;next</code>设置为used栈顶指针所指向的元素的地址,并将<code>X-&gt;data</code>返回给用户</p>
<p>第三步中线程A所获取到的<code>X</code>和<code>X-&gt;next</code>已经不是最新的了。在这种情况下将<code>X-&gt;data</code>作为出栈元素，将<code>X-&gt;next</code>作为used栈顶元素的地址，就是错误的行为了。</p>
<h3 id="ABA问题解决方案"><a href="#ABA问题解决方案" class="headerlink" title="ABA问题解决方案"></a>ABA问题解决方案</h3><p>引入版本号，每次对栈顶进行push和pop操作时，版本号加一。同时使用CAS进行比较时不仅比较栈顶元素的地址，还同时比较版本号。这样做就避免了ABA问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_elem</span> {</span></span><br><span class="line">	<span class="type">void</span> *data;			<span class="comment">/**&lt; Data pointer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_elem</span> *<span class="title">next</span>;</span>	<span class="comment">/**&lt; Next pointer */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//栈顶指针，采用128位的CAS进行比较</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_head</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_elem</span> *<span class="title">top</span>;</span> <span class="comment">/**&lt; Stack top */</span></span><br><span class="line">	<span class="type">uint64_t</span> cnt; <span class="comment">/**&lt; Modification counter for avoiding ABA problem */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//used栈和free栈</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_list</span> {</span></span><br><span class="line">	<span class="comment">/** List head */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_head</span> <span class="title">head</span> __<span class="title">rte_aligned</span>(16);</span></span><br><span class="line">	<span class="comment">/** List len */</span></span><br><span class="line">	RTE_ATOMIC(<span class="type">uint64_t</span>) len;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure containing two lock-free LIFO lists: the stack itself and a list</span></span><br><span class="line"><span class="comment"> * of free linked-list elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf</span> {</span></span><br><span class="line">	<span class="comment">/** LIFO list of elements */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_list</span> <span class="title">used</span> __<span class="title">rte_cache_aligned</span>;</span></span><br><span class="line">	<span class="comment">/** LIFO list of free elements */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_list</span> <span class="title">free</span> __<span class="title">rte_cache_aligned</span>;</span></span><br><span class="line">	<span class="comment">/** LIFO elements */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_stack_lf_elem</span> <span class="title">elems</span>[] __<span class="title">rte_cache_aligned</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h1 id="RCU-Read-Copy-Update"><a href="#RCU-Read-Copy-Update" class="headerlink" title="RCU(Read, Copy, Update)"></a>RCU(Read, Copy, Update)</h1><p>无锁化的读写锁，利用QSBR(Quiescent State Based Reclamation)算法检测grace period。</p>
<blockquote>
<p>静止期（Quiescent State）：线程不存在对临界资源的任何引用的时间段</p>
</blockquote>
<blockquote>
<p>宽限期（grace period）：从资源在共享数据结构上删除到该资源释放的时间段</p>
</blockquote>
<p>dpdk的rcu使用QS变量（rcu实例）来保护某个特定共享数据结构的临界资源（例如hash、lpm）。</p>
<p>QS变量使用<code>token</code>来记录当前共享数据结构的版本号（每个读者线程也有属于该线程的token，记录该线程的静止期所使用的版本号），写者每对其资源每删除一次，版本号都会加一，加一后的版本号也就对应了该资源的宽限期。需要注意的是，写者对其资源添加并不会修改版本号，因为添加的资源不需要释放，也就不需要追踪其版本。</p>
<p>当读线程处于静止期时，更新该线程的版本号为当前QS变量的token。</p>
<p>当写者要释放特定版本号所删除的资源时，需要等待一个宽限期的时间，即写者要等到所有的读线程的版本号都大于等于该版本号。宽限期过后，即可释放该资源。</p>
<p><a href="/images/rcu_general_info.svg" class="gallery-item" style="box-shadow: none;"> <img src="/images/rcu_general_info.svg"></a></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QS变量初始化</span></span><br><span class="line"><span class="comment">//获取QS变量大小</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">rte_rcu_qsbr_get_memsize</span><span class="params">(<span class="type">uint32_t</span> max_threads)</span>;</span><br><span class="line"><span class="comment">//QS变量初始化，入参的QS变量一定要提前malloc出来</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_rcu_qsbr_init</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr *v, <span class="type">uint32_t</span> max_threads)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读者线程注册</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_rcu_qsbr_thread_register</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr *v, <span class="type">unsigned</span> <span class="type">int</span> thread_id)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="读者"><a href="#读者" class="headerlink" title="读者"></a>读者</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读者线程开启对该线程QS（Quiescent State）的报告</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_rcu_qsbr_thread_online</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr *v, <span class="type">unsigned</span> <span class="type">int</span> thread_id)</span></span><br><span class="line"><span class="comment">//读者线程关闭对该线程QS的报告，使得写者在检查宽限期时跳过该线程（如果读者需进行阻塞调用，则进入阻塞前调用该函数，阻塞返回后再调用上面的函数）</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_rcu_qsbr_thread_offline</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr *v, <span class="type">unsigned</span> <span class="type">int</span> thread_id)</span></span><br><span class="line"><span class="comment">//读者线程报告该线程进入QS</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_rcu_qsbr_quiescent</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr *v, <span class="type">unsigned</span> <span class="type">int</span> thread_id)</span></span><br></pre></td></tr></table></figure>



<h2 id="写者"><a href="#写者" class="headerlink" title="写者"></a>写者</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始宽限期</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">uint64_t</span></span><br><span class="line"><span class="title function_">rte_rcu_qsbr_start</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr *v)</span></span><br><span class="line"><span class="comment">//检查特定版本的宽限期是否结束</span></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_rcu_qsbr_check</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr *v, <span class="type">uint64_t</span> t, <span class="type">bool</span> wait)</span></span><br></pre></td></tr></table></figure>



<h2 id="资源的释放"><a href="#资源的释放" class="headerlink" title="资源的释放"></a>资源的释放</h2><p>上述对于写者所提供的API使得写者可以很灵活地实现对于资源的删除和释放。为了更进一步方便写者对于rcu的使用，dpdk将上面的两个API做进一步的封装，并根据对删除资源的释放时机，提供了两种不同的方法</p>
<ol>
<li><p>同步释放：删除资源后，写者以阻塞方式等待宽限期结束，结束后立即释放资源</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始一个新的宽限期并阻塞到宽限期结束后返回，返回后可以安全的释放所删除的资源。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_rcu_qsbr_synchronize</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr *v, <span class="type">unsigned</span> <span class="type">int</span> thread_id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步释放：通过创建FIFO的延时队列，删除资源后，将待释放的资源和该资源对应的宽限期版本号入队，而后直接返回。此后可选择适当的时机以非阻塞的方式遍历延时队列，取出并释放宽限期结束的资源。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建延时队列时使用的参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_rcu_qsbr_dq_parameters</span> {</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="comment">/**&lt; Name of the queue. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**&lt; Enqueue and reclaim operations are multi-thread safe by default.</span></span><br><span class="line"><span class="comment"> *   The call back functions registered to free the resources are</span></span><br><span class="line"><span class="comment"> *   assumed to be multi-thread safe.</span></span><br><span class="line"><span class="comment"> *   Set this flag if multi-thread safety is not required.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_RCU_QSBR_DQ_MT_UNSAFE 1</span></span><br><span class="line">	<span class="type">uint32_t</span> flags;</span><br><span class="line">	<span class="comment">/**&lt; Flags to control API behaviors */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> size;</span><br><span class="line">	<span class="comment">/**&lt; Number of entries in queue. Typically, this will be</span></span><br><span class="line"><span class="comment">	 *   the same as the maximum number of entries supported in the</span></span><br><span class="line"><span class="comment">	 *   lock free data structure.</span></span><br><span class="line"><span class="comment">	 *   Data structures with unbounded number of entries is not</span></span><br><span class="line"><span class="comment">	 *   supported currently.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> esize;</span><br><span class="line">	<span class="comment">/**&lt; Size (in bytes) of each element in the defer queue.</span></span><br><span class="line"><span class="comment">	 *   This has to be multiple of 4B.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> trigger_reclaim_limit;</span><br><span class="line">	<span class="comment">/**&lt; Trigger automatic reclamation after the defer queue</span></span><br><span class="line"><span class="comment">	 *   has at least these many resources waiting. This auto</span></span><br><span class="line"><span class="comment">	 *   reclamation is triggered in rte_rcu_qsbr_dq_enqueue API</span></span><br><span class="line"><span class="comment">	 *   call.</span></span><br><span class="line"><span class="comment">	 *   If this is greater than 'size', auto reclamation is</span></span><br><span class="line"><span class="comment">	 *   not triggered.</span></span><br><span class="line"><span class="comment">	 *   If this is set to 0, auto reclamation is triggered</span></span><br><span class="line"><span class="comment">	 *   in every call to rte_rcu_qsbr_dq_enqueue API.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_reclaim_size;</span><br><span class="line">	<span class="comment">/**&lt; When automatic reclamation is enabled, reclaim at the max</span></span><br><span class="line"><span class="comment">	 *   these many resources. This should contain a valid value, if</span></span><br><span class="line"><span class="comment">	 *   auto reclamation is on. Setting this to 'size' or greater will</span></span><br><span class="line"><span class="comment">	 *   reclaim all possible resources currently on the defer queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">rte_rcu_qsbr_free_resource_t</span> free_fn;</span><br><span class="line">	<span class="comment">/**&lt; Function to call to free the resource. */</span></span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line">	<span class="comment">/**&lt; Pointer passed to the free function. Typically, this is the</span></span><br><span class="line"><span class="comment">	 *   pointer to the data structure to which the resource to free</span></span><br><span class="line"><span class="comment">	 *   belongs. This can be NULL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_rcu_qsbr</span> *<span class="title">v</span>;</span></span><br><span class="line">	<span class="comment">/**&lt; RCU QSBR variable to use for this defer queue */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//延时队列创建，写者以异步方式进行资源释放</span></span><br><span class="line"><span class="keyword">struct</span> rte_rcu_qsbr_dq *</span><br><span class="line"><span class="title function_">rte_rcu_qsbr_dq_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_rcu_qsbr_dq_parameters *params)</span>;</span><br><span class="line"><span class="comment">//将待释放的资源入队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_rcu_qsbr_dq_enqueue</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr_dq *dq, <span class="type">void</span> *e)</span>;</span><br><span class="line"><span class="comment">//释放延时队列中能够释放的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_rcu_qsbr_dq_reclaim</span><span class="params">(<span class="keyword">struct</span> rte_rcu_qsbr_dq *dq, <span class="type">unsigned</span> <span class="type">int</span> n,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> *freed, <span class="type">unsigned</span> <span class="type">int</span> *pending, <span class="type">unsigned</span> <span class="type">int</span> *available)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>具体使用可参考dpdk的hash模块：<code>rte_hash_rcu_qsbr_add()</code></p>
<h1 id="Mempool"><a href="#Mempool" class="headerlink" title="Mempool"></a>Mempool</h1><ul>
<li><p>可使用多种管理方式来管理内存池，默认是基于ring管理</p>
</li>
<li><p>根据硬件的内存配置，优化内存池block的内存布局。这在多次访问内存池连续的对象，且每次仅访问block的头64字节(一个cache line大小)的情况下可最大化内存带宽</p>
<blockquote>
<p>例如使用mempool管理packet，mempool会保证每个packet的首地址都处于不同的channel和rank中，此时mempool会将packet的大小扩展到与channel*rank互为质数（即最大公约数为1，最小公倍数为两数相乘，这意味着连续的channel*rank个packet，每个packet的首地址都处于不同的channel和rank中）</p>
<p><a href="/images/memory-management.svg" title="management" class="gallery-item" style="box-shadow: none;"> <img src="/images/memory-management.svg" alt="management"></a></p>
</blockquote>
</li>
<li><p>使用局部缓存，通过降低产生并发的频率来提高内存池的存取性能</p>
</li>
</ul>
<p>内存池主要由三部分组成：</p>
<ol>
<li><code>struct rte_mempool</code>用于存储该内存池的相关信息，该结构体包含了私有数据和局部缓存(LIFO)的内存</li>
<li>用于管理内存池的数据结构，比如前面介绍过的<code>ring</code>和<code>stack</code></li>
<li>内存池中的对象，存放在<strong>2</strong>中进行管理，每个对象都有一个头(<code>struct rte_mempool_objhdr</code>)，用链表连接起来并存放在<strong>1</strong>中</li>
</ol>
<p><a href="/images/mempool.svg" title="mempool" class="gallery-item" style="box-shadow: none;"> <img src="/images/mempool.svg" alt="mempool"></a></p>
<blockquote>
<p>内存池对于每个核都会创建一个局部缓存，一般来说每核对应一个处理线程，如果有多个处理线程都在一个核上，对局部缓存的操作需要上锁。</p>
</blockquote>
<h2 id="Mempool创建"><a href="#Mempool创建" class="headerlink" title="Mempool创建"></a>Mempool创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Spreading among memory channels not required. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_MEMPOOL_F_NO_SPREAD		0x0001</span></span><br><span class="line"><span class="comment">/** Do not align objects on cache lines. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_MEMPOOL_F_NO_CACHE_ALIGN	0x0002</span></span><br><span class="line"><span class="comment">/** Default put is "single-producer". */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_MEMPOOL_F_SP_PUT		0x0004</span></span><br><span class="line"><span class="comment">/** Default get is "single-consumer". */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_MEMPOOL_F_SC_GET		0x0008</span></span><br><span class="line"><span class="comment">/** Don't need IOVA contiguous objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_MEMPOOL_F_NO_IOVA_CONTIG	0x0020</span></span><br><span class="line"><span class="keyword">struct</span> rte_mempool *</span><br><span class="line"><span class="title function_">rte_mempool_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> n, <span class="type">unsigned</span> elt_size,</span></span><br><span class="line"><span class="params">		   <span class="type">unsigned</span> cache_size, 		<span class="comment">//局部缓存的容量</span></span></span><br><span class="line"><span class="params">		   <span class="type">unsigned</span> private_data_size,	<span class="comment">//追加到struct rte_mempool后的私有数据大小</span></span></span><br><span class="line"><span class="params">		   <span class="type">rte_mempool_ctor_t</span> *mp_init, <span class="type">void</span> *mp_init_arg,	<span class="comment">//初始化私有数据</span></span></span><br><span class="line"><span class="params">		   <span class="type">rte_mempool_obj_cb_t</span> *obj_init, <span class="type">void</span> *obj_init_arg,	<span class="comment">//初始化内存池的所有对象</span></span></span><br><span class="line"><span class="params">		   <span class="type">int</span> socket_id, <span class="type">unsigned</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>创建函数会调用<code>rte_mempool_populate_default()</code>，该函数计算内存池对象所需的内存大小，而后去申请内存并将申请到的内存分割成一个个对象加入到内存池中。</p>
<p>计算内存池对象所需内存大小时：</p>
<ol>
<li>对于没有设置<code>RTE_MEMPOOL_F_NO_IOVA_CONTIG</code>标志的内存池来说，其对象的物理地址必须是连续的，且不能跨页面；计算时所使用的页面大小为dpdk所用的最小页面的大小，这样做虽然会使得计算结果偏大，但却简化了实现的复杂度。若实际分配时采用的是较大的页面，也不会导致任何问题，因为大页面可视为多个物理地址连续的小页面的集合。</li>
<li>对于设置了<code>RTE_MEMPOOL_F_NO_IOVA_CONTIG</code>标志的内存池来说没有上述约束。</li>
</ol>
<p>申请内存时：</p>
<ol>
<li>尽量一次申请出对象所需内存(memzone，不需要iova连续，无论是否配置了<code>RTE_MEMPOOL_F_NO_IOVA_CONTIG</code>)</li>
<li>如果申请失败则将申请大小减半进行申请，直到申请成功</li>
</ol>
<p>将申请到的内存分割成对象：</p>
<ol>
<li>若设置了<code>RTE_MEMPOOL_F_NO_IOVA_CONTIG</code>则调用<code>rte_mempool_populate_iova()</code>将memzone分割成对象</li>
<li>若没设置<code>RTE_MEMPOOL_F_NO_IOVA_CONTIG</code>则调用<code>rte_mempool_populate_virt()</code>将memzone划为一个个iova连续的内存区域，再调用<code>rte_mempool_populate_iova()</code>将这些iova连续的内存区域分割成对象</li>
</ol>
<h2 id="Mempool对象的申请"><a href="#Mempool对象的申请" class="headerlink" title="Mempool对象的申请"></a>Mempool对象的申请</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_mempool_put_bulk</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mp, <span class="type">void</span> * <span class="type">const</span> *obj_table,</span></span><br><span class="line"><span class="params">		     <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>



<h1 id="Mbuf"><a href="#Mbuf" class="headerlink" title="Mbuf"></a>Mbuf</h1><p>dpdk用于消息存储(message buffers)的数据结构，使用mempool管理。常用于携带网络报文。</p>
<p><a href="/images/mbuf1.svg" title="mbuf1" class="gallery-item" style="box-shadow: none;"> <img src="/images/mbuf1.svg" alt="mbuf1"></a></p>
<p><a href="/images/mbuf2.svg" title="mbuf2" class="gallery-item" style="box-shadow: none;"> <img src="/images/mbuf2.svg" alt="mbuf2"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> {</span></span><br><span class="line">	RTE_MARKER cacheline0;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *buf_addr;           <span class="comment">/**&lt; Virtual address of segment buffer. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> RTE_IOVA_IN_MBUF</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Physical address of segment buffer.</span></span><br><span class="line"><span class="comment">	 * This field is undefined if the build is configured to use only</span></span><br><span class="line"><span class="comment">	 * virtual address as IOVA (i.e. RTE_IOVA_IN_MBUF is 0).</span></span><br><span class="line"><span class="comment">	 * Force alignment to 8-bytes, so as to ensure we have the exact</span></span><br><span class="line"><span class="comment">	 * same mbuf cacheline0 layout for 32-bit and 64-bit. This makes</span></span><br><span class="line"><span class="comment">	 * working on vector drivers easier.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">rte_iova_t</span> buf_iova __rte_aligned(<span class="keyword">sizeof</span>(<span class="type">rte_iova_t</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Next segment of scattered packet.</span></span><br><span class="line"><span class="comment">	 * This field is valid when physical address field is undefined.</span></span><br><span class="line"><span class="comment">	 * Otherwise next pointer in the second cache line will be used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* next 8 bytes are initialised on RX descriptor rearm */</span></span><br><span class="line">	RTE_MARKER64 rearm_data;</span><br><span class="line">	<span class="type">uint16_t</span> data_off;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reference counter. Its size should at least equal to the size</span></span><br><span class="line"><span class="comment">	 * of port field (16 bits), to support zero-copy broadcast.</span></span><br><span class="line"><span class="comment">	 * It should only be accessed using the following functions:</span></span><br><span class="line"><span class="comment">	 * rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and</span></span><br><span class="line"><span class="comment">	 * rte_mbuf_refcnt_set(). The functionality of these functions (atomic,</span></span><br><span class="line"><span class="comment">	 * or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_ATOMIC(<span class="type">uint16_t</span>) refcnt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Number of segments. Only valid for the first segment of an mbuf</span></span><br><span class="line"><span class="comment">	 * chain.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_segs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Input port (16 bits to support more than 256 virtual ports).</span></span><br><span class="line"><span class="comment">	 * The event eth Tx adapter uses this field to specify the output port.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint16_t</span> port;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> ol_flags;        <span class="comment">/**&lt; Offload features. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* remaining bytes are set on RX when pulling packet from descriptor */</span></span><br><span class="line">	RTE_MARKER rx_descriptor_fields1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The packet type, which is the combination of outer/inner L2, L3, L4</span></span><br><span class="line"><span class="comment">	 * and tunnel types. The packet_type is about data really present in the</span></span><br><span class="line"><span class="comment">	 * mbuf. Example: if vlan stripping is enabled, a received vlan packet</span></span><br><span class="line"><span class="comment">	 * would have RTE_PTYPE_L2_ETHER and not RTE_PTYPE_L2_VLAN because the</span></span><br><span class="line"><span class="comment">	 * vlan is stripped from the data.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="type">uint32_t</span> packet_type; <span class="comment">/**&lt; L2/L3/L4 and tunnel information. */</span></span><br><span class="line">		__extension__</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="type">uint8_t</span> l2_type:<span class="number">4</span>;   <span class="comment">/**&lt; (Outer) L2 type. */</span></span><br><span class="line">			<span class="type">uint8_t</span> l3_type:<span class="number">4</span>;   <span class="comment">/**&lt; (Outer) L3 type. */</span></span><br><span class="line">			<span class="type">uint8_t</span> l4_type:<span class="number">4</span>;   <span class="comment">/**&lt; (Outer) L4 type. */</span></span><br><span class="line">			<span class="type">uint8_t</span> tun_type:<span class="number">4</span>;  <span class="comment">/**&lt; Tunnel type. */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">				<span class="type">uint8_t</span> inner_esp_next_proto;</span><br><span class="line">				<span class="comment">/**&lt; ESP next protocol type, valid if</span></span><br><span class="line"><span class="comment">				 * RTE_PTYPE_TUNNEL_ESP tunnel type is set</span></span><br><span class="line"><span class="comment">				 * on both Tx and Rx.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				__extension__</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">					<span class="type">uint8_t</span> inner_l2_type:<span class="number">4</span>;</span><br><span class="line">					<span class="comment">/**&lt; Inner L2 type. */</span></span><br><span class="line">					<span class="type">uint8_t</span> inner_l3_type:<span class="number">4</span>;</span><br><span class="line">					<span class="comment">/**&lt; Inner L3 type. */</span></span><br><span class="line">				};</span><br><span class="line">			};</span><br><span class="line">			<span class="type">uint8_t</span> inner_l4_type:<span class="number">4</span>; <span class="comment">/**&lt; Inner L4 type. */</span></span><br><span class="line">		};</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> pkt_len;         <span class="comment">/**&lt; Total pkt len: sum of all segments. */</span></span><br><span class="line">	<span class="type">uint16_t</span> data_len;        <span class="comment">/**&lt; Amount of data in segment buffer. */</span></span><br><span class="line">	<span class="comment">/** VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_VLAN is set. */</span></span><br><span class="line">	<span class="type">uint16_t</span> vlan_tci;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">			<span class="type">uint32_t</span> rss;     <span class="comment">/**&lt; RSS hash result if RSS enabled */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">				<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">						<span class="type">uint16_t</span> hash;</span><br><span class="line">						<span class="type">uint16_t</span> id;</span><br><span class="line">					};</span><br><span class="line">					<span class="type">uint32_t</span> lo;</span><br><span class="line">					<span class="comment">/**&lt; Second 4 flexible bytes */</span></span><br><span class="line">				};</span><br><span class="line">				<span class="type">uint32_t</span> hi;</span><br><span class="line">				<span class="comment">/**&lt; First 4 flexible bytes or FD ID, dependent</span></span><br><span class="line"><span class="comment">				 * on RTE_MBUF_F_RX_FDIR_* flag in ol_flags.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">			} fdir;	<span class="comment">/**&lt; Filter identifier if FDIR enabled */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf_sched</span> <span class="title">sched</span>;</span></span><br><span class="line">			<span class="comment">/**&lt; Hierarchical scheduler : 8 bytes */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">				<span class="type">uint32_t</span> reserved1;</span><br><span class="line">				<span class="type">uint16_t</span> reserved2;</span><br><span class="line">				<span class="type">uint16_t</span> txq;</span><br><span class="line">				<span class="comment">/**&lt; The event eth Tx adapter uses this field</span></span><br><span class="line"><span class="comment">				 * to store Tx queue id.</span></span><br><span class="line"><span class="comment">				 * @see rte_event_eth_tx_adapter_txq_set()</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">			} txadapter; <span class="comment">/**&lt; Eventdev ethdev Tx adapter */</span></span><br><span class="line">			<span class="type">uint32_t</span> usr;</span><br><span class="line">			<span class="comment">/**&lt; User defined tags. See rte_distributor_process() */</span></span><br><span class="line">		} hash;                   <span class="comment">/**&lt; hash information */</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Outer VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_QINQ is set. */</span></span><br><span class="line">	<span class="type">uint16_t</span> vlan_tci_outer;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> buf_len;         <span class="comment">/**&lt; Length of segment buffer. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">pool</span>;</span> <span class="comment">/**&lt; Pool from which mbuf was allocated. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* second cache line - fields only used in slow path or on TX */</span></span><br><span class="line">	RTE_MARKER cacheline1 __rte_cache_min_aligned;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> RTE_IOVA_IN_MBUF</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Next segment of scattered packet. Must be NULL in the last</span></span><br><span class="line"><span class="comment">	 * segment or in case of non-segmented packet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reserved for dynamic fields</span></span><br><span class="line"><span class="comment">	 * when the next pointer is in first cache line (i.e. RTE_IOVA_IN_MBUF is 0).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint64_t</span> dynfield2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fields to support TX offloads */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="type">uint64_t</span> tx_offload;       <span class="comment">/**&lt; combined for easy fetch */</span></span><br><span class="line">		__extension__</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="type">uint64_t</span> l2_len:RTE_MBUF_L2_LEN_BITS;</span><br><span class="line">			<span class="comment">/**&lt; L2 (MAC) Header Length for non-tunneling pkt.</span></span><br><span class="line"><span class="comment">			 * Outer_L4_len + ... + Inner_L2_len for tunneling pkt.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="type">uint64_t</span> l3_len:RTE_MBUF_L3_LEN_BITS;</span><br><span class="line">			<span class="comment">/**&lt; L3 (IP) Header Length. */</span></span><br><span class="line">			<span class="type">uint64_t</span> l4_len:RTE_MBUF_L4_LEN_BITS;</span><br><span class="line">			<span class="comment">/**&lt; L4 (TCP/UDP) Header Length. */</span></span><br><span class="line">			<span class="type">uint64_t</span> tso_segsz:RTE_MBUF_TSO_SEGSZ_BITS;</span><br><span class="line">			<span class="comment">/**&lt; TCP TSO segment size */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Fields for Tx offloading of tunnels.</span></span><br><span class="line"><span class="comment">			 * These are undefined for packets which don't request</span></span><br><span class="line"><span class="comment">			 * any tunnel offloads (outer IP or UDP checksum,</span></span><br><span class="line"><span class="comment">			 * tunnel TSO).</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * PMDs should not use these fields unconditionally</span></span><br><span class="line"><span class="comment">			 * when calculating offsets.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * Applications are expected to set appropriate tunnel</span></span><br><span class="line"><span class="comment">			 * offload flags when they fill in these fields.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="type">uint64_t</span> outer_l3_len:RTE_MBUF_OUTL3_LEN_BITS;</span><br><span class="line">			<span class="comment">/**&lt; Outer L3 (IP) Hdr Length. */</span></span><br><span class="line">			<span class="type">uint64_t</span> outer_l2_len:RTE_MBUF_OUTL2_LEN_BITS;</span><br><span class="line">			<span class="comment">/**&lt; Outer L2 (MAC) Hdr Length. */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* uint64_t unused:RTE_MBUF_TXOFLD_UNUSED_BITS; */</span></span><br><span class="line">		};</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Shared data for external buffer attached to mbuf. See</span></span><br><span class="line"><span class="comment">	 * rte_pktmbuf_attach_extbuf().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf_ext_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Size of the application private data. In case of an indirect</span></span><br><span class="line"><span class="comment">	 * mbuf, it stores the direct mbuf private data size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint16_t</span> priv_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Timesync flags for use with IEEE1588. */</span></span><br><span class="line">	<span class="type">uint16_t</span> timesync;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> dynfield1[<span class="number">9</span>]; <span class="comment">/**&lt; Reserved for dynamic fields. */</span></span><br><span class="line">} __rte_cache_aligned;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rte_mempool *</span><br><span class="line"><span class="title function_">rte_pktmbuf_pool_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> n,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> cache_size, <span class="type">uint16_t</span> priv_size, <span class="type">uint16_t</span> data_room_size,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> socket_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">rte_pktmbuf_alloc_bulk</span><span class="params">(<span class="keyword">struct</span> rte_mempool *pool,</span></span><br><span class="line"><span class="params">	 <span class="keyword">struct</span> rte_mbuf **mbufs, <span class="type">unsigned</span> count)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rte_mbuf *</span><br><span class="line"><span class="title function_">rte_pktmbuf_clone</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *md, <span class="keyword">struct</span> rte_mempool *mp)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="Dynamic-field"><a href="#Dynamic-field" class="headerlink" title="Dynamic field"></a>Dynamic field</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf_dynfield</span> {</span></span><br><span class="line">	<span class="type">char</span> name[RTE_MBUF_DYN_NAMESIZE]; <span class="comment">/**&lt; Name of the field. */</span></span><br><span class="line">	<span class="type">size_t</span> size;        <span class="comment">/**&lt; The number of bytes to reserve. */</span></span><br><span class="line">	<span class="type">size_t</span> align;       <span class="comment">/**&lt; The alignment constraint (power of 2). */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags; <span class="comment">/**&lt; Reserved for future use, must be 0. */</span></span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_mbuf_dynfield_register</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_mbuf_dynfield *params)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="Dynamic-flag"><a href="#Dynamic-flag" class="headerlink" title="Dynamic flag"></a>Dynamic flag</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf_dynflag</span> {</span></span><br><span class="line">	<span class="type">char</span> name[RTE_MBUF_DYN_NAMESIZE]; <span class="comment">/**&lt; Name of the dynamic flag. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags; <span class="comment">/**&lt; Reserved for future use, must be 0. */</span></span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_mbuf_dynflag_register</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_mbuf_dynflag *params)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><ul>
<li><p>基于skiplist实现，skiplist是一个具有多层索引的有序链表，其搜索/插入/删除的时间复杂度均为O(logn)</p>
</li>
<li><p>使用HPET(High Precision Event Timer)或者TSC(Time Stamp Counter)作为低开销的时间基准</p>
</li>
</ul>
<h2 id="Skiplist原理"><a href="#Skiplist原理" class="headerlink" title="Skiplist原理"></a>Skiplist原理</h2><p>跳跃表是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的“快速通道”，在第 i 层中的元素按某个固定的概率p(通常为 1/2 或 1/4 )出现在第 i + 1 层中。</p>
<p><a href="/images/Skip_list.svg" title="skiplist" class="gallery-item" style="box-shadow: none;"> <img src="/images/Skip_list.svg" alt="skiplist"></a></p>
<p>跳跃表的插入(以p=1/2为例):</p>
<p><a href="/images/Skip_list_add_element-en.gif" title="skiplist_add" class="gallery-item" style="box-shadow: none;"> <img src="/images/Skip_list_add_element-en.gif" alt="skiplist_add"></a></p>
<p>dpdk采用10层(0~9)的跳跃表，且插入到 0 层的元素以 1/4 的概率出现在 1 层中，即插入的元素有 (1/4)^i 的概率出现在 i 层。dpdk对于插入层数的确定没有按照一般跳跃表对于的插入实现，即对插入的层数按概率一层一层的累加，而是直接确定插入元素的最高层数。对于如何一次就能确定插入元素的最高层数，dpdk的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* probability value is 1/4, i.e. all at level 0, 1 in 4 is at level 1,</span></span><br><span class="line"><span class="comment"> * 1 in 16 at level 2, 1 in 64 at level 3, etc. Calculated using lowest</span></span><br><span class="line"><span class="comment"> * bit position of a (pseudo)random number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//取随机数的1~31位，这些位每位出现0/1的概率都是1/2</span></span><br><span class="line"><span class="type">uint32_t</span> rand = rte_rand() &amp; (UINT32_MAX - <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 由于rte_bsf32()函数入参不能为0，当rand为0时，level设为最高层</span></span><br><span class="line"><span class="comment"> * X = rte_bsf32(rand) X表示值为1的最低二进制位数，也意味着从最低位开始连续0的个数(X∈[1,31])</span></span><br><span class="line"><span class="comment"> * 这里可将X视为服从参数为1/2的几何分布，即X~Geo(1/2)，X=1,2,3,...</span></span><br><span class="line"><span class="comment"> * 令level = ⌊(X-1)/2⌋，level就是插入元素时所确定的最高层数，该最高层数满足</span></span><br><span class="line"><span class="comment"> * P(level &gt; r) = P(X &gt; 2r+2) = (1/2)^(2r+2) = (1/4)^(r+1)，即插入的元素出现在(r+1)层的概率为(1/4)^(r+1)</span></span><br><span class="line"><span class="comment"> * 同理，若设置概率为1/4，令level = ⌊(X-1)/4⌋ 即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> level = rand == <span class="number">0</span> ? MAX_SKIPLIST_DEPTH : (rte_bsf32(rand)<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* limit the levels used to one above our current level, so we don't,</span></span><br><span class="line"><span class="comment"> * for instance, have a level 0 and a level 7 without anything between</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (level &gt; curr_depth)</span><br><span class="line">	level = curr_depth;</span><br><span class="line"><span class="keyword">if</span> (level &gt;= MAX_SKIPLIST_DEPTH)</span><br><span class="line">	level = MAX_SKIPLIST_DEPTH<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>



<p>在结构表示上，相比于传统的有序链表，跳跃表的next成员不再是指针，而是指针数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_timer</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="type">uint64_t</span> expire;       <span class="comment">/**&lt; Time when timer expire. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_timer</span> *<span class="title">sl_next</span>[<span class="title">MAX_SKIPLIST_DEPTH</span>];</span>	<span class="comment">//跳跃表的next数组</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">union</span> <span class="title">rte_timer_status</span> <span class="title">status</span>;</span> <span class="comment">/**&lt; Status of timer. */</span></span><br><span class="line">	<span class="type">uint64_t</span> period;       <span class="comment">/**&lt; Period of timer (0 if not periodic). */</span></span><br><span class="line">	<span class="type">rte_timer_cb_t</span> f;      <span class="comment">/**&lt; Callback function. */</span></span><br><span class="line">	<span class="type">void</span> *arg;             <span class="comment">/**&lt; Argument to callback function. */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h2 id="Timer的使用"><a href="#Timer的使用" class="headerlink" title="Timer的使用"></a>Timer的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器模块初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_timer_subsystem_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_timer_init</span><span class="params">(<span class="keyword">struct</span> rte_timer *tim)</span>;</span><br><span class="line"><span class="comment">//配置一个定时器并开启</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_timer_reset</span><span class="params">(<span class="keyword">struct</span> rte_timer *tim, <span class="type">uint64_t</span> ticks,</span></span><br><span class="line"><span class="params">		    <span class="keyword">enum</span> rte_timer_type type, <span class="type">unsigned</span> tim_lcore,</span></span><br><span class="line"><span class="params">		    <span class="type">rte_timer_cb_t</span> fct, <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器处理，所有到时的定时器会在该函数中处理，需要用户循环调用，调用的时间间隔会影响定时器的精度。</span></span><br><span class="line"><span class="comment">//需要注意的是该函数只会处理挂载在该lcore上的定时器。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_timer_manage</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>基于Cuckoo算法实现，在较高的空间利用率的情况下，能有不错的查询性能。dpdk的hash表被分为两个表：</p>
<ol>
<li>索引查询表（hash bucket）：里面存储着key的签名（用于hash查找时的快速比较和另一个hash bucket的确定）和key-value表的索引</li>
<li>key-value表：存放着key和value（value的大小最大为一个指针的长度）</li>
</ol>
<h2 id="Cuckoo算法"><a href="#Cuckoo算法" class="headerlink" title="Cuckoo算法"></a>Cuckoo算法</h2><p>利用两个hash函数来解决hash冲突，对于任意的key，可求出2个hash值，将这两个hash值映射到索引查询表的两个不同的位置上。换句话说，Cuckoo算法中每个key都会对应两个hash bucket，分别为primary bucket和secondary bucket。</p>
<ul>
<li><p>查找key_a：根据给定的key_a，求出两个hash bucket的位置，进行匹配（具体实现时分为两步，第一步匹配索引查询表中的key的签名，第二步匹配key-value表中的key），若匹配失败，则查找失败</p>
</li>
<li><p>插入key_a：</p>
<ol>
<li>先进行查找，若已存在对应key_a，则更新value并返回成功</li>
<li>查看primary bucket是否被占用，若没占用，则直接插入并返回成功</li>
<li>将当前primary bucket所存储的key_b踢出，并插入key_a</li>
<li>被踢出的key_b存放到该key所对应的另一个hash桶上，若另一个hash桶被占用，则将该hash桶上的key_c踢出，并插入key_b</li>
<li>重复操作4，直到没有新的key被踢出时返回成功，或者超出最大循环限制</li>
<li>执行操作2-5，只不过这次是对secondary bucket进行操作，若超出最大循环限制，则返回失败</li>
</ol>
<blockquote>
<p>一连串被踢出的key所形成的路径称作Cuckoo Kick路径</p>
</blockquote>
</li>
</ul>
<p>为了提高hash的插入性能，dpdk做了下面几处优化：</p>
<ol>
<li>使用8路组相联，这意味着每个hash bucket不再只存储一个key，而是可以存储最多8个key，大大减小了插入时旧key被踢出的概率。选用8路组相联主要是因为这可以使得hash bucket的大小正好为一个cache line，减少组相联对查询性能的影响。</li>
<li>插入时如果需要踢出旧key，则先采用BFS来寻找最短Cuckoo Kick路径（引入组相联后Cuckoo Kick路径不再是一条，而是多条），找到后再从尾到头移动key，最后插入待插入的key到primary/secondary bucket中。</li>
</ol>
<h2 id="Hash表的初始化"><a href="#Hash表的初始化" class="headerlink" title="Hash表的初始化"></a>Hash表的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Enable Hardware transactional memory support. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT	0x01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default behavior of insertion, single writer/multi writer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD 0x02</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Flag to support reader writer concurrency */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY 0x04</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Flag to indicate the extendable bucket table feature should be used */</span></span><br><span class="line"><span class="comment">//为应对极小概率下所遇到的因Cuckoo Kick路径过长所导致的插入失败问题。可扩展的仅为索引查询表，而非key-value表。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_HASH_EXTRA_FLAGS_EXT_TABLE 0x08</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Flag to disable freeing of key index on hash delete.</span></span><br><span class="line"><span class="comment"> * Refer to rte_hash_del_xxx APIs for more details.</span></span><br><span class="line"><span class="comment"> * This is enabled by default when RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF</span></span><br><span class="line"><span class="comment"> * is enabled. However, if internal RCU is enabled, freeing of internal</span></span><br><span class="line"><span class="comment"> * memory/index is done on delete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Flag to support lock free reader writer concurrency. Both single writer</span></span><br><span class="line"><span class="comment"> * and multi writer use cases are supported.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF 0x20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_hash_parameters</span> {</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;		<span class="comment">/**&lt; Name of the hash. */</span></span><br><span class="line">	<span class="type">uint32_t</span> entries;		<span class="comment">/**&lt; Total hash table entries. */</span></span><br><span class="line">	<span class="type">uint32_t</span> reserved;		<span class="comment">/**&lt; Unused field. Should be set to 0 */</span></span><br><span class="line">	<span class="type">uint32_t</span> key_len;		<span class="comment">/**&lt; Length of hash key. */</span></span><br><span class="line">	rte_hash_function hash_func;	<span class="comment">/**&lt; Primary Hash function used to calculate hash. */</span></span><br><span class="line">	<span class="type">uint32_t</span> hash_func_init_val;	<span class="comment">/**&lt; Init value used by hash_func. */</span></span><br><span class="line">	<span class="type">int</span> socket_id;			<span class="comment">/**&lt; NUMA Socket ID for memory. */</span></span><br><span class="line">	<span class="type">uint8_t</span> extra_flag;		<span class="comment">/**&lt; Indicate if additional parameters are present. */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//hash表的创建</span></span><br><span class="line"><span class="keyword">struct</span> rte_hash *</span><br><span class="line"><span class="title function_">rte_hash_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_hash_parameters *params)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_hash_rcu_config</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_rcu_qsbr</span> *<span class="title">v</span>;</span>		<span class="comment">/**&lt; RCU QSBR variable. */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_hash_qsbr_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">	<span class="comment">/**&lt; Mode of RCU QSBR. RTE_HASH_QSBR_MODE_xxx</span></span><br><span class="line"><span class="comment">	 * '0' for default: create defer queue for reclaim.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> dq_size;</span><br><span class="line">	<span class="comment">/**&lt; RCU defer queue size.</span></span><br><span class="line"><span class="comment">	 * default: total hash table entries.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> trigger_reclaim_limit;	<span class="comment">/**&lt; Threshold to trigger auto reclaim. */</span></span><br><span class="line">	<span class="type">uint32_t</span> max_reclaim_size;</span><br><span class="line">	<span class="comment">/**&lt; Max entries to reclaim in one go.</span></span><br><span class="line"><span class="comment">	 * default: RTE_HASH_RCU_DQ_RECLAIM_MAX.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> *key_data_ptr;</span><br><span class="line">	<span class="comment">/**&lt; Pointer passed to the free function. Typically, this is the</span></span><br><span class="line"><span class="comment">	 * pointer to the data structure to which the resource to free</span></span><br><span class="line"><span class="comment">	 * (key-data) belongs. This can be NULL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rte_hash_free_key_data free_key_data_func;</span><br><span class="line">	<span class="comment">/**&lt; Function to call to free the resource (key-data). */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//若在创建时配置了RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF，则需要配置rcu</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_hash_rcu_qsbr_add</span><span class="params">(<span class="keyword">struct</span> rte_hash *h, <span class="keyword">struct</span> rte_hash_rcu_config *cfg)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="Hash表的使用"><a href="#Hash表的使用" class="headerlink" title="Hash表的使用"></a>Hash表的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入key-value</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_hash_add_key_data</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_hash *h, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="comment">//查询key所对应的value</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_hash_lookup_data</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_hash *h, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">void</span> **data)</span>;</span><br><span class="line"><span class="comment">//删除key</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_hash_del_key</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_hash *h, <span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="LPM-Longest-Prefix-Match"><a href="#LPM-Longest-Prefix-Match" class="headerlink" title="LPM(Longest Prefix Match)"></a>LPM(Longest Prefix Match)</h1><p>使用DIR-24-8算法的变体实现，以空间换时间。使得lpm的查找最多花费两次访存操作(大部分情况下仅访存一次)</p>
<h2 id="DIR-24-8算法原理"><a href="#DIR-24-8算法原理" class="headerlink" title="DIR-24-8算法原理"></a>DIR-24-8算法原理</h2><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>建立一个规则表和一个巨大的lpm表。其中lpm表中的每个表项的索引为ip地址(32位无符号整数)，表项内容为：</p>
<ul>
<li>valid：有效位</li>
<li>depth：前缀长度</li>
<li>next hop：下一跳地址(网卡端口号)</li>
</ul>
<p>添加规则时：</p>
<ul>
<li>将规则添加到规则表中</li>
<li>根据所提供的CIDR，计算该规则的ip地址范围，在该范围内根据表项的valid和depth值，决定是否更新lpm表项</li>
</ul>
<p>删除规则时：</p>
<ul>
<li>将规则从规则表中删除</li>
<li>根据所提供的CIDR，计算该规则的ip地址范围，同时在规则表中寻找是否有包含该规则的最小母规则。若存在，则用母规则更新lpm表项，否则将对应的lpm表项置为无效</li>
</ul>
<p>规则匹配时：直接访问ip所对应的lpm表项，并根据有效位来决定返回的结果。</p>
<h3 id="DIR-24-8算法"><a href="#DIR-24-8算法" class="headerlink" title="DIR-24-8算法"></a>DIR-24-8算法</h3><p>由于朴素算法所占用的内存过于庞大，为平衡内存占用和查找性能，将lpm表项分为两级：</p>
<ul>
<li>包含2^24个表项的tbl24（索引为ip地址的高24位）</li>
<li>包含2^8个表项的tbl8（索引为ip地址的低8位）</li>
</ul>
<p>类似于用于虚拟内存的多级分页表机制，将lpm表分为两级后表项本身所占用的内存大幅度减小。因为绝大多数的路由规则不会去配置大于24的前缀长度，所以该优化不会使得规则匹配的性能有很大的下降。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_lpm_tbl_entry</span> {</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Stores Next hop ((tbl8) or (tbl24 when valid_group is not set)) or</span></span><br><span class="line"><span class="comment">	 * a group index pointing to a tbl8 structure (tbl24 only, when</span></span><br><span class="line"><span class="comment">	 * valid_group is set)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> next_hop    :<span class="number">24</span>;</span><br><span class="line">	<span class="comment">/* Using single uint8_t to store 3 values. */</span></span><br><span class="line">	<span class="type">uint32_t</span> valid       :<span class="number">1</span>;   <span class="comment">/**&lt; Validation flag. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * For tbl24:</span></span><br><span class="line"><span class="comment">	 *  - valid_group == 0: entry stores a next hop</span></span><br><span class="line"><span class="comment">	 *  - valid_group == 1: entry stores a group_index pointing to a tbl8</span></span><br><span class="line"><span class="comment">	 * For tbl8:</span></span><br><span class="line"><span class="comment">	 *  - valid_group indicates whether the current tbl8 is in use or not</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> valid_group :<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint32_t</span> depth       :<span class="number">6</span>; <span class="comment">/**&lt; Rule depth. */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h2 id="LPM使用"><a href="#LPM使用" class="headerlink" title="LPM使用"></a>LPM使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_lpm_config</span> {</span></span><br><span class="line">	<span class="type">uint32_t</span> max_rules;      <span class="comment">/**&lt; Max number of rules. */</span></span><br><span class="line">	<span class="type">uint32_t</span> number_tbl8s;   <span class="comment">/**&lt; Number of tbl8s to allocate. */</span></span><br><span class="line">	<span class="type">int</span> flags;               <span class="comment">/**&lt; This field is currently unused. */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//lpm表创建</span></span><br><span class="line"><span class="keyword">struct</span> rte_lpm *</span><br><span class="line"><span class="title function_">rte_lpm_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> rte_lpm_config *config)</span>;</span><br><span class="line"><span class="comment">//lpm表无锁化支持</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_lpm_rcu_qsbr_add</span><span class="params">(<span class="keyword">struct</span> rte_lpm *lpm, <span class="keyword">struct</span> rte_lpm_rcu_config *cfg)</span>;</span><br><span class="line"><span class="comment">//规则添加</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_lpm_add</span><span class="params">(<span class="keyword">struct</span> rte_lpm *lpm, <span class="type">uint32_t</span> ip, <span class="type">uint8_t</span> depth, <span class="type">uint32_t</span> next_hop)</span>;</span><br><span class="line"><span class="comment">//规则删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_lpm_delete</span><span class="params">(<span class="keyword">struct</span> rte_lpm *lpm, <span class="type">uint32_t</span> ip, <span class="type">uint8_t</span> depth)</span>;</span><br><span class="line"><span class="comment">//规则匹配</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_lpm_lookup</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_lpm *lpm, <span class="type">uint32_t</span> ip, <span class="type">uint32_t</span> *next_hop)</span></span><br></pre></td></tr></table></figure>



<h1 id="LPM6"><a href="#LPM6" class="headerlink" title="LPM6"></a>LPM6</h1><p>与lpm的实现类似，将lpm表项分为14级，第1级为tbl24，后面的13级为tbl8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_lpm6_tbl_entry</span> {</span></span><br><span class="line">	<span class="type">uint32_t</span> next_hop:	<span class="number">21</span>;  <span class="comment">/**&lt; Next hop / next table to be checked. */</span></span><br><span class="line">	<span class="type">uint32_t</span> depth	:<span class="number">8</span>;      <span class="comment">/**&lt; Rule depth. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Flags. */</span></span><br><span class="line">	<span class="type">uint32_t</span> valid     :<span class="number">1</span>;   <span class="comment">/**&lt; Validation flag. */</span></span><br><span class="line">    <span class="comment">//虽然会被设置，但实际上这一标志位没有被用到</span></span><br><span class="line">	<span class="type">uint32_t</span> valid_group :<span class="number">1</span>; <span class="comment">/**&lt; Group validation flag. */</span></span><br><span class="line">	<span class="type">uint32_t</span> ext_entry :<span class="number">1</span>;   <span class="comment">/**&lt; External entry. */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h1 id="RIB-Routing-Information-Base"><a href="#RIB-Routing-Information-Base" class="headerlink" title="RIB(Routing Information Base)"></a>RIB(Routing Information Base)</h1><p>路由信息表，提供路由信息的存储。</p>
<p>采用二叉树结构来管理路由表项，每个路由表项都存储在唯一的一个二叉树节点中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_rib_node</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_rib_node</span>	*<span class="title">left</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_rib_node</span>	*<span class="title">right</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_rib_node</span>	*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span>	ip;</span><br><span class="line">	<span class="type">uint8_t</span>		depth;</span><br><span class="line">	<span class="type">uint8_t</span>		flag;	<span class="comment">//记录该节点是中间节点还是路由节点</span></span><br><span class="line">	<span class="type">uint64_t</span>	nh;		<span class="comment">//下一跳</span></span><br><span class="line">	__extension__ <span class="type">uint64_t</span> ext[];	<span class="comment">//用户设置的额外数据</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>由路由表项所构建的二叉树的规则如下：</p>
<ul>
<li>每个节点都代表一个CIDR地址块(表示ip地址范围)</li>
<li>每个节点所代表的ip地址范围都包含在父节点的ip地址范围中，根节点除外</li>
<li>将每个节点所代表的ip地址范围对半分，左孩子节点位于较低的ip地址范围，右孩子节点位于较高的ip地址范围</li>
</ul>
<p>其中二叉树的节点被分为两类：</p>
<ol>
<li>路由节点：存放着路由表项的节点</li>
<li>中间节点：为了维持二叉树结构所使用的节点，本身不属于任何路由表项</li>
</ol>
<p><a href="/images/rib_internals.svg" title="rib binary tree" class="gallery-item" style="box-shadow: none;"> <img src="/images/rib_internals.svg" alt="rib binary tree"></a></p>
<h2 id="RIB使用"><a href="#RIB使用" class="headerlink" title="RIB使用"></a>RIB使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_rib_conf</span> {</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Size of extension block inside rte_rib_node.</span></span><br><span class="line"><span class="comment">	 * This space could be used to store additional user</span></span><br><span class="line"><span class="comment">	 * defined data.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">size_t</span>	ext_sz;</span><br><span class="line">	<span class="comment">/* size of rte_rib_node's pool */</span></span><br><span class="line">	<span class="type">int</span>	max_nodes;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//rib表创建</span></span><br><span class="line"><span class="keyword">struct</span> rte_rib *</span><br><span class="line"><span class="title function_">rte_rib_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> socket_id, <span class="type">const</span> <span class="keyword">struct</span> rte_rib_conf *conf)</span></span><br><span class="line"><span class="comment">//插入CIDR到rib表中并返回对应的路由表项</span></span><br><span class="line"><span class="keyword">struct</span> rte_rib_node *</span><br><span class="line"><span class="title function_">rte_rib_insert</span><span class="params">(<span class="keyword">struct</span> rte_rib *rib, <span class="type">uint32_t</span> ip, <span class="type">uint8_t</span> depth)</span>;</span><br><span class="line"><span class="comment">//查找该ip地址所匹配的最佳路由表项</span></span><br><span class="line"><span class="keyword">struct</span> rte_rib_node *</span><br><span class="line"><span class="title function_">rte_rib_lookup</span><span class="params">(<span class="keyword">struct</span> rte_rib *rib, <span class="type">uint32_t</span> ip)</span>;</span><br><span class="line"><span class="comment">//查找该CIDR所对应的路由表项</span></span><br><span class="line"><span class="keyword">struct</span> rte_rib_node *</span><br><span class="line"><span class="title function_">rte_rib_lookup_exact</span><span class="params">(<span class="keyword">struct</span> rte_rib *rib, <span class="type">uint32_t</span> ip, <span class="type">uint8_t</span> depth)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="FIB-Forwarding-Information-Base"><a href="#FIB-Forwarding-Information-Base" class="headerlink" title="FIB(Forwarding Information Base)"></a>FIB(Forwarding Information Base)</h1><p>转发表，内部使用rib表存储路由表项并帮助生成转发表。目前转发表所使用的算法有两个：</p>
<ol>
<li>Dummy：将rib表作为fib表使用，由于rib表做路由查找很慢，所以该算法用于测试和程序调试时使用</li>
<li>DIR-24-8：与上面所讲到的lpm表所使用的算法类似，提供高性能的路由查找</li>
</ol>
<h2 id="DIR-24-8"><a href="#DIR-24-8" class="headerlink" title="DIR-24-8"></a>DIR-24-8</h2><p>与lpm的算法不同的是，tbl24和tbl8结构更为紧凑，且next hop的大小可配置。若next hop配置为1字节，则tbl24和tbl8表项构成如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tbl24</span>/<span class="title">tbl8</span> {</span></span><br><span class="line">    <span class="type">uint8_t</span> extend:<span class="number">1</span>;	<span class="comment">//0位</span></span><br><span class="line">    <span class="type">uint8_t</span> next_hop:<span class="number">7</span>;	<span class="comment">//1~7位</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>由于使用了一位用于判断是否存在扩展表，实际的next hop取值范围减小一半。下面为DIR-24-8算法所使用的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir24_8_tbl</span> {</span></span><br><span class="line">	<span class="type">uint32_t</span>	number_tbl8s;	<span class="comment">/**&lt; Total number of tbl8s */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若新增的路由规则需要添加tbl8时，该成员加一。若该值等于number_tb8s，则无法添加该条路由。</span></span><br><span class="line">	<span class="type">uint32_t</span>	rsvd_tbl8s;	<span class="comment">/**&lt; Number of reserved tbl8s */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该成员的值可能小于rsvd_tlb8s的值。例如某个tbl8中所有的next hop的值都相等的情况下，会删除该tbl8，使得cur_tbl8s值变小。在删除某个路由表项时可能会将删除的tbl8添加回来。</span></span><br><span class="line">	<span class="type">uint32_t</span>	cur_tbl8s;	<span class="comment">/**&lt; Current number of tbl8s */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_fib_dir24_8_nh_sz</span>	<span class="title">nh_sz</span>;</span>	<span class="comment">/**&lt; Size of nexthop entry */</span></span><br><span class="line">	<span class="type">uint64_t</span>	def_nh;		<span class="comment">/**&lt; Default next hop */</span></span><br><span class="line">	<span class="type">uint64_t</span>	*tbl8;		<span class="comment">/**&lt; tbl8 table. */</span></span><br><span class="line">	<span class="type">uint64_t</span>	*tbl8_idxes;	<span class="comment">/**&lt; bitmap containing free tbl8 idxes*/</span></span><br><span class="line">	<span class="comment">/* tbl24 table. */</span></span><br><span class="line">	__extension__ <span class="type">uint64_t</span>	tbl24[<span class="number">0</span>] __rte_cache_aligned;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>路由查找流程如下图所示</p>
<p><a href="/images/dir_24_8_alg.svg" title="DIR-24-8 lookup" class="gallery-item" style="box-shadow: none;"> <img src="/images/dir_24_8_alg.svg" alt="DIR-24-8 lookup"></a></p>
<h2 id="FIB使用"><a href="#FIB使用" class="headerlink" title="FIB使用"></a>FIB使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_fib_conf</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_fib_type</span> <span class="title">type</span>;</span> <span class="comment">/**&lt; Type of FIB struct */</span></span><br><span class="line">	<span class="comment">/** Default value returned on lookup if there is no route */</span></span><br><span class="line">	<span class="type">uint64_t</span> default_nh;</span><br><span class="line">	<span class="type">int</span>	max_routes;</span><br><span class="line">	<span class="comment">/** Size of the node extension in the internal RIB struct */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> rib_ext_sz;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="class"><span class="keyword">enum</span> <span class="title">rte_fib_dir24_8_nh_sz</span> <span class="title">nh_sz</span>;</span></span><br><span class="line">			<span class="type">uint32_t</span>	num_tbl8;</span><br><span class="line">		} dir24_8;</span><br><span class="line">	};</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> rte_fib *</span><br><span class="line"><span class="title function_">rte_fib_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> socket_id, <span class="keyword">struct</span> rte_fib_conf *conf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_fib_add</span><span class="params">(<span class="keyword">struct</span> rte_fib *fib, <span class="type">uint32_t</span> ip, <span class="type">uint8_t</span> depth, <span class="type">uint64_t</span> next_hop)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_fib_delete</span><span class="params">(<span class="keyword">struct</span> rte_fib *fib, <span class="type">uint32_t</span> ip, <span class="type">uint8_t</span> depth)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_fib_lookup_bulk</span><span class="params">(<span class="keyword">struct</span> rte_fib *fib, <span class="type">uint32_t</span> *ips,</span></span><br><span class="line"><span class="params">		<span class="type">uint64_t</span> *next_hops, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="ACL-Access-Control-Lists"><a href="#ACL-Access-Control-Lists" class="headerlink" title="ACL(Access Control Lists)"></a>ACL(Access Control Lists)</h1><p>访问控制库，通过加载具有多个类别的一组AC规则，对输入报文进行N元组搜索，为输入报文找到每个类别的最佳匹配。</p>
<h2 id="AC规则定义"><a href="#AC规则定义" class="headerlink" title="AC规则定义"></a>AC规则定义</h2><p>规则域可以看作是规则的模板，定义了AC规则中各个字段(field)的匹配行为。一个AC规则集对应一组规则域，在该规则集中所有添加的规则都是以该规则域为模板的。在实际使用时，acl库会为每个规则集构建一个AC上下文用于规则匹配。下面是规则域的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_field_def</span> {</span></span><br><span class="line">    <span class="type">uint8_t</span> type;         <span class="comment">/*&lt; type - ACL_FIELD_TYPE. */</span></span><br><span class="line">    <span class="type">uint8_t</span> size;         <span class="comment">/*&lt; size of field 1,2,4, or 8. */</span></span><br><span class="line">    <span class="type">uint8_t</span> field_index;  <span class="comment">/*&lt; index of field inside the rule. */</span></span><br><span class="line">    <span class="type">uint8_t</span> input_index;  <span class="comment">/*&lt; 0-N input index. */</span></span><br><span class="line">    <span class="type">uint32_t</span> offset;      <span class="comment">/*&lt; offset to start of field. */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<ul>
<li><p>type字段：</p>
<ol>
<li><p>RTE_ACL_FIELD_TYPE_MASK：规则提供前缀和前缀掩码长度，匹配时将输入数据和前缀长度所对应的掩码相与，将其结果与前缀比较。常用于对IP地址的前缀匹配。</p>
</li>
<li><p>RTE_ACL_FIELD_TYPE_RANGE：根据规则所提供的范围的上下限，判断输入数据是否在给定范围内。常用于对端口的范围匹配。</p>
</li>
<li><p>RTE_ACL_FIELD_TYPE_BITMASK：规则所提供二进制串和比特掩码，匹配时将输入数据和比特掩码相与，将其结果与二进制串比较。常用于对协议号的匹配。</p>
</li>
</ol>
</li>
<li><p>size字段：定义该规则域所需的输入数据的字节长度。需要注意的是，如果该规则域设置为1或2字节长度，则需要其他规则域与该规则域组成一个完整的输入组。同时，为了规则构建过程中的进一步优化，8字节长度最好分为两个4字节长度。</p>
</li>
<li><p>field_index字段：表明该规则域在规则中的位置，从0开始。</p>
</li>
<li><p>input_index字段：除了第一个规则域，其他规则域所需的所有的输入数据必须以连续的4个字节为一组（被称为输入组）。该字段指明了该规则域的输入数据属于哪个输入组。匹配时会每次读取一个输入组。</p>
</li>
<li><p>offset字段：定义了该规则域所需的输入数据在输入缓冲区中的偏移。</p>
</li>
</ul>
<p>对于规则域的定义需要注意：</p>
<ul>
<li>第一个规则域的size字段长度必须为1，且属于单独的一个输入组。</li>
<li>其余的规则域所需的输入数据必须以连续的4个字节为一个输入组（如果少于连续的4个字节则需要补充至4个，即使没有用到）。</li>
</ul>
<p>例如，定义一个4-tuple规则集，匹配时输入缓冲区中数据的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acl_key</span> {</span></span><br><span class="line">    <span class="type">uint8_t</span> ip_proto;</span><br><span class="line">    <span class="type">uint16_t</span> port_src;</span><br><span class="line">    <span class="type">uint16_t</span> port_dst;</span><br><span class="line">    <span class="type">uint32_t</span> ip_src;</span><br><span class="line">    <span class="type">uint32_t</span> ip_dst;</span><br><span class="line">    <span class="type">uint8_t</span> tos;      <span class="comment">/*&lt; This is partially using a 32-bit input element */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>该规则集的规则域定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_field_def</span> <span class="title">ipv4_defs</span>[6] =</span> {</span><br><span class="line">    <span class="comment">/* first input field - always one byte long. */</span></span><br><span class="line">    {</span><br><span class="line">        .type = RTE_ACL_FIELD_TYPE_BITMASK,</span><br><span class="line">        .size = <span class="keyword">sizeof</span> (<span class="type">uint8_t</span>),</span><br><span class="line">        .field_index = <span class="number">0</span>,</span><br><span class="line">        .input_index = <span class="number">0</span>,</span><br><span class="line">        .offset = offsetof (<span class="keyword">struct</span> acl_key, ip_proto),</span><br><span class="line">    },</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Next 2 fields (src &amp; dst ports) form 4 consecutive bytes.</span></span><br><span class="line"><span class="comment">     * They share the same input index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    {</span><br><span class="line">        .type = RTE_ACL_FIELD_TYPE_RANGE,</span><br><span class="line">        .size = <span class="keyword">sizeof</span> (<span class="type">uint16_t</span>),</span><br><span class="line">        .field_index = <span class="number">1</span>,</span><br><span class="line">        .input_index = <span class="number">1</span>,</span><br><span class="line">        .offset = offsetof (<span class="keyword">struct</span> acl_key, port_src),</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        .type = RTE_ACL_FIELD_TYPE_RANGE,</span><br><span class="line">        .size = <span class="keyword">sizeof</span> (<span class="type">uint16_t</span>),</span><br><span class="line">        .field_index = <span class="number">2</span>,</span><br><span class="line">        .input_index = <span class="number">1</span>,</span><br><span class="line">        .offset = offsetof (<span class="keyword">struct</span> acl_key, port_dst),</span><br><span class="line">    },</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* next input field (IPv4 source address) - 4 consecutive bytes. */</span></span><br><span class="line">    {</span><br><span class="line">        .type = RTE_ACL_FIELD_TYPE_MASK,</span><br><span class="line">        .size = <span class="keyword">sizeof</span> (<span class="type">uint32_t</span>),</span><br><span class="line">        .field_index = <span class="number">3</span>,</span><br><span class="line">        .input_index = <span class="number">2</span>,</span><br><span class="line">       .offset = offsetof (<span class="keyword">struct</span> acl_key, ip_src),</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* next input field (IPv4 destination address) - 4 consecutive bytes. */</span></span><br><span class="line">    {</span><br><span class="line">        .type = RTE_ACL_FIELD_TYPE_MASK,</span><br><span class="line">        .size = <span class="keyword">sizeof</span> (<span class="type">uint32_t</span>),</span><br><span class="line">        .field_index = <span class="number">4</span>,</span><br><span class="line">        .input_index = <span class="number">3</span>,</span><br><span class="line">       .offset = offsetof (<span class="keyword">struct</span> acl_key, ip_dst),</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Next element of search key (Type of Service) is indeed 1 byte long.</span></span><br><span class="line"><span class="comment">     * Anyway we need to allocate all the 4 consecutive bytes for it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    {</span><br><span class="line">        .type = RTE_ACL_FIELD_TYPE_BITMASK,</span><br><span class="line">        .size = <span class="keyword">sizeof</span> (<span class="type">uint32_t</span>), <span class="comment">/* All the 4 consecutive bytes are allocated */</span></span><br><span class="line">        .field_index = <span class="number">5</span>,</span><br><span class="line">        .input_index = <span class="number">4</span>,</span><br><span class="line">        .offset = offsetof (<span class="keyword">struct</span> acl_key, tos),</span><br><span class="line">    },</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>根据上述规则域的定义，对规则的编写如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source addr/mask  destination addr/mask  source ports dest ports  tos/mask protocol/mask</span><br><span class="line">192.168.1.0/24    192.168.2.31/32        0:65535      1234:1234   1/0xff   6/0xff</span><br></pre></td></tr></table></figure>



<p>上面的规则是以配置文件方式展示，实际代码中规则对应如下数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Miscellaneous data for ACL rule.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_rule_data</span> {</span></span><br><span class="line">    <span class="comment">//该规则所属类别的掩码</span></span><br><span class="line">	<span class="type">uint32_t</span> category_mask; <span class="comment">/**&lt; Mask of categories for that rule. */</span></span><br><span class="line">    <span class="comment">//若存在多条priority相等的规则且匹配时同时命中，因为优先级相同，所以返回的结果是不确定的。</span></span><br><span class="line">    <span class="comment">//对于每条规则，其priority应该是独一无二的。</span></span><br><span class="line">    <span class="comment">//其取值范围为[1, (2^29)-1]</span></span><br><span class="line">	<span class="type">int32_t</span>  priority;      <span class="comment">/**&lt; Priority for that rule. */</span></span><br><span class="line">	<span class="type">uint32_t</span> userdata;      <span class="comment">/**&lt; Associated with the rule user data. */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defines the value of a field for a rule.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_field</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">rte_acl_field_types</span> <span class="title">value</span>;</span></span><br><span class="line">	<span class="comment">/**&lt; a 1,2,4, or 8 byte value of the field. */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">rte_acl_field_types</span> <span class="title">mask_range</span>;</span></span><br><span class="line">	<span class="comment">/**&lt;</span></span><br><span class="line"><span class="comment">	 * depending on field type:</span></span><br><span class="line"><span class="comment">	 * mask -&gt; 1.2.3.4/32 value=0x1020304, mask_range=32,</span></span><br><span class="line"><span class="comment">	 * range -&gt; 0 : 65535 value=0, mask_range=65535,</span></span><br><span class="line"><span class="comment">	 * bitmask -&gt; 0x06/0xff value=6, mask_range=0xff.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defines single ACL rule.</span></span><br><span class="line"><span class="comment"> * data - miscellaneous data for the rule.</span></span><br><span class="line"><span class="comment"> * field[] - value and mask or range for each field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	RTE_ACL_RULE_DEF(name, fld_num)	struct name {\</span></span><br><span class="line"><span class="meta">	struct rte_acl_rule_data data;               \</span></span><br><span class="line"><span class="meta">	struct rte_acl_field field[fld_num];         \</span></span><br><span class="line"><span class="meta">}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//General rule representation</span></span><br><span class="line">RTE_ACL_RULE_DEF(rte_acl_rule,);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ACL rule size</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	RTE_ACL_RULE_SZ(fld_num)	\</span></span><br><span class="line"><span class="meta">	(sizeof(struct rte_acl_rule) + sizeof(struct rte_acl_field) * (fld_num))</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>需要注意的是规则中所使用的数据均为主机字节序(LSB)。在规则匹配时，输入缓冲区中的数据为网络字节序(MSB)。</p>
</blockquote>
<h2 id="ACL使用"><a href="#ACL使用" class="headerlink" title="ACL使用"></a>ACL使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_param</span> {</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;         <span class="comment">/**&lt; Name of the ACL context. */</span></span><br><span class="line">	<span class="type">int</span>         socket_id;    <span class="comment">/**&lt; Socket ID to allocate memory for. */</span></span><br><span class="line">    <span class="comment">//该规则集中规则的大小，可设置为 RTE_ACL_RULE_SZ(fld_num)</span></span><br><span class="line">	<span class="type">uint32_t</span>    rule_size;    <span class="comment">/**&lt; Size of each rule. */</span></span><br><span class="line">	<span class="type">uint32_t</span>    max_rule_num; <span class="comment">/**&lt; Maximum number of rules. */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//创建规则集的AC上下文</span></span><br><span class="line"><span class="keyword">struct</span> rte_acl_ctx * <span class="title function_">rte_acl_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_acl_param *param)</span>;</span><br><span class="line"><span class="comment">//添加规则到规则集中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_acl_add_rules</span><span class="params">(<span class="keyword">struct</span> rte_acl_ctx *ctx, <span class="type">const</span> <span class="keyword">struct</span> rte_acl_rule *rules,</span></span><br><span class="line"><span class="params">	<span class="type">uint32_t</span> num)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ACL build configuration.</span></span><br><span class="line"><span class="comment"> * Defines the fields of an ACL trie and number of categories to build with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> rte_acl_config {</span><br><span class="line">    <span class="comment">//类别数，最多16个，最少1个</span></span><br><span class="line">	<span class="type">uint32_t</span> num_categories; <span class="comment">/**&lt; Number of categories to build with. */</span></span><br><span class="line">    <span class="comment">//规则域个数，不得多于64个</span></span><br><span class="line">	<span class="type">uint32_t</span> num_fields;     <span class="comment">/**&lt; Number of field definitions. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_field_def</span> <span class="title">defs</span>[<span class="title">RTE_ACL_MAX_FIELDS</span>];</span></span><br><span class="line">	<span class="comment">/**&lt; array of field definitions. */</span></span><br><span class="line">    <span class="comment">//若为0则表示没有内存限制，构建时会以最小内存代价构建trie，这可能会增加构建耗时。</span></span><br><span class="line">    <span class="comment">//若不为0则在内存限制范围内以最少trie数构建。</span></span><br><span class="line">	<span class="type">size_t</span> max_size;</span><br><span class="line">	<span class="comment">/**&lt; max memory limit for internal run-time structures. */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//构建规则集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_acl_build</span><span class="params">(<span class="keyword">struct</span> rte_acl_ctx *ctx, <span class="type">const</span> <span class="keyword">struct</span> rte_acl_config *cfg)</span></span><br><span class="line"><span class="comment">//规则集匹配，将匹配结果返回给results，results存储着每个data所匹配的categories个类别的结果，即返回每个类别下所命中的priority最高的规则的userdata</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_acl_classify</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_acl_ctx *ctx,</span></span><br><span class="line"><span class="params">		 <span class="type">const</span> <span class="type">uint8_t</span> **data,</span></span><br><span class="line"><span class="params">		 <span class="type">uint32_t</span> *results, <span class="type">uint32_t</span> num,</span></span><br><span class="line"><span class="params">		 <span class="type">uint32_t</span> categories)</span>;	<span class="comment">//必须为4的倍数</span></span><br></pre></td></tr></table></figure>



<h2 id="ACL实现原理"><a href="#ACL实现原理" class="headerlink" title="ACL实现原理"></a>ACL实现原理</h2><p>根据所提供的规则构建trie，而后将trie视为dfa，生成转移矩阵，用于规则匹配。</p>
<h3 id="Binary-Trie"><a href="#Binary-Trie" class="headerlink" title="Binary Trie"></a>Binary Trie</h3><p>前缀二叉树，一种用于快速检索的二叉树结构，其基本性质如下：</p>
<ul>
<li>边存储匹配信息，节点存储匹配结果</li>
<li>每条边都代表二进制串的一位，节点指向左孩子的边代表0，指向右孩子的边代表1。第0层节点的边（根节点指向孩子节点的边）对应二进制串的最高位，第二层节点的边对应二进制串的次高位，以此类推。</li>
<li>从根节点到某一结点，路径上经过的二进制数连接起来，为该节点对应的二进制串前缀</li>
<li>规则集所定义的规则匹配长度为树的高度，且所有叶节点都处于同一层</li>
</ul>
<p>例：规则集定义了规则匹配长度为4bit，且规则集中添加了三条规则</p>
<table>
<thead>
<tr>
<th>rule1:range</th>
<th>rule2:bitmask</th>
<th>rule3:mask</th>
</tr>
</thead>
<tbody><tr>
<td>0b1101~0b1110</td>
<td>0b1011/0xf</td>
<td>0b0100/2</td>
</tr>
</tbody></table>
<p>构建的binary trie如下：</p>
<p><a href="/images/binary_tire.svg" title="binary_trie" class="gallery-item" style="box-shadow: none;"> <img src="/images/binary_tire.svg" alt="binary_trie"></a></p>
<p>对该AC规则集进行匹配时，从根节点开始遍历，根据输入的二进制串决定下一个遍历的孩子节点，若遍历到叶子节点，则匹配成功，否则匹配失败。</p>
<h3 id="Multi-bit-Trie"><a href="#Multi-bit-Trie" class="headerlink" title="Multi-bit Trie"></a>Multi-bit Trie</h3><p>实际使用时规则集的输入匹配长度是由输入组的数量决定的，而对于经常使用的ipv4的5-tuple来说，其输入组有4个，换算成bit长度有104位，利用binary trie对该规则集进行构建则最多需要申请<code>2^105 - 1</code>个节点，因此直接采用binary trie来构建规则集是不切实际的。</p>
<p>Multi-bit trie是Binary trie的一种扩展，其边的权值可以表示多个二进制位，其可以表示二进制位的个数称为<strong>步长</strong>，比如Binary trie的步长为1，在dpdk中则采用步长为8的Multi-bit trie。相比于Binary trie，每个节点最多可以有2^8条出边，且树的高度改为由匹配长度的字节数而非比特数决定。这样做对内部节点会有些许的减少，但整体上对于内存的消耗还是不可估量的。使得Multi-bit trie相比于Binary trie更加实用的原因在于，Multi-bit trie的边不仅可以表示一个值，而且可以表示一个集合，这使得构建trie所需的节点大大减少。</p>
<h4 id="Multi-bit-trie优化"><a href="#Multi-bit-trie优化" class="headerlink" title="Multi-bit trie优化"></a>Multi-bit trie优化</h4><p>由于field0的特殊性（匹配上下文初始化时固定读取<code>input_index：0</code>作为初始状态），下列优化不考虑规则的field0。</p>
<h5 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h5><p>统计规则集中每条规则中每个field的匹配范围与该field取值范围之比（代码中采用wildness百分制表示）。对于该规则集中所有规则来说，若存在某个input_index，其对应的field的wildness均为100，则说明对于该规则集，无论该input_index所对应的输入是什么，都一定命中该规则集中所有的规则。这种情况下，在构建trie时，可以不加载该input_index所属的field，同时匹配时也跳过对该input_index的读取。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>field0（input_index：0）</th>
<th>field1（input_index：1）</th>
<th>field2（input_index：1）</th>
<th>field3（input_index：2）</th>
</tr>
</thead>
<tbody><tr>
<td>rule1</td>
<td>0x07/0xff</td>
<td>0x0000~0xffff</td>
<td>0x0000~0xffff</td>
<td>0xf3000000/24</td>
</tr>
<tr>
<td>rule2</td>
<td>0x12/0xff</td>
<td>0x0000~0xffff</td>
<td>0x0000~0xffff</td>
<td>0x5932a124/24</td>
</tr>
<tr>
<td>rule3</td>
<td>0x12/0xff</td>
<td>0x0000~0xffff</td>
<td>0x0000~0xffff</td>
<td>0x12341355/8</td>
</tr>
</tbody></table>
<p>在该规则集中，所有规则的<code>input_index：1</code>的wildness都为100，这时构建trie时，就可以忽略规则中的<code>field1</code>和<code>field2</code>了。同时匹配时跳过对<code>input_index：1</code>的匹配。</p>
<h5 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h5><p>将规则按照wildness进行排序，构建trie时优先添加wildness值大的规则到树中。（意义不明）</p>
<h5 id="优化3"><a href="#优化3" class="headerlink" title="优化3"></a>优化3</h5><p>根据规则集规则加载情况，动态增加构建的trie的数目，最多可构建8颗trie。这样做减少了构建trie时总体的内存占用，但增加了构建时间。</p>
<h5 id="优化4"><a href="#优化4" class="headerlink" title="优化4"></a>优化4</h5><p>对于每条规则，每个field只创建一个节点作为匹配成功的标志。这样做进一步减少了内存的占用。</p>
<h4 id="Multi-bit-trie构建流程"><a href="#Multi-bit-trie构建流程" class="headerlink" title="Multi-bit trie构建流程"></a>Multi-bit trie构建流程</h4><p>读取规则集中的规则，将每条规则都构建成一颗trie子树，并将每颗子树合并到trie的根节点中。节点是trie的主要数据结构，其成员如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_node</span> {</span></span><br><span class="line">	<span class="type">uint64_t</span> node_index;  <span class="comment">/* index for this node */</span></span><br><span class="line">	<span class="type">uint32_t</span> level;       <span class="comment">/* level 0-n in the trie */</span></span><br><span class="line">    <span class="comment">//初始为1，每有一个节点指向该节点，该节点的引用计数就加1</span></span><br><span class="line">	<span class="type">uint32_t</span> ref_count;   <span class="comment">/* ref count for this node */</span></span><br><span class="line">    <span class="comment">//所有出边的边权值的集合，bitmap表示</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_bitset</span>  <span class="title">values</span>;</span></span><br><span class="line">	<span class="comment">/* set of all values that map to another node</span></span><br><span class="line"><span class="comment">	 * (union of bits in each transition.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//出边个数</span></span><br><span class="line">	<span class="type">uint32_t</span>                num_ptrs; <span class="comment">/* number of ptr_set in use */</span></span><br><span class="line">    <span class="comment">//出边数组大小</span></span><br><span class="line">	<span class="type">uint32_t</span>                max_ptrs; <span class="comment">/* number of allocated ptr_set */</span></span><br><span class="line">    <span class="comment">//merge node时使用，起隔离作用。</span></span><br><span class="line">	<span class="type">uint32_t</span>                min_add;  <span class="comment">/* number of ptr_set per allocation */</span></span><br><span class="line">    <span class="comment">//出边数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_ptr_set</span> *<span class="title">ptrs</span>;</span>     <span class="comment">/* transitions array for this node */</span></span><br><span class="line">    <span class="comment">//非0表示该节点命中规则</span></span><br><span class="line">	<span class="type">int32_t</span>                 match_flag;</span><br><span class="line">	<span class="type">int32_t</span>                 match_index; <span class="comment">/* index to match data */</span></span><br><span class="line">	<span class="type">uint32_t</span>                node_type;</span><br><span class="line">	<span class="type">int32_t</span>                 fanout;</span><br><span class="line">	<span class="comment">/* number of ranges (transitions w/ consecutive bits) */</span></span><br><span class="line">	<span class="type">int32_t</span>                 id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_match_results</span> *<span class="title">mrt</span>;</span> <span class="comment">/* only valid when match_flag != 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="type">char</span>            transitions[RTE_ACL_QUAD_SIZE];</span><br><span class="line">		<span class="comment">/* boundaries for ranged node */</span></span><br><span class="line">		<span class="type">uint8_t</span>         dfa_gr64[RTE_ACL_DFA_GR64_NUM];</span><br><span class="line">	};</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_node</span>     *<span class="title">next</span>;</span></span><br><span class="line">	<span class="comment">/* free list link or pointer to duplicate node during merge */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_acl_node</span>     *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="comment">/* points to node from which this node was duplicated */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h5 id="规则的构建"><a href="#规则的构建" class="headerlink" title="规则的构建"></a>规则的构建</h5><p>对于每条规则，根据规则域的定义，按顺序将规则中的每个field转为node节点。对于size为多个字节的field，先转化field中的高字节。</p>
<p>对于不同类型的规则域，其转化node的方式也有所不同：</p>
<ul>
<li>MASK：0x83240000/16</li>
</ul>
<p><a href="/images/mask.svg" title="mask" class="gallery-item" style="box-shadow: none;"> <img src="/images/mask.svg" alt="mask"></a></p>
<ul>
<li>BITMASK：0x07/0xff</li>
</ul>
<p><a href="/images/bitmask.svg" title="bitmask" class="gallery-item" style="box-shadow: none;"> <img src="/images/bitmask.svg" alt="bitmask"></a></p>
<ul>
<li>RANGE：0x0012~0x0855</li>
</ul>
<p><a href="/images/range.svg" title="range" class="gallery-item" style="box-shadow: none;"> <img src="/images/range.svg" alt="range"></a></p>
<p>将规则中的每个field所生成的节点首尾相接，即将field0的end作为field1的node0。最后构成一颗trie子树，该子树的树根为field0的node0节点，叶节点为fieldn的end，该end同时也代表着该规则的命中。</p>
<h5 id="规则集的构建"><a href="#规则集的构建" class="headerlink" title="规则集的构建"></a>规则集的构建</h5><p>为Multi-bit trie创建一个根节点root，而后将每条规则生成的trie子树合并到root中。</p>
<p>合并A、B节点的算法流程如下：</p>
<ol>
<li><p>若待合并的节点为叶子节点，则将A、B节点合并为新的节点，新的节点中保留A、B中各categories中priority最高的userdata并返回。</p>
</li>
<li><p>若A、B的出边存在交集，则处理交集部分。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> childa <span class="keyword">in</span> A的出边：</span><br><span class="line">    <span class="keyword">for</span> childb <span class="keyword">in</span> B的出边：</span><br><span class="line">        <span class="keyword">if</span> childa的节点 != childb的节点：</span><br><span class="line">            <span class="keyword">if</span> childa与childb的边权值存在交集：</span><br><span class="line">                node = merge(childa节点和childb节点)</span><br><span class="line">                将childa与childb的交集所指向的节点更新为node</span><br></pre></td></tr></table></figure>
</li>
<li><p>将只包含在B中的出边及其出边节点更新到A节点中。</p>
</li>
</ol>
<p>在实际的代码实现过程中，还涉及到节点的复制等操作，因为不影响整体的合并流程，这里省略相关逻辑。</p>
<p>例如：规则集仅使用一个类别，且rule1的priority为100，rule2的priority为50。</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>field0（input_index：0）</th>
<th>field1（input_index：1）</th>
<th>field2（input_index：1）</th>
</tr>
</thead>
<tbody><tr>
<td>rule1</td>
<td>0x07/0xff</td>
<td>0x0000~0xf000</td>
<td>0x0000/8</td>
</tr>
<tr>
<td>rule2</td>
<td>0x07/0xff</td>
<td>0x8000~0xffff</td>
<td>0x0000/8</td>
</tr>
</tbody></table>
<p>rule1合并到trie中：</p>
<p><a href="/images/merge1.svg" title="merge1" class="gallery-item" style="box-shadow: none;"> <img src="/images/merge1.svg" alt="merge1"></a></p>
<p>rule2合并到trie中：</p>
<p><a href="/images/merge2.svg" title="merge2" class="gallery-item" style="box-shadow: none;"> <img src="/images/merge2.svg" alt="merge2"></a></p>
<h3 id="Node-array"><a href="#Node-array" class="headerlink" title="Node_array"></a>Node_array</h3><p>Multi-bit trie很好的组织了匹配过程中各状态之间的关系，为了进一步的减少内存消耗，提高匹配性能。这里将构建好的trie视为DFA(Deterministic Finite Automation)，将状态转移由指针方式转为索引方式，并存放到node_array中。匹配时就会基于输入数据和当前所处的状态，计算下一个状态在node_array中的偏移。</p>
<p>node_array中存储着的node元素被称为transition，transition是由64位二进制数组成，内部存储着当前匹配状态和状态转移条件，其格式如下：</p>
<table>
<thead>
<tr>
<th>node_type_specific : 32</th>
<th>node_type : 3</th>
<th>node_addr : 29</th>
</tr>
</thead>
</table>
<ul>
<li><p>node_type：节点类型，根据出边状态的数量，定义不同的类型。</p>
<ol>
<li>RTE_ACL_NODE_DFA：出边较多的节点，其出边状态数量大于5个时定义该类型，为了节省空间，将所有出边状态划分为4个组，每组64个出边状态。第i组包含状态[i * 64 … i * 64 + 63]。若第j组状态与第i组状态相同（j &gt; i），则删除第j组的出边。</li>
<li>RTE_ACL_NODE_QRANGE：出边较少的节点，其出边状态数量小于等于5个时定义该类型</li>
<li>RTE_ACL_NODE_SINGLE：若出边仅为一条时（也就是无论输入数据为何值，都只会向同一个状态迁移）定义该类型</li>
<li>RTE_ACL_NODE_MATCH：不存在出边时（也就是该状态为终止状态）定义该类型</li>
</ol>
</li>
<li><p>node_addr：根据node_type，具有不同的含义</p>
<ol>
<li>RTE_ACL_NODE_MATCH：此时该字段的值指向着返回数组，数组内存储着所命中规则的每个类别的priority和userdata</li>
<li>非RTE_ACL_NODE_MATCH：指向着下一个transition的基地址</li>
</ol>
</li>
<li><p>node_type_specific：根据node_type，具有不同的含义</p>
<ol>
<li><p>RTE_ACL_NODE_MATCH：该字段不被使用</p>
</li>
<li><p>RTE_ACL_NODE_QRANGE：用于状态转移计算，被解释为4个int8_t类型的值，从INT8_MIN到INT8_MAX，这4个数决定了该类型最多拥有5个出边状态</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INT8_MIN &lt;= range[<span class="number">0</span>]  &lt;= ((<span class="type">int8_t</span> *)&amp;transition)[<span class="number">4</span>]</span><br><span class="line">((<span class="type">int8_t</span> *)&amp;transition)[<span class="number">4</span>] &lt; range[<span class="number">1</span>] &lt;= ((<span class="type">int8_t</span> *)&amp;transition)[<span class="number">5</span>]</span><br><span class="line">((<span class="type">int8_t</span> *)&amp;transition)[<span class="number">5</span>] &lt; range[<span class="number">2</span>] &lt;= ((<span class="type">int8_t</span> *)&amp;transition)[<span class="number">6</span>]</span><br><span class="line">((<span class="type">int8_t</span> *)&amp;transition)[<span class="number">6</span>] &lt; range[<span class="number">3</span>] &lt;= ((<span class="type">int8_t</span> *)&amp;transition)[<span class="number">7</span>]</span><br><span class="line">((<span class="type">int8_t</span> *)&amp;transition)[<span class="number">7</span>] &lt; range[<span class="number">4</span>] &lt;= INT8_MAX</span><br></pre></td></tr></table></figure>

<p> 对于处于range[i]范围内的输入数据，可计算出要迁移的下一个状态的node_array索引为：<code>node_addr + i</code></p>
</li>
<li><p>RTE_ACL_NODE_DFA：用于状态转移计算，被解释为4个uint8_t类型的值，每个位置对应一个组，每个位置的数代表了该组出边索引。对于给定的输入数据，可计算出要迁移的下一个状态的node_array索引为：</p>
<p> <code>input_byte - ((uint8_t *)&amp;transition)[4 + input_byte / 64]</code></p>
</li>
</ol>
</li>
</ul>
<p>对于node出边状态的数量的确定方法如下：</p>
<ol>
<li>计算trie node的values（bitmap）中连续为0的区间数</li>
<li>计算trie node的各个出边values（bitmap）中连续为1的区间数</li>
<li>将上述结果相加即为出边状态数（对应trie node结构中的fanout值）</li>
</ol>
<h3 id="RT-Structure"><a href="#RT-Structure" class="headerlink" title="RT Structure"></a>RT Structure</h3><p>最终规则集所构建的用于匹配的RT(runtime) Structure的内存布局如下：</p>
<p><a href="/images/rtstruct.webp" title="rtstruct" class="gallery-item" style="box-shadow: none;"> <img src="/images/rtstruct.webp" alt="rtstruct"></a></p>
<ul>
<li>Data indexes：保存着所有输入组所对应的输入缓冲区的偏移，匹配时使用该字段确定待匹配的输入数据的位置</li>
<li>Results：保存着所有的返回数据，当命中规则时访问该数组并返回匹配结果</li>
<li>Trans table：转移矩阵，用于匹配时的状态跳转。DFA0用于构造失效节点，因为每匹配一个输入组（4个字节）后才会判断当前状态是否为终止状态。若在匹配时提前进入了匹配失效状态，则在做状态转移时会跳到DFA0内，直到当前输入组匹配完毕后再进行失效状态处理。idle节点用于空转，当没有额外的输入数据需要处理时，调用该节点做空转处理。DFAs、QUADs、SINGLEs即为trie树中依据node的不同type对应的array模式</li>
</ul>
<h3 id="匹配算法"><a href="#匹配算法" class="headerlink" title="匹配算法"></a>匹配算法</h3><p>对于RTE_ACL_NODE_SINGLE和RTE_ACL_NODE_QRANGE类型的节点，其状态转换函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="type">uint32_t</span>)input * SCALAR_QRANGE_MULT;</span><br><span class="line">a = ranges | SCALAR_QRANGE_MIN;</span><br><span class="line">a -= (c &amp; SCALAR_QRANGE_MASK);</span><br><span class="line">b = c &amp; SCALAR_QRANGE_MIN;</span><br><span class="line">a &amp;= SCALAR_QRANGE_MIN;</span><br><span class="line">a ^= (ranges ^ b) &amp; (a ^ b);</span><br><span class="line">x = scan_forward(a, <span class="number">32</span>) &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码是ACL中最为晦涩难懂的部分了。下面着重讲解下这部分代码的实现原理。</p>
<p>从对RTE_ACL_NODE_QRANGE类型的注释可以得知，ranges中存放的4个数将整个区间划分为5个部分，通过比较输入数据与ranges的4个数字的大小，即可确定输入数字属于哪个区间。上面的代码所做的，就是将input与ranges的每个数字的比较结果存放在a的每个字节的符号位中，而后根据其所在的字节位置得到区间号，其大致逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int8_t</span> a[<span class="number">4</span>] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">    <span class="keyword">if</span>(ranges[i] &gt;= input)</span><br><span class="line">        a[i] = <span class="number">0x80</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">x = (a == <span class="number">0</span>) ? <span class="number">4</span> : (a的最低有效位位数 &gt;&gt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>例如：input = 0x04，ranges = 0x3011fe83，可推出a = 0x80800000，x = 2，即输入字节属于range[2]</p>
<p>ACL中的实现采用uint32_t类型的变量，避免了for循环。同时利用逻辑运算，代替了if/else的分支逻辑，避免cpu因分支预测失败导致的流水线停顿。</p>
<p>想要理解代码中逻辑运算的原理，需要先了解对于补码是如何比较大小的：</p>
<ol>
<li>当两个数的符号位相同时，除去符号位，大的更大</li>
<li>当两个数的符号位不同时，正数大</li>
</ol>
<p>实际上代码中的逻辑运算就是利用上述的两条原理，具体注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面将所有的4字节的变量看作1字节的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将输入扩展为4字节</span></span><br><span class="line">c = (<span class="type">uint32_t</span>)input * SCALAR_QRANGE_MULT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录c的符号位</span></span><br><span class="line">b = c &amp; SCALAR_QRANGE_MIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当c[i]与ranges[i]的符号位相同时</span></span><br><span class="line"><span class="comment">//将ranges[i]的符号位置一，c[i]的符号位置零，两数相减，并将相减后的符号位记录到a中</span></span><br><span class="line"><span class="comment">//若a[i] = 0x80则说明ranges[i] &gt;= c[i]，否则a[i] = 0</span></span><br><span class="line">a = ranges | SCALAR_QRANGE_MIN;</span><br><span class="line">a -= (c &amp; SCALAR_QRANGE_MASK);</span><br><span class="line">a &amp;= SCALAR_QRANGE_MIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当c[i]与ranges[i]同号时，下列运算符号位化简为 a[i] ^= 0 &amp; (a[i] ^ b[i]) ==&gt; a[i] = a[i]</span></span><br><span class="line"><span class="comment">//当c[i]与ranges[i]异号时，下列运算符号位化简为 a[i] ^= a[i] ^ b[i] ==&gt; a[i] = b[i]</span></span><br><span class="line"><span class="comment">//由于a和b的非符号位均为0，因此下列运算非符号位化简为 a[i] ^= ranges &amp; 0 ==&gt; a[i] = 0</span></span><br><span class="line">a ^= (ranges ^ b) &amp; (a ^ b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时a数组中所出现的第一个符号位为1的成员的索引号，即为所求</span></span><br><span class="line">x = scan_forward(a, <span class="number">32</span>) &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<h1 id="EFD-Elastic-Flow-Distributor"><a href="#EFD-Elastic-Flow-Distributor" class="headerlink" title="EFD(Elastic Flow Distributor)"></a>EFD(Elastic Flow Distributor)</h1><p>常用于集群之间的分流/负载均衡，其功能与<a href="#Hash">Hash</a>类似，建立EFD表并插入&lt;key, value&gt;到EFD表中，运行时通过key值查找EFD表，并获取对应的value，若查找时的key值此前并未被插入到EFD表中，则返回一个伪随机的value。这里的key一般为流的特征，value一般为该流所要引导到的目的节点id号。</p>
<p>EFD内部存储了两个类型的表：</p>
<ul>
<li>online table(in cache)：用于频繁的查找操作，内存开销小。</li>
<li>offline table(in memory)：用于插入/更新操作，存储key/value，内存开销大。</li>
</ul>
<p>EFD特点：</p>
<ul>
<li>支持任意的key/value长度的配置(key长度通过rte_efd_create配置，value长度通过RTE_EFD_VALUE_NUM_BITS配置)</li>
<li>EFD表中用于查询的表(online table)不存储key/value值，其所需的内存大小仅与规则数量有关(rte_efd_create的max_num_rules入参)，这使得存储需求相对较小，可插入上百万条规则</li>
<li>使用完美哈希来确定key所对应的value的位置，查找性能不受key长度的影响</li>
<li>支持批量查找</li>
</ul>
<h2 id="EFD使用"><a href="#EFD使用" class="headerlink" title="EFD使用"></a>EFD使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value的二进制长度，默认为8位，用户可自定义，其范围必须在1~32之间。value的数据类型为efd_value_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_EFD_VALUE_NUM_BITS (8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//efd表创建</span></span><br><span class="line"><span class="keyword">struct</span> rte_efd_table *</span><br><span class="line"><span class="title function_">rte_efd_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> max_num_rules, <span class="type">uint32_t</span> key_len,</span></span><br><span class="line"><span class="params">	<span class="type">uint64_t</span> online_cpu_socket_bitmask, <span class="comment">//调用rte_efd_lookup的线程所在的socket的集合</span></span></span><br><span class="line"><span class="params">    <span class="type">uint8_t</span> offline_cpu_socket)</span>;		<span class="comment">//调用rte_efd_update的线程所在的socket</span></span><br><span class="line"><span class="comment">//efd表插入，非线程安全函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_efd_update</span><span class="params">(<span class="keyword">struct</span> rte_efd_table *table, <span class="type">unsigned</span> <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">void</span> *key, <span class="type">efd_value_t</span> value)</span>;</span><br><span class="line"><span class="comment">//efd表查询，需要注意的是，如果所查找的key并没有被插入到efd表中，此时返回的value为伪随机数。</span></span><br><span class="line"><span class="comment">//若不想出现这种情况，应用程序必须以某种方法保证传入的key在efd表中。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_efd_lookup_bulk</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_efd_table *table, <span class="type">unsigned</span> <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> num_keys, <span class="type">const</span> <span class="type">void</span> **key_list,</span></span><br><span class="line"><span class="params">		<span class="type">efd_value_t</span> *value_list)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="EFD原理"><a href="#EFD原理" class="headerlink" title="EFD原理"></a>EFD原理</h2><h3 id="offline-table的构建"><a href="#offline-table的构建" class="headerlink" title="offline table的构建"></a>offline table的构建</h3><p>基本思想是：利用双重hash，找到一个hash_index，使得所给定的插入key满足<code>value = hash1(key) + hash_index * hash2(key)</code>，这样EFD查找表中仅存储对应的hash_index，查找时根据所输入的key和EFD中的hash_index，直接进行hash计算即可得到对应的value。</p>
<p>当EFD表中仅存储一个&lt;key,value&gt;时，上述方法是完全可行的，但当插入的规则数增加，想找到一个能满足所有key-value映射的hash_index，是几乎不可能的。因此，采用分治的思想，将上述问题的规模分解为更小的部分。具体分解方法如下：</p>
<ol>
<li><p>将所插入的key划分成许多的group（代码中默认分为64个组），每个group大约由20~28个key组成（代码中默认每组容量为28个），每个group都存储一个该组的hash_index。这样通过限制key-value的个数，降低hash_index查找的难度。</p>
<p> <a href="/images/efd_i7.svg" title="efd_group" class="gallery-item" style="box-shadow: none;"> <img src="/images/efd_i7.svg" alt="efd_group"></a></p>
</li>
<li><p>将value按位考虑，即利用双重hash，找到一组hash_index，使得所给定的一组key-value都满足<code>value[i] = (hash1(key) + hash_index[i] * hash2(key)) &amp; 0x1</code>。下图是对于group内value[i]的hash_index的确定。</p>
<p> <a href="/images/efd_i4.svg" title="efd_value" class="gallery-item" style="box-shadow: none;"> <img src="/images/efd_i4.svg" alt="efd_value"></a></p>
<blockquote>
<p>注：在该模块的讲解中，<strong>所有的value[i]都表示value的第i位</strong></p>
</blockquote>
</li>
<li><p>基于2的分解，为了进一步降低计算value每一位时hash冲突的概率，引入lookup_table，对于所给定的一组key-value都满足<code>value[i] = (lookup_table[i] &gt;&gt; bucket_idx) &amp; 0x1</code>，其中<code>bucket_idx = (hash1(key) + hash_index[i] * hash2(key)) &gt;&gt; 23</code>。如下图所示，对于group内的每个value位，都将创建一个16位的hash_index和16位的lookup_table。</p>
<p> <a href="/images/efd_i8.svg" title="lookup_table" class="gallery-item" style="box-shadow: none;"> <img src="/images/efd_i8.svg" alt="lookup_table"></a></p>
</li>
</ol>
<h3 id="hash-index的确定"><a href="#hash-index的确定" class="headerlink" title="hash_index的确定"></a>hash_index的确定</h3><p>如下图所示，group内包含4个key-value，其中value图中仅画出第0位（其他位同理）。</p>
<p><a href="/images/efd_i10.svg" title="efd_hash_index" class="gallery-item" style="box-shadow: none;"> <img src="/images/efd_i10.svg" alt="efd_hash_index"></a></p>
<ol>
<li>令<code>hash_index = 0</code>。</li>
<li>计算出所有key所对应的bucket_index，也就是图中的position。</li>
<li>每个position都对应lookup_table中的一位，将每个key所对应的value[0]都写入lookup_table的position位中。</li>
<li>若有多个key对应同一个position，且这些key所对应的value[0]的值不同，则发生冲突。</li>
<li>发生冲突后令<code>hash_index += 1</code>，返回到步骤2执行，直到没有冲突或者达到循环上限。</li>
</ol>
<p>例如上图中的key3和key7，由于所对应的value[0]相同，即使经过hash后的position相同，也不会产生冲突，而key4和key7，由于所对应的value[0]不同，则产生hash冲突。</p>
<h3 id="chunk的引进"><a href="#chunk的引进" class="headerlink" title="chunk的引进"></a>chunk的引进</h3><p>由于上面的方案会将efd表分为64个group，每个group最多包含28个rule，这样就限制了efd表的上限为64 * 28个规则。为了避免这个限制，引入chunk这个概念，efd表中包含多个chunk，每个chunk包含64个group，每个group包含28个rule。通过这种方法，解决了规则数量限制的问题。</p>
<p>插入key-value时先要确定key所属的chunk，再确定所属的group。</p>
<h3 id="查找流程"><a href="#查找流程" class="headerlink" title="查找流程"></a>查找流程</h3><p><a href="/images/efd_i11.svg" title="efd_lookup" class="gallery-item" style="box-shadow: none;"> <img src="/images/efd_i11.svg" alt="efd_lookup"></a></p>
<p>上图中仅展现了对于key所对应的value的一位值的获取，通过上述过程的循环，可得到value的所有位的值。</p>
<h3 id="组的重平衡"><a href="#组的重平衡" class="headerlink" title="组的重平衡"></a>组的重平衡</h3><p>由于实现时对group的划分可能不平衡，导致有些group的规则多，有些group的规则少。通常规则插入所耗的时间会随着group内规则数量的增加而增加，且规则数越多，插入失败的可能性越大。为了避免这些问题，引入bins来平衡group的划分。</p>
<p>如下图所示，一个chunk包含256个bin，每个bin都会映射到固定的4个group。bin中存储着2位的索引，用于表示当前bin选择第几个映射的group。</p>
<p>在插入时将不再直接计算group，而是直接计算bin_id，找到对应的bin。若bin当前所映射的group数量过多，则切换bin中的索引，使其映射到规则数最少的group中。</p>
<p><a href="/images/efd_i12.svg" title="efd_rebalance" class="gallery-item" style="box-shadow: none;"> <img src="/images/efd_i12.svg" alt="efd_rebalance"></a></p>
<h1 id="Packet-Distributor"><a href="#Packet-Distributor" class="headerlink" title="Packet Distributor"></a>Packet Distributor</h1><p>包分发库，该库将lcore分为两类：</p>
<ul>
<li>distributor core：从网卡接收报文，将报文分发到worker core中，并回收worker core处理好的报文发往网卡。只能有一个lcore作为distributor core。</li>
<li>worker core：用于实际的报文处理。</li>
</ul>
<blockquote>
<p>distributor core和worker core不能使用同一个lcore。</p>
</blockquote>
<p><a href="/images/packet_distributor2.png" title="distributor" class="gallery-item" style="box-shadow: none;"> <img src="/images/packet_distributor2.png" alt="distributor"></a></p>
<p>数据包中的<code>mbuf-&gt;hash.usr</code>决定了distributor发往哪个worker，每个worker会向distributor告知该worker正在处理的报文的<code>mbuf-&gt;hash.usr</code>，distributor在报文分发时，会优先将报文发往<code>mbuf-&gt;hash.usr</code>相同的worker上</p>
<p>distributor会将数据包中的<code>mbuf-&gt;hash.usr</code>作为tag，且worker会记录当前所处理的报文的tag。在distributor做报文分发时，若存在y与当前报文tag相同的worker，则将报文分发到该worker上，否则分发给没有请求到报文的worker。</p>
<blockquote>
<p>需要注意的是，这种分包方法不保证同一条流的报文一定会发往同一个核。例如当worker1收到tag1的报文，处理完毕后再收到tag2的报文，此时distributor分发tag1的报文，并不一定会将该报文发往worker1。</p>
</blockquote>
<h2 id="Distributor的使用"><a href="#Distributor的使用" class="headerlink" title="Distributor的使用"></a>Distributor的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//distributor的创建</span></span><br><span class="line"><span class="keyword">struct</span> rte_distributor *</span><br><span class="line"><span class="title function_">rte_distributor_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> num_workers,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> alg_type)</span>;</span><br><span class="line"><span class="comment">//distributor core调用，用于分发报文到worker</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_distributor_process</span><span class="params">(<span class="keyword">struct</span> rte_distributor *d,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> rte_mbuf **mbufs, <span class="type">unsigned</span> <span class="type">int</span> num_mbufs)</span>;</span><br><span class="line"><span class="comment">//distributor core调用，用于回收worker core处理完毕的报文</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_distributor_returned_pkts</span><span class="params">(<span class="keyword">struct</span> rte_distributor *d,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> rte_mbuf **mbufs, <span class="type">unsigned</span> <span class="type">int</span> max_mbufs)</span>;</span><br><span class="line"><span class="comment">//worker core调用，接收报文并返回处理完毕的报文</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_distributor_get_pkt</span><span class="params">(<span class="keyword">struct</span> rte_distributor *d,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> worker_id, <span class="keyword">struct</span> rte_mbuf **pkts,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> rte_mbuf **oldpkt, <span class="type">unsigned</span> <span class="type">int</span> retcount)</span>;</span><br><span class="line"><span class="comment">//worker core调用，返回处理完毕的报文并告知distributor该worker不再接收报文</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_distributor_return_pkt</span><span class="params">(<span class="keyword">struct</span> rte_distributor *d,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> worker_id, <span class="keyword">struct</span> rte_mbuf **oldpkt, <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="Reorder"><a href="#Reorder" class="headerlink" title="Reorder"></a>Reorder</h1><p>实现对一组报文的重排序，比如使用[Packet Distributor](#Packet Distributor)时，distributor core将顺序的报文分发给worker，但distributor并不能保证所回收到的报文还是顺序的。在这种情况下，使用reorder库，在distributor core分发报文之前，为每一个报文分配序列号，在回收时，将回收到的报文交给reorder处理，reorder会按照报文的序列号进行排序，这样distributor再从reorder取到的报文就是顺序的报文。</p>
<blockquote>
<p>该库仅保证插入到reorder中的报文按序取出，并不保证取出报文的序列号连续</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reorder创建</span></span><br><span class="line"><span class="keyword">struct</span> rte_reorder_buffer *</span><br><span class="line"><span class="title function_">rte_reorder_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> socket_id, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//报文序列号设置</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">rte_reorder_seqn_t</span> *</span><br><span class="line"><span class="title function_">rte_reorder_seqn</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *mbuf)</span></span><br><span class="line"><span class="comment">//reorder报文插入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_reorder_insert</span><span class="params">(<span class="keyword">struct</span> rte_reorder_buffer *b, <span class="keyword">struct</span> rte_mbuf *mbuf)</span>;</span><br><span class="line"><span class="comment">//从reorder中取出重排序后的报文</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">rte_reorder_drain</span><span class="params">(<span class="keyword">struct</span> rte_reorder_buffer *b, <span class="keyword">struct</span> rte_mbuf **mbufs,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> max_mbufs)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="IP-Frag"><a href="#IP-Frag" class="headerlink" title="IP Frag"></a>IP Frag</h1><p>提供ipv4/v6的ip分片/重组功能</p>
<h2 id="Packet-fragmentation"><a href="#Packet-fragmentation" class="headerlink" title="Packet fragmentation"></a>Packet fragmentation</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入报文的指针应指向ip头</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">rte_ipv4_fragment_packet</span><span class="params">(<span class="keyword">struct</span> rte_mbuf *pkt_in,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> rte_mbuf **pkts_out,</span></span><br><span class="line"><span class="params">			<span class="type">uint16_t</span> nb_pkts_out, <span class="type">uint16_t</span> mtu_size,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> rte_mempool *pool_direct,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> rte_mempool *pool_indirect)</span>;</span><br></pre></td></tr></table></figure>

<p>将pkt_in根据所输入的mtu_size（ip报文最大长度）进行分片，分片报文存储在pkts_out中，对于所创建的分片报文，由以下两类mbuf组成：</p>
<ul>
<li>Direct mbuf：存储着该分片所对应的ip头。</li>
<li>Indirect mbuf：存储着该分片所对应的数据段，由于是间接的mbuf，其存储的数据段是通过指针指向pkt_in对应数据段位置而实现的，免去了数据段的拷贝。</li>
</ul>
<h2 id="Packet-reassembly"><a href="#Packet-reassembly" class="headerlink" title="Packet reassembly"></a>Packet reassembly</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ip分片表的每个entry能够存储的分片数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_LIBRTE_IP_FRAG_MAX 8</span></span><br><span class="line"><span class="comment">//ip分片表创建，用于存储需要重组的分片报文</span></span><br><span class="line"><span class="keyword">struct</span> rte_ip_frag_tbl * <span class="title function_">rte_ip_frag_table_create</span><span class="params">(<span class="type">uint32_t</span> bucket_num,	<span class="comment">//hash桶的数目</span></span></span><br><span class="line"><span class="params">		<span class="type">uint32_t</span> bucket_entries,	<span class="comment">//每个hash桶可容纳的entry的数目（用于解决hash冲突）</span></span></span><br><span class="line"><span class="params">        <span class="type">uint32_t</span> max_entries,		<span class="comment">//hash表可容纳的最大entry数</span></span></span><br><span class="line"><span class="params">		<span class="type">uint64_t</span> max_cycles,		<span class="comment">//ip分片超时时间设置</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> socket_id)</span>;</span><br><span class="line"><span class="comment">//ip分片重组，非线程安全函数</span></span><br><span class="line"><span class="keyword">struct</span> rte_mbuf * <span class="title function_">rte_ipv4_frag_reassemble_packet</span><span class="params">(<span class="keyword">struct</span> rte_ip_frag_tbl *tbl,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> rte_ip_frag_death_row *dr,	<span class="comment">//存放失效的ip分片</span></span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> rte_mbuf *mb, <span class="type">uint64_t</span> tms, <span class="keyword">struct</span> rte_ipv4_hdr *ip_hdr)</span>;</span><br><span class="line"><span class="comment">//释放失效的ip分片</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_ip_frag_free_death_row</span><span class="params">(<span class="keyword">struct</span> rte_ip_frag_death_row *dr,</span></span><br><span class="line"><span class="params">		<span class="type">uint32_t</span> prefetch)</span>;</span><br><span class="line"><span class="comment">//收集ip分片表中失效的ip分片</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_ip_frag_table_del_expired_entries</span><span class="params">(<span class="keyword">struct</span> rte_ip_frag_tbl *tbl,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> rte_ip_frag_death_row *dr, <span class="type">uint64_t</span> tms)</span>;</span><br></pre></td></tr></table></figure>



<p>ip分片表内部使用hash表来进行管理：</p>
<ul>
<li>key：&lt;源ip, 目的ip, Packet ID&gt;</li>
<li>value：<code>struct ip_frag_pkt</code>，存储着当前报文的所有分片</li>
</ul>
<p>为了解决hash冲突，ip分片表使用两个hash函数来生成bucket索引，同时每个bucket包含多个entry。</p>
<p>当插入的报文的最后一个分片时，ip分片表会将其重组，修改第一个分片的ip头，将其他分片的起始指针指到分片的数据部分，并用链表连接起来返回给用户。</p>
<h1 id="Membership"><a href="#Membership" class="headerlink" title="Membership"></a>Membership</h1><p>成员库，向应用程序提供了以下功能：</p>
<ul>
<li>向给定集合插入/删除一个成员（key）</li>
<li>查询成员是否属于该集合</li>
</ul>
<p>该库采用集合摘要的方式实现，具有内存占用低，查找迅速等特点，这对于大数据核流式应用来说非常有用。但由于集合摘要采用的是概率数据结构，因此具有假阳率，即查询成员是否属于该集合时，若返回真，则实际可能为假。</p>
<h2 id="Membership使用"><a href="#Membership使用" class="headerlink" title="Membership使用"></a>Membership使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_member_parameters</span> {</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;			<span class="comment">/**&lt; Name of the hash. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User to specify the type of the setsummary from one of</span></span><br><span class="line"><span class="comment">	 * rte_member_setsum_type.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * HT based setsummary is implemented like a hash table. User should use</span></span><br><span class="line"><span class="comment">	 * this type when there are many sets.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * vBF setsummary is a vector of bloom filters. It is used when number</span></span><br><span class="line"><span class="comment">	 * of sets is not big (less than 32 for current implementation).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_member_setsum_type</span> <span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * is_cache is only used for HT based setsummary.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If it is HT based setsummary, user to specify the subtype or mode</span></span><br><span class="line"><span class="comment">	 * of the setsummary. It could be cache, or non-cache mode.</span></span><br><span class="line"><span class="comment">	 * Set is_cache to be 1 if to use as cache mode.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For cache mode, keys can be evicted out of the HT setsummary. Keys</span></span><br><span class="line"><span class="comment">	 * with the same signature and map to the same bucket</span></span><br><span class="line"><span class="comment">	 * will overwrite each other in the setsummary table.</span></span><br><span class="line"><span class="comment">	 * This mode is useful for the case that the set-summary only</span></span><br><span class="line"><span class="comment">	 * needs to keep record of the recently inserted keys. Both</span></span><br><span class="line"><span class="comment">	 * false-negative and false-positive could happen.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For non-cache mode, keys cannot be evicted out of the cache. So for</span></span><br><span class="line"><span class="comment">	 * this mode the setsummary will become full eventually. Keys with the</span></span><br><span class="line"><span class="comment">	 * same signature but map to the same bucket will still occupy multiple</span></span><br><span class="line"><span class="comment">	 * entries. This mode does not give false-negative result.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint8_t</span> is_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * For HT setsummary, num_keys equals to the number of entries of the</span></span><br><span class="line"><span class="comment">	 * table. When the number of keys inserted in the HT setsummary</span></span><br><span class="line"><span class="comment">	 * approaches this number, eviction could happen. For cache mode,</span></span><br><span class="line"><span class="comment">	 * keys could be evicted out of the table. For non-cache mode, keys will</span></span><br><span class="line"><span class="comment">	 * be evicted to other buckets like cuckoo hash. The table will also</span></span><br><span class="line"><span class="comment">	 * likely to become full before the number of inserted keys equal to the</span></span><br><span class="line"><span class="comment">	 * total number of entries.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For vBF, num_keys equal to the expected number of keys that will</span></span><br><span class="line"><span class="comment">	 * be inserted into the vBF. The implementation assumes the keys are</span></span><br><span class="line"><span class="comment">	 * evenly distributed to each BF in vBF. This is used to calculate the</span></span><br><span class="line"><span class="comment">	 * number of bits we need for each BF. User does not specify the size of</span></span><br><span class="line"><span class="comment">	 * each BF directly because the optimal size depends on the num_keys</span></span><br><span class="line"><span class="comment">	 * and false positive rate.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> num_keys;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The length of key is used for hash calculation. Since key is not</span></span><br><span class="line"><span class="comment">	 * stored in set-summary, large key does not require more memory space.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> key_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * num_set is only used for vBF, but not used for HT setsummary.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * num_set is equal to the number of BFs in vBF. For current</span></span><br><span class="line"><span class="comment">	 * implementation, it only supports 1,2,4,8,16,32 BFs in one vBF set</span></span><br><span class="line"><span class="comment">	 * summary. If other number of sets are needed, for example 5, the user</span></span><br><span class="line"><span class="comment">	 * should allocate the minimum available value that larger than 5,</span></span><br><span class="line"><span class="comment">	 * which is 8.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> num_set;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * false_positive_rate is only used for vBF, but not used for HT</span></span><br><span class="line"><span class="comment">	 * setsummary.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For vBF, false_positive_rate is the user-defined false positive rate</span></span><br><span class="line"><span class="comment">	 * given expected number of inserted keys (num_keys). It is used to</span></span><br><span class="line"><span class="comment">	 * calculate the total number of bits for each BF, and the number of</span></span><br><span class="line"><span class="comment">	 * hash values used during lookup and insertion. For details please</span></span><br><span class="line"><span class="comment">	 * refer to vBF implementation and membership library documentation.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For HT, This parameter is not directly set by users.</span></span><br><span class="line"><span class="comment">	 * HT setsummary's false positive rate is in the order of:</span></span><br><span class="line"><span class="comment">	 * false_pos = (1/bucket_count)*(1/2^16), since we use 16-bit signature.</span></span><br><span class="line"><span class="comment">	 * This is because two keys needs to map to same bucket and same</span></span><br><span class="line"><span class="comment">	 * signature to have a collision (false positive). bucket_count is equal</span></span><br><span class="line"><span class="comment">	 * to number of entries (num_keys) divided by entry count per bucket</span></span><br><span class="line"><span class="comment">	 * (RTE_MEMBER_BUCKET_ENTRIES). Thus, the false_positive_rate is not</span></span><br><span class="line"><span class="comment">	 * directly set by users for HT mode.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">float</span> false_positive_rate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * We use two seeds to calculate two independent hashes for each key.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For HT type, one hash is used as signature, and the other is used</span></span><br><span class="line"><span class="comment">	 * for bucket location.</span></span><br><span class="line"><span class="comment">	 * For vBF type, these two hashes and their combinations are used as</span></span><br><span class="line"><span class="comment">	 * hash locations to index the bit array.</span></span><br><span class="line"><span class="comment">	 * For Sketch type, these seeds are not used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> prim_hash_seed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The secondary seed should be a different value from the primary seed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> sec_hash_seed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * For count(min) sketch data structure, error rate defines the accuracy</span></span><br><span class="line"><span class="comment">	 * required by the user. Higher accuracy leads to more memory usage, but</span></span><br><span class="line"><span class="comment">	 * the flow size is estimated more accurately.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">float</span> error_rate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Sampling rate means the internal sample rate of the rows of the count</span></span><br><span class="line"><span class="comment">	 * min sketches. Lower sampling rate can reduce CPU overhead, but the</span></span><br><span class="line"><span class="comment">	 * data structure will require more time to converge statistically.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">float</span> sample_rate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * How many top heavy hitter to be reported. The library will internally</span></span><br><span class="line"><span class="comment">	 * keep the keys of heavy hitters for final report.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> top_k;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Extra flags that may passed in by user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> extra_flag;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> socket_id;			<span class="comment">/**&lt; NUMA Socket ID for memory. */</span></span><br><span class="line">} __rte_cache_aligned;</span><br><span class="line"><span class="comment">//创建一个member实例</span></span><br><span class="line"><span class="keyword">struct</span> rte_member_setsum *</span><br><span class="line"><span class="title function_">rte_member_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_member_parameters *params)</span>;</span><br><span class="line"><span class="comment">//向指定集合中添加成员</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_member_add</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_member_setsum *setsum, <span class="type">const</span> <span class="type">void</span> *key,</span></span><br><span class="line"><span class="params">			<span class="type">member_set_t</span> set_id)</span>;</span><br><span class="line"><span class="comment">//查询给定成员所属集合，若查询成功则返回给set_id</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_member_lookup</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_member_setsum *setsum, <span class="type">const</span> <span class="type">void</span> *key,</span></span><br><span class="line"><span class="params">			<span class="type">member_set_t</span> *set_id)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="Membership原理"><a href="#Membership原理" class="headerlink" title="Membership原理"></a>Membership原理</h2><p>目前dpdk对于该库有三种实现，不同实现方式适用于不同的使用场景，用户可根据自身需要选择不同的内部实现方式。</p>
<h3 id="HTSS-Hash-table-based-set-summary"><a href="#HTSS-Hash-table-based-set-summary" class="headerlink" title="HTSS(Hash-table based set-summary)"></a>HTSS(Hash-table based set-summary)</h3><p>采用Cuckoo filter实现，与<a href="#Hash">Cuckoo hash</a>实现方式类似，只不过不存储key值，这里不再赘述。该实现方式适用于集合中成员数较多的情况。</p>
<p>因为hash表中存储的是key的签名，所以存在==假阳率==。当发生hash冲突时（即primary和secondary的bucket都满时），根据HSTT所采用的解决冲突的方式，分为两种模式：</p>
<ul>
<li>cache mode：直接随机覆盖掉之前所插入的一个key。使得插入操作的代价比non-cache mode下小，但这会导致该模式下存在==假阴率==，即查询成员是否属于该集合时，若返回假，则实际可能为真。因此该模式通常用于缓存查找，查找缓存失败时再查找主表。</li>
<li>non-cache mode：采用Cuckoo hash的冲突解决方法，踢出一个key，并递归地插入所踢出的key。</li>
</ul>
<h3 id="BF-Bloom-Filter"><a href="#BF-Bloom-Filter" class="headerlink" title="BF(Bloom Filter)"></a>BF(Bloom Filter)</h3><p>布隆过滤器，采用位图方式实现。当一个成员加入到集合中时，通过k个散列函数将该元素映射到位图中的k个位，并置1。查找时，若成员所对应的k个位在该集合中都为1，则该成员属于该集合中，该实现方式适用于集合中成员数较少的情况。</p>
<p>由于不同成员可能散列到相同位置，因此布隆过滤器存在==假阳率==，假阳率的概率可以通过入参配置。</p>
<h4 id="假阳率的表达式"><a href="#假阳率的表达式" class="headerlink" title="假阳率的表达式"></a>假阳率的表达式</h4><p>首先定义所用到的一些变量：</p>
<ul>
<li>m：该集合所使用的bitmap的比特数</li>
<li>k：向该集合中插入一个成员需要进行的哈希轮数</li>
<li>n：该集合中成员的个数（一个大约的估计值，用户配置）</li>
<li>ρ：插入n个元素的情况下的假阳率（用户配置）</li>
</ul>
<p>BF中任何一位bit在第1个成员第1个hash执行完毕后为0的概率：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.577ex;" xmlns="http://www.w3.org/2000/svg" width="6.879ex" height="4.613ex" role="img" focusable="false" viewBox="0 -1342 3040.4 2039"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(1722.4,0)"><g data-mml-node="mn" transform="translate(409,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-686)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="1078" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container><br>BF中任何一位bit在第1个成员第k个hash执行完毕后为0的概率：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.577ex;" xmlns="http://www.w3.org/2000/svg" width="9.66ex" height="4.613ex" role="img" focusable="false" viewBox="0 -1342 4269.8 2039"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1111.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(2111.4,0)"><g data-mml-node="mn" transform="translate(409,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-686)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="1078" height="60" x="120" y="220"></rect></g><g data-mml-node="msup" transform="translate(3429.4,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(422,413) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></svg></mjx-container><br>BF中任何一位bit在所有n个成员都添加完毕后为1的概率：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.577ex;" xmlns="http://www.w3.org/2000/svg" width="14.517ex" height="4.613ex" role="img" focusable="false" viewBox="0 -1342 6416.6 2039"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(1722.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(2111.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2833.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(3833.9,0)"><g data-mml-node="mn" transform="translate(409,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-686)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="1078" height="60" x="120" y="220"></rect></g><g data-mml-node="msup" transform="translate(5151.9,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" transform="translate(422,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></g></svg></mjx-container><br>一个不存在的成员被k个hash函数映射后k个bit都为1的概率：<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 44.54ex;"><svg style="vertical-align: -1.741ex; min-width: 44.54ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="4.613ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -1269.5)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2078,0) translate(-2078,0)"><g transform="translate(0 1269.5) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="7765.3 -1269.5 1 2039"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,-72.5)"><g data-mml-node="mtd"><g data-mml-node="mi"><path data-c="1D70C" d="M58 -216Q25 -216 23 -186Q23 -176 73 26T127 234Q143 289 182 341Q252 427 341 441Q343 441 349 441T359 442Q432 442 471 394T510 276Q510 219 486 165T425 74T345 13T266 -10H255H248Q197 -10 165 35L160 41L133 -71Q108 -168 104 -181T92 -202Q76 -216 58 -216ZM424 322Q424 359 407 382T357 405Q322 405 287 376T231 300Q217 269 193 170L176 102Q193 26 260 26Q298 26 334 62Q367 92 389 158T418 266T424 322Z"></path></g><g data-mml-node="mo" transform="translate(794.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(1850.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(2128.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2850.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(3851,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4240,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4962.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(5962.4,0)"><g data-mml-node="mn" transform="translate(409,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-686)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="1078" height="60" x="120" y="220"></rect></g><g data-mml-node="msup" transform="translate(7280.4,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" transform="translate(422,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><g data-mml-node="msup" transform="translate(8545.1,0)"><g data-mml-node="mo"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mi" transform="translate(311,413) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(9552.3,0)"><path data-c="2248" d="M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"></path></g><g data-mml-node="mo" transform="translate(10608.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(10997.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(11719.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(12719.5,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(778,0)"><g data-mml-node="mrow" transform="translate(220,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mi" transform="translate(521,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mi" transform="translate(305.9,-345) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="992.7" height="60" x="120" y="220"></rect></g></g></g><g data-mml-node="msup" transform="translate(14690.3,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(422,413) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="1278 -1269.5 1 2039"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:1" transform="translate(0,677.5)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(389,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(889,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container></p>
<h4 id="BF所使用的bitmap位数m的确定"><a href="#BF所使用的bitmap位数m的确定" class="headerlink" title="BF所使用的bitmap位数m的确定"></a>BF所使用的bitmap位数m的确定</h4><p>在这里m和k都是未知量，为了求得假阳率的最小值，我们将ρ先看做为k的函数，对其进行求导，确定当k为何值时ρ的值最小。</p>
<p>这里采用对数求导法<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 36.612ex;"><svg style="vertical-align: -0.892ex; min-width: 36.612ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="2.915ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -894.3)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2078,0) translate(-2078,0)"><g transform="translate(0 894.3) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="6013.3 -894.3 1 1288.6"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,-144.3)"><g data-mml-node="mtd"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(1460,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2126.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3182.6,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(4016.6,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(4183.2,0)"><path data-c="1D70C" d="M58 -216Q25 -216 23 -186Q23 -176 73 26T127 234Q143 289 182 341Q252 427 341 441Q343 441 349 441T359 442Q432 442 471 394T510 276Q510 219 486 165T425 74T345 13T266 -10H255H248Q197 -10 165 35L160 41L133 -71Q108 -168 104 -181T92 -202Q76 -216 58 -216ZM424 322Q424 359 407 382T357 405Q322 405 287 376T231 300Q217 269 193 170L176 102Q193 26 260 26Q298 26 334 62Q367 92 389 158T418 266T424 322Z"></path></g><g data-mml-node="mo" transform="translate(4978,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(6033.8,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mi" transform="translate(6721.4,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(7555.4,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(7555.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(7944.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8666.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(9666.9,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(778,0)"><g data-mml-node="mrow" transform="translate(220,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mi" transform="translate(521,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mi" transform="translate(305.9,-345) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="992.7" height="60" x="120" y="220"></rect></g></g></g><g data-mml-node="mo" transform="translate(11637.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="1278 -894.3 1 1288.6"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:2" transform="translate(0,605.7)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(389,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(889,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container><br>为了简化式子(2)，令<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.446ex" height="2.422ex" role="img" focusable="false" viewBox="0 -988.6 3733.3 1070.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(706.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(1762.6,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(778,0)"><g data-mml-node="mrow" transform="translate(220,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mi" transform="translate(521,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mi" transform="translate(305.9,-345) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="992.7" height="60" x="120" y="220"></rect></g></g></g></g></g></svg></mjx-container>，对式子(2)两边求导，得<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.859ex;" xmlns="http://www.w3.org/2000/svg" width="36.38ex" height="5.397ex" role="img" focusable="false" viewBox="0 -1563.7 16079.9 2385.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(636,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g></g><g data-mml-node="mo" transform="translate(880.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1269.5,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(1790.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2457.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3513,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(4347,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(4347,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4736,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(5458.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(6458.5,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><g data-mml-node="mo" transform="translate(7889,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(8500.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(9500.4,0)"><g data-mml-node="mrow" transform="translate(275.2,710)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1223,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2653.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-739.7)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(1722.4,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g><rect width="3353" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(13093.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(13482.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(14260.4,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><g data-mml-node="mo" transform="translate(15690.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br>令导数为0，得<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 32.325ex;"><svg style="vertical-align: -2.133ex; min-width: 32.325ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="5.397ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -1442.7)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2078,0) translate(-2078,0)"><g transform="translate(0 1442.7) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="5065.8 -1442.7 1 2385.5"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,-121)"><g data-mml-node="mtd"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1223,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1945.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(2945.4,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><g data-mml-node="mo" transform="translate(4376,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="msup" transform="translate(1887.2,-739.7)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><rect width="4965" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(5482.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(6538.5,0)"><g data-mml-node="mrow" transform="translate(275.2,710)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1223,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2653.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-739.7)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(1722.4,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g><rect width="3353" height="60" x="120" y="220"></rect></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="1278 -1442.7 1 2385.5"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:3" transform="translate(0,629)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(389,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(889,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container><br>为方便起见，设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.548ex" height="2.117ex" role="img" focusable="false" viewBox="0 -853.7 3336.1 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(1905.6,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></g></svg></mjx-container>，令<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 26.416ex;"><svg style="vertical-align: -1.874ex; min-width: 26.416ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="4.88ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -1328.5)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2078,0) translate(-2078,0)"><g transform="translate(0 1328.5) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="3760 -1328.5 1 2157"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,-131.5)"><g data-mml-node="mtd"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(879,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1451,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2117.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(3173.6,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1223,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1945.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2945.4,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(3517.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mi" transform="translate(1887.2,-686)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><rect width="4106.4" height="60" x="120" y="220"></rect></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="1278 -1328.5 1 2157"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:4" transform="translate(0,618.5)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(389,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(889,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container><br>要想使式子(3)成立，就是求<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="15.24ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6736 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(879,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1451,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2117.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3173.6,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3663.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4052.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4774.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(5775,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(6347,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br>由于式子(4)单调递减，因此当且仅当<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="6.107ex" height="2.737ex" role="img" focusable="false" viewBox="0 -864.9 2699.1 1209.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(1905.6,0)"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="553.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>时，式子(3)成立，即<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 43.981ex;"><svg style="vertical-align: -1.773ex; min-width: 43.981ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="4.676ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -1283.5)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2078,0) translate(-2078,0)"><g transform="translate(0 1283.5) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="7641.8 -1283.5 1 2067"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,-86.5)"><g data-mml-node="mtd"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="TeXAtom" transform="translate(462,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1708.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(2764.1,0)"><g data-mml-node="mn" transform="translate(220,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mn" transform="translate(220,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="700" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3981.9,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g><g data-mml-node="mi" transform="translate(5259.6,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(6058.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(7114.2,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(1000.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mrow" transform="translate(255.5,-686)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(1000.7,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g><rect width="1700.7" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(9332.6,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g><g data-mml-node="mi" transform="translate(10610.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(11409.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(12465,0)"><g data-mml-node="mi" transform="translate(220,676)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(359,-686)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><rect width="1078" height="60" x="120" y="220"></rect></g><g data-mml-node="mi" transform="translate(13783,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(14617,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(14783.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="1278 -1283.5 1 2067"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:5" transform="translate(0,663.5)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(389,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(889,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container><br>因此当且仅当<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="9.991ex" height="2.397ex" role="img" focusable="false" viewBox="0 -706.5 4416.1 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(798.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(1854.6,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(318.3,-345) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><rect width="820.8" height="60" x="120" y="220"></rect></g><g data-mml-node="mi" transform="translate(2915.4,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(3749.4,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(3916.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>时，假阳率取得极值，通过对k带数可知，该极值为极小值。</p>
<p>到这里，就可以计算BF所使用的bitmap位数了。将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="9.991ex" height="2.397ex" role="img" focusable="false" viewBox="0 -706.5 4416.1 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(798.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(1854.6,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(318.3,-345) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><rect width="820.8" height="60" x="120" y="220"></rect></g><g data-mml-node="mi" transform="translate(2915.4,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(3749.4,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(3916.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>带入式子(1)，得<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.752ex;" xmlns="http://www.w3.org/2000/svg" width="29.715ex" height="5.851ex" role="img" focusable="false" viewBox="0 -1370 13134.2 2586.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70C" d="M58 -216Q25 -216 23 -186Q23 -176 73 26T127 234Q143 289 182 341Q252 427 341 441Q343 441 349 441T359 442Q432 442 471 394T510 276Q510 219 486 165T425 74T345 13T266 -10H255H248Q197 -10 165 35L160 41L133 -71Q108 -168 104 -181T92 -202Q76 -216 58 -216ZM424 322Q424 359 407 382T357 405Q322 405 287 376T231 300Q217 269 193 170L176 102Q193 26 260 26Q298 26 334 62Q367 92 389 158T418 266T424 322Z"></path></g><g data-mml-node="mo" transform="translate(794.8,0)"><path data-c="2248" d="M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"></path></g><g data-mml-node="mo" transform="translate(1850.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(2239.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mfrac" transform="translate(2628.6,0)"><g data-mml-node="mn" transform="translate(220,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mn" transform="translate(220,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="700" height="60" x="120" y="220"></rect></g><g data-mml-node="msup" transform="translate(3568.6,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" transform="translate(422,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(1000.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="msup" transform="translate(5101.7,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mfrac" transform="translate(422,413) scale(0.707)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(318.3,-345) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><rect width="820.8" height="60" x="120" y="220"></rect></g></g><g data-mml-node="mo" transform="translate(6601.6,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g><g data-mml-node="mi" transform="translate(7879.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(9035.1,0)"><path data-c="2248" d="M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"></path></g><g data-mml-node="mfrac" transform="translate(10090.9,0)"><g data-mml-node="mrow" transform="translate(379.5,676)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(766.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(1600.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(1767.3,0)"><path data-c="1D70C" d="M58 -216Q25 -216 23 -186Q23 -176 73 26T127 234Q143 289 182 341Q252 427 341 441Q343 441 349 441T359 442Q432 442 471 394T510 276Q510 219 486 165T425 74T345 13T266 -10H255H248Q197 -10 165 35L160 41L133 -71Q108 -168 104 -181T92 -202Q76 -216 58 -216ZM424 322Q424 359 407 382T357 405Q322 405 287 376T231 300Q217 269 193 170L176 102Q193 26 260 26Q298 26 334 62Q367 92 389 158T418 266T424 322Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-824.9)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1000.7,0)"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(624.5,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="msup" transform="translate(220,-391.4) scale(0.707)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(1000.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><rect width="1362.6" height="60" x="120" y="220"></rect></g></g></g><rect width="2803.2" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<h4 id="BF所使用的hash数k的确定"><a href="#BF所使用的hash数k的确定" class="headerlink" title="BF所使用的hash数k的确定"></a>BF所使用的hash数k的确定</h4><p>此时m已知，由式子(5)即可算出BF所使用的hash数k。</p>
<p>为了查找时的性能考虑m会取值为2的整数次方，此时所得到的假阳率ρ一定是保守的，即小于用户所指定的假阳率。因此为了进一步减少插入/查找一个成员所需进行的hash次数k，依次递减k的值，带入式子(1)中，最后确定一个使得假阳率低于用户所给定的假阳率的最小k值。</p>
<h4 id="多集合的支持"><a href="#多集合的支持" class="headerlink" title="多集合的支持"></a>多集合的支持</h4><p>传统的BF仅支持一个集合，而在dpdk中进行了向量化，使其支持多个集合。</p>
<p><a href="/images/vbf.svg" title="vbf" class="gallery-item" style="box-shadow: none;"> <img src="/images/vbf.svg" alt="vbf"></a></p>
<h3 id="Sketch"><a href="#Sketch" class="headerlink" title="Sketch"></a>Sketch</h3><p>Count-Min Sketch：使用一个二维的（d*w）计数器阵列来统计输入key，二维阵列的每一行都对应一个hash函数，总共有d个hash函数，其值域都在w内。每添加一个key，都需要计算d次hash，并更新对应位置上的计数器。key的计数估计值是由d个hash函数所映射到的阵列位置的最小记数值而确定。</p>
<p>![sketch](/images/count-min sketch.png)</p>
<p>该方法仅支持一个集合，该集合为一个大小为topk的最小堆，堆中存储记数估计值最大的前topk（用户配置）个key。查询时，若查询的key在该堆中，则属于该集合，否则不属于该集合。</p>
<p>为了提高性能，dpdk采用了NitroSketch来实现。相比于Count-Min Sketch，NitroSketch做了以下优化：</p>
<h4 id="优化1-1"><a href="#优化1-1" class="headerlink" title="优化1"></a>优化1</h4><p>对计数器进行采样，通过设置采样率p，插入key时对每个计数器以p的概率进行更新，其更新值为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="3.37ex" height="2.326ex" role="img" focusable="false" viewBox="0 -833.9 1489.7 1027.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="TeXAtom" transform="translate(536,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g></svg></mjx-container></p>
<p><a href="/images/sample-counter.png" title="sample-counter" class="gallery-item" style="box-shadow: none;"> <img src="/images/sample-counter.png" alt="sample-counter"></a></p>
<p>此时对于key的记数估计值的获取不再使用最小记数值，而是使用中位数技术值，以提高准确性。</p>
<h4 id="优化2-1"><a href="#优化2-1" class="headerlink" title="优化2"></a>优化2</h4><p>插入key时，每个计数器是否更新，一般来说是通过抛硬币（参数为p的0-1分布）的方式决定。这样一来每插入一个key就需要进行d次抛硬币操作，更加高效的实现方式是通过几何样本（服从参数为p的几何分布的变量）来获取下一个需要更新的计数器的位置，避免了每次抛硬币带来的性能的损耗。</p>
<p><a href="/images/geometric-sampling.png" title="geometric" class="gallery-item" style="box-shadow: none;"> <img src="/images/geometric-sampling.png" alt="geometric"></a></p>
<p>利用<strong>逆变换采样</strong>构造几何样本：</p>
<blockquote>
<p>假设X为一个连续随机变量，其累积分布函数为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="3.006ex" height="1.878ex" role="img" focusable="false" viewBox="0 -680 1328.5 830"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(676,-150) scale(0.707)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g></g></g></svg></mjx-container>。此时，随机变量<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.437ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5055 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44C" d="M66 637Q54 637 49 637T39 638T32 641T30 647T33 664T42 682Q44 683 56 683Q104 680 165 680Q288 680 306 683H316Q322 677 322 674T320 656Q316 643 310 637H298Q242 637 242 624Q242 619 292 477T343 333L346 336Q350 340 358 349T379 373T411 410T454 461Q546 568 561 587T577 618Q577 634 545 637Q528 637 528 647Q528 649 530 661Q533 676 535 679T549 683Q551 683 578 682T657 680Q684 680 713 681T746 682Q763 682 763 673Q763 669 760 657T755 643Q753 637 734 637Q662 632 617 587Q608 578 477 424L348 273L322 169Q295 62 295 57Q295 46 363 46Q379 46 384 45T390 35Q390 33 388 23Q384 6 382 4T366 1Q361 1 324 1T232 2Q170 2 138 2T102 1Q84 1 84 9Q84 14 87 24Q88 27 89 30T90 35T91 39T93 42T96 44T101 45T107 45T116 46T129 46Q168 47 180 50T198 63Q201 68 227 171L252 274L129 623Q128 624 127 625T125 627T122 629T118 631T113 633T105 634T96 635T83 636T66 637Z"></path></g><g data-mml-node="mo" transform="translate(1040.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(2096.6,0)"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(676,-150) scale(0.707)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g><g data-mml-node="mo" transform="translate(3425,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3814,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(4666,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>服从区间[0,1]上的均匀分布。逆变换采样即是将该过程反过来进行：首先对于随机变量 Y，我们从0至1中随机均匀抽取一个数u。之后，由于随机变量<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.7ex;" xmlns="http://www.w3.org/2000/svg" width="7.538ex" height="2.697ex" role="img" focusable="false" viewBox="0 -882.5 3332 1191.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="TeXAtom" transform="translate(837.3,411.6) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mi" transform="translate(676,-309.4) scale(0.707)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g><g data-mml-node="mo" transform="translate(1791,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2180,0)"><path data-c="1D44C" d="M66 637Q54 637 49 637T39 638T32 641T30 647T33 664T42 682Q44 683 56 683Q104 680 165 680Q288 680 306 683H316Q322 677 322 674T320 656Q316 643 310 637H298Q242 637 242 624Q242 619 292 477T343 333L346 336Q350 340 358 349T379 373T411 410T454 461Q546 568 561 587T577 618Q577 634 545 637Q528 637 528 647Q528 649 530 661Q533 676 535 679T549 683Q551 683 578 682T657 680Q684 680 713 681T746 682Q763 682 763 673Q763 669 760 657T755 643Q753 637 734 637Q662 632 617 587Q608 578 477 424L348 273L322 169Q295 62 295 57Q295 46 363 46Q379 46 384 45T390 35Q390 33 388 23Q384 6 382 4T366 1Q361 1 324 1T232 2Q170 2 138 2T102 1Q84 1 84 9Q84 14 87 24Q88 27 89 30T90 35T91 39T93 42T96 44T101 45T107 45T116 46T129 46Q168 47 180 50T198 63Q201 68 227 171L252 274L129 623Q128 624 127 625T125 627T122 629T118 631T113 633T105 634T96 635T83 636T66 637Z"></path></g><g data-mml-node="mo" transform="translate(2943,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>与X有着相同的分布，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.7ex;" xmlns="http://www.w3.org/2000/svg" width="11.418ex" height="2.697ex" role="img" focusable="false" viewBox="0 -882.5 5046.5 1191.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msubsup" transform="translate(1905.6,0)"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="TeXAtom" transform="translate(837.3,411.6) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mi" transform="translate(676,-309.4) scale(0.707)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g><g data-mml-node="mo" transform="translate(3696.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4085.5,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4657.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>即可看作是从分布<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="3.006ex" height="1.878ex" role="img" focusable="false" viewBox="0 -680 1328.5 830"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(676,-150) scale(0.707)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g></g></g></svg></mjx-container>中生成的随机样本。</p>
</blockquote>
<p>随机变量X~G(p)的累积分布函数可表示为：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="33.275ex" height="2.61ex" role="img" focusable="false" viewBox="0 -903.7 14707.4 1153.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(676,-150) scale(0.707)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g><g data-mml-node="mo" transform="translate(1328.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1717.5,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(2238.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2905.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3961,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(4712,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5101,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(6230.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(7286.6,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(7807.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(8474.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9530.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(10252.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(11252.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(11641.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(12363.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(13364,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="msup" transform="translate(13867,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(422,413) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></svg></mjx-container><br>采用逆变换采样得到：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="37.898ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 16751 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(1905.6,0)"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(676,-150) scale(0.707)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g><g data-mml-node="mo" transform="translate(3234,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3623,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(4195,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(4861.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(5917.6,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(6668.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(7057.6,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(8187.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(9243.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(9815.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(10481.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(11537.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(12259.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(13260.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(13649.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(14371.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(15371.6,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="msup" transform="translate(15874.6,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(422,413) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></g></svg></mjx-container><br>得出随机变量X的几何样本x为：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.172ex;" xmlns="http://www.w3.org/2000/svg" width="14.145ex" height="5.475ex" role="img" focusable="false" viewBox="0 -1460 6252 2420"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(1905.6,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1223,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1945.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2945.4,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3517.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mrow" transform="translate(254.5,-710)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1223,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1945.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2945.4,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(3448.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><rect width="4106.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<h4 id="优化3-1"><a href="#优化3-1" class="headerlink" title="优化3"></a>优化3</h4><p>在开始阶段时不使用NitroSketch方法，而是使用Count-Min Sketch方法，在接收一定数量的key（统计记数收敛）后，再采取NitroSketch方法。这样即保证了统计的准确性，也提升了性能。</p>
<h4 id="额外API"><a href="#额外API" class="headerlink" title="额外API"></a>额外API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取特定key的记数估计值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_member_query_count</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_member_setsum *setsum,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="type">void</span> *key, <span class="type">uint64_t</span> *count)</span>;</span><br><span class="line"><span class="comment">//获取top-k的key和记数估计值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_member_report_heavyhitter</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rte_member_setsum *setsum,</span></span><br><span class="line"><span class="params">			      <span class="type">void</span> **keys, <span class="type">uint64_t</span> *counts)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><p>利用有向图去构建dpdk的报文处理框架，该框架支持两种运行模型</p>
<ul>
<li><p>RTC(Run-To-Completion)：默认的图运行模型，仅需要一个worker线程进行图遍历。如果存在n个worker线程，需创建n个图。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Graph: node-0 -&gt; node-1 -&gt; node-2 @Core0.</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">'                  Core #0                  '</span><br><span class="line">'                                           '</span><br><span class="line">' +--------+     +---------+     +--------+ '</span><br><span class="line">' | Node-0 | --&gt; | Node-1  | --&gt; | Node-2 | '</span><br><span class="line">' +--------+     +---------+     +--------+ '</span><br><span class="line">'                                           '</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - +</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dispatch model：将图中各个节点的执行权限分配给不同的worker线程，每个worker线程在进行图遍历时，若遍历到需要其他线程才能执行的节点时，通过跨核调度机制将相关信息转交给其他线程进行处理。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Graph topo: node-0 -&gt; Core1; node-1 -&gt; node-2; node-2 -&gt; node-3. Config graph: node-0 @Core0; node-1/3 @Core1; node-2 @Core2.</span><br><span class="line">+ - - - - - -+     +- - - - - - - - - - - - - +     + - - - - - -+</span><br><span class="line">'  Core #0   '     '          Core #1         '     '  Core #2   '</span><br><span class="line">'            '     '                          '     '            '</span><br><span class="line">' +--------+ '     ' +--------+    +--------+ '     ' +--------+ '</span><br><span class="line">' | Node-0 | - - - -&gt;| Node-1 |    | Node-3 |&lt;- - - - | Node-2 | '</span><br><span class="line">' +--------+ '     ' +--------+    +--------+ '     ' +--------+ '</span><br><span class="line">'            '     '     |                    '     '      ^     '</span><br><span class="line">+ - - - - - -+     +- - -|- - - - - - - - - - +     + - - -|- - -+</span><br><span class="line">                         |                                 |</span><br><span class="line">                         + - - - - - - - - - - - - - - - - +</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>图由节点构成，每个节点都是一个独立的处理流程。dpdk对于节点做了单独的抽象<code>struct node</code>。在图创建时，dpdk会获取所需的节点来构建图。需要注意的是，图中的图节点<code>struct rte_node</code>与节点<code>struct node</code>是两个不同的数据结构，节点更像是<strong>类</strong>，而图中的图节点更像是<strong>实例</strong>。</p>
<p><a href="/images/anatomy_of_a_node.svg" title="node" class="gallery-item" style="box-shadow: none;"> <img src="/images/anatomy_of_a_node.svg" alt="node"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">	STAILQ_ENTRY(node) next;      <span class="comment">/**&lt; Next node in the list. */</span></span><br><span class="line">	<span class="type">char</span> name[RTE_NODE_NAMESIZE]; <span class="comment">/**&lt; Name of the node. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_NODE_SOURCE_F (1ULL &lt;&lt; 0) <span class="comment">/**&lt; Node type is source. */</span></span></span><br><span class="line">	<span class="type">uint64_t</span> flags;		      <span class="comment">/**&lt; Node configuration flag. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> lcore_id;</span><br><span class="line">	<span class="comment">/**&lt; Node runs on the Lcore ID used for mcore dispatch model. */</span></span><br><span class="line">	<span class="type">rte_node_process_t</span> process;   <span class="comment">/**&lt; Node process function. */</span></span><br><span class="line">	<span class="type">rte_node_init_t</span> init;         <span class="comment">/**&lt; Node init function. */</span></span><br><span class="line">	<span class="type">rte_node_fini_t</span> fini;	      <span class="comment">/**&lt; Node fini function. */</span></span><br><span class="line">	<span class="type">rte_node_t</span> id;		      <span class="comment">/**&lt; Allocated identifier for the node. */</span></span><br><span class="line">	<span class="type">rte_node_t</span> parent_id;	      <span class="comment">/**&lt; Parent node identifier. */</span></span><br><span class="line">	<span class="type">rte_edge_t</span> nb_edges;	      <span class="comment">/**&lt; Number of edges from this node. */</span></span><br><span class="line">	<span class="type">char</span> next_nodes[][RTE_NODE_NAMESIZE]; <span class="comment">/**&lt; Names of next nodes. */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点注册函数</span></span><br><span class="line">RTE_NODE_REGISTER(node)</span><br><span class="line"><span class="comment">//通过克隆来注册新节点，新节点的名称为"oldname-newname"。这在需要创建多个Rx/Tx节点时很有用</span></span><br><span class="line"><span class="type">rte_node_t</span> <span class="title function_">rte_node_clone</span><span class="params">(<span class="type">rte_node_t</span> id, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Node出边的更新"><a href="#Node出边的更新" class="headerlink" title="Node出边的更新"></a>Node出边的更新</h3><p>节点通过出边<code>next_nodes</code>与其他节点关联起来，构成拓扑图</p>
<p><a href="/images/link_the_nodes.svg" title="topology" class="gallery-item" style="box-shadow: none;"> <img src="/images/link_the_nodes.svg" alt="topology"></a></p>
<p>一般来说节点的出边在节点注册时就已经决定下来了，若想在节点注册后获取/修改节点的出边，可调用<code>rte_node_edge_get()</code>, <code>rte_node_edge_update()</code>, <code>rte_node_edge_shrink()</code>函数</p>
<h2 id="Graph-object"><a href="#Graph-object" class="headerlink" title="Graph object"></a>Graph object</h2><p>dpdk将图抽象为<code>struct graph</code>结构，存放着图的各类信息，其中最重要的成员是<code>struct rte_graph</code>，该成员保存着图节点以及图遍历时所需要的队列及其相关信息。</p>
<p><a href="/images/graph_mem_layout.svg" title="graph" class="gallery-item" style="box-shadow: none;"> <img src="/images/graph_mem_layout.svg" alt="graph"></a></p>
<p>Circular Buffer：图遍历时所用到的队列</p>
<p>Source Node：图中的源点，图遍历的起点</p>
<p>Enqueue Node：图中需要被执行的节点，图遍历时添加</p>
<p>Fastpath area：存放着该节点待处理的数据</p>
<h3 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h3><p>dpdk对于报文的处理，在图框架中就是对图的遍历。dpdk对图遍历采用BFS算法，从源节点开始访问，根据报文内容，确定要访问的下一个图节点，将报文指针放到对应图节点的<code>Fastpath area</code>中，并将该图节点在图<code>struct rte_graph</code>中的索引放到<code>Circular Buffer</code>中。</p>
<p>根据各节点确定next node的方法的不同，dpdk将节点分为两类：</p>
<ul>
<li>静态节点：该类节点对于next node的选择是固定的，即对于该节点所收到的批量报文，都转交给固定的图节点中。该类节点的<code>process()</code>可以使用<code>rte_node_next_stream_move()</code>函数来转交批量报文到next node并将next node添加到BFS的队列中。</li>
<li>中间节点：该类节点对于next node的选择是不固定的，即对于该节点所收到的所有报文，按报文类型转交给不同的图节点。相比于静态节点，该类节点的报文转交开销较大。实际上在大部分情况下，该类节点所收到的批量报文的next node都指向同一个，这个时候可以使用<code>rte_node_next_stream_move()</code>函数来批量转交报文到next node，这种处理被称为==home run==。</li>
</ul>
<p>对于中间节点的<code>process()</code>函数的实现，dpdk给出了一套流程：</p>
<ol>
<li><p>首先根据node-&gt;ctx，猜测一个next node（也可以不通过node-&gt;ctx，直接硬编码实现）：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next_index = node-&gt;ctx</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>rte_node_next_stream_get()</code>获取next node的<code>Fastpath area</code>：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to_next = rte_node_next_stream_get(graph, node, next_index, nb_mbufs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历该节点收到的批量报文，并根据报文内容，确定该报文要转交的next node，如果所确定的next node与猜测的<code>next_index</code>相等，则直接将报文指针放入<code>to_next</code>中，否则调用<code>rte_node_enqueue_x1()</code>将该报文转入所确定的next node中：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">next = do_something(mbuf)</span><br><span class="line"><span class="keyword">if</span>(next == next_index)</span><br><span class="line">    to_next[i++] = mbuf</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    rte_node_enqueue_x1(graph, node, next, mbuf)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果所有报文都转交给所猜测的<code>next_index</code>中，则做==home run==处理，否则调用<code>rte_node_next_stream_put()</code>进行报文转交：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i == nb_mbufs)</span><br><span class="line">    rte_node_next_stream_move(graph, node, next_index)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    rte_node_next_stream_put(graph, node, next_index, i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据该节点中各报文对于next node的选择情况，更新node-&gt;ctx</p>
</li>
</ol>
<blockquote>
<p>上述流程的主要目的是为了尽可能执行==home run==处理，因为==home run==处理可以避免不必要的内存拷贝，提高性能</p>
</blockquote>
<h2 id="Graph使用"><a href="#Graph使用" class="headerlink" title="Graph使用"></a>Graph使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_graph_param</span> {</span></span><br><span class="line">	<span class="type">int</span> socket_id; <span class="comment">/**&lt; Socket id where memory is allocated. */</span></span><br><span class="line">	<span class="type">uint16_t</span> nb_node_patterns;  <span class="comment">/**&lt; Number of node patterns. */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> **node_patterns;</span><br><span class="line">	<span class="comment">/**&lt; Array of node patterns based on shell pattern. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> pcap_enable; <span class="comment">/**&lt; Pcap enable. */</span></span><br><span class="line">	<span class="type">uint64_t</span> num_pkt_to_capture; <span class="comment">/**&lt; Number of packets to capture. */</span></span><br><span class="line">	<span class="type">char</span> *pcap_filename; <span class="comment">/**&lt; Filename in which packets to be captured.*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="type">uint64_t</span> rsvd; <span class="comment">/**&lt; Reserved for rtc model. */</span></span><br><span class="line">		} rtc;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="type">uint32_t</span> wq_size_max; <span class="comment">/**&lt; Maximum size of workqueue for dispatch model. */</span></span><br><span class="line">			<span class="type">uint32_t</span> mp_capacity; <span class="comment">/**&lt; Capacity of memory pool for dispatch model. */</span></span><br><span class="line">		} dispatch;</span><br><span class="line">	};</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建运行模型为RTC的图</span></span><br><span class="line"><span class="type">rte_graph_t</span> <span class="title function_">rte_graph_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> rte_graph_param *prm)</span>;</span><br><span class="line"><span class="comment">//图运行模型的设置，需在图创建后调用(运行模型若为RTC则不需要调用该函数)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_graph_worker_model_set</span><span class="params">(<span class="type">uint8_t</span> model)</span>;</span><br><span class="line"><span class="comment">//绑定节点所能运行的lcore，图的运行模型为Dispatch model时使用，需要在rte_graph_clone()之前设置好</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_graph_model_mcore_dispatch_node_lcore_affinity_set</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">							   <span class="type">unsigned</span> <span class="type">int</span> lcore_id)</span>;</span><br><span class="line"><span class="comment">//通过克隆来创建子图，子图与原图类似，但多了对Dispatch model的初始化。在选择了Dispatch model作为运行模型的情况下，需调用该函数来创建worker线程进行图遍历时所需的图</span></span><br><span class="line"><span class="type">rte_graph_t</span> <span class="title function_">rte_graph_clone</span><span class="params">(<span class="type">rte_graph_t</span> id, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> rte_graph_param *prm)</span>;</span><br><span class="line"><span class="comment">//将图绑定到对应的worker线程上，该图必须是通过rte_graph_clone()创建出来的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_graph_model_mcore_dispatch_core_bind</span><span class="params">(<span class="type">rte_graph_t</span> id, <span class="type">int</span> lcore)</span>;</span><br><span class="line"><span class="comment">//图遍历函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rte_graph_walk</span><span class="params">(<span class="keyword">struct</span> rte_graph *graph)</span></span><br><span class="line"><span class="comment">//创建一个用于整合图簇(一组图)中各节点统计数据的结构</span></span><br><span class="line"><span class="keyword">struct</span> rte_graph_cluster_stats *<span class="title function_">rte_graph_cluster_stats_create</span><span class="params">(</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> rte_graph_cluster_stats_param *prm)</span>;</span><br><span class="line"><span class="comment">//获取该图簇的统计信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rte_graph_cluster_stats_get</span><span class="params">(<span class="keyword">struct</span> rte_graph_cluster_stats *stat,</span></span><br><span class="line"><span class="params">				 <span class="type">bool</span> skip_cb)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="PacketFrame"><a href="#PacketFrame" class="headerlink" title="PacketFrame"></a>PacketFrame</h1><p>以后再说。</p>
<h1 id="Ethdev"><a href="#Ethdev" class="headerlink" title="Ethdev"></a>Ethdev</h1><p>dpdk使用大于等于0的整数（port id）用来充当dpdk所接管的网卡的标识符。</p>
<p>网卡配置流程：</p>
<ul>
<li>rte_eth_dev_configure()</li>
<li>rte_eth_tx_queue_setup()</li>
<li>rte_eth_rx_queue_setup()</li>
<li>rte_eth_dev_start()</li>
</ul>
<p>网卡在启动后如果需要重新配置，则需要先调用<code>rte_eth_dev_stop()</code>停止网卡，配置完毕后再调用<code>rte_eth_dev_start()</code>启动网卡。在网卡停止到启动期间，一些配置会被保留：</p>
<ul>
<li>MTU</li>
<li>流控制的设置</li>
<li>接收模式的配置（如混杂模式、广播模式、硬件校验模式…）</li>
<li>VLAN过滤配置</li>
<li>默认的MAC地址</li>
<li>流过滤模式（不包括过滤规则）</li>
<li>网卡队列统计映射</li>
</ul>
<p>下列配置可能会被保留：</p>
<ul>
<li>流规则</li>
<li>流相关的共享目标</li>
</ul>
<p>最后，应用程序可以通过调用<code>rte_eth_dev_close()</code>来关闭网卡。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取网卡信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_info_get</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="keyword">struct</span> rte_eth_dev_info *dev_info)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> {</span></span><br><span class="line">	<span class="type">uint32_t</span> link_speeds; <span class="comment">/**&lt; bitmap of RTE_ETH_LINK_SPEED_XXX of speeds to be</span></span><br><span class="line"><span class="comment">				used. RTE_ETH_LINK_SPEED_FIXED disables link</span></span><br><span class="line"><span class="comment">				autonegotiation, and a unique speed shall be</span></span><br><span class="line"><span class="comment">				set. Otherwise, the bitmap defines the set of</span></span><br><span class="line"><span class="comment">				speeds to be advertised. If the special value</span></span><br><span class="line"><span class="comment">				RTE_ETH_LINK_SPEED_AUTONEG (0) is used, all speeds</span></span><br><span class="line"><span class="comment">				supported are advertised. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxmode</span> <span class="title">rxmode</span>;</span> <span class="comment">/**&lt; Port Rx configuration. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txmode</span> <span class="title">txmode</span>;</span> <span class="comment">/**&lt; Port Tx configuration. */</span></span><br><span class="line">	<span class="type">uint32_t</span> lpbk_mode; <span class="comment">/**&lt; Loopback operation mode. By default the value</span></span><br><span class="line"><span class="comment">			         is 0, meaning the loopback mode is disabled.</span></span><br><span class="line"><span class="comment">				 Read the datasheet of given Ethernet controller</span></span><br><span class="line"><span class="comment">				 for details. The possible values of this field</span></span><br><span class="line"><span class="comment">				 are defined in implementation of each driver. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rss_conf</span> <span class="title">rss_conf</span>;</span> <span class="comment">/**&lt; Port RSS configuration */</span></span><br><span class="line">		<span class="comment">/** Port VMDq+DCB configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_dcb_conf</span> <span class="title">vmdq_dcb_conf</span>;</span></span><br><span class="line">		<span class="comment">/** Port DCB Rx configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dcb_rx_conf</span> <span class="title">dcb_rx_conf</span>;</span></span><br><span class="line">		<span class="comment">/** Port VMDq Rx configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_rx_conf</span> <span class="title">vmdq_rx_conf</span>;</span></span><br><span class="line">	} rx_adv_conf; <span class="comment">/**&lt; Port Rx filtering configuration. */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="comment">/** Port VMDq+DCB Tx configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_dcb_tx_conf</span> <span class="title">vmdq_dcb_tx_conf</span>;</span></span><br><span class="line">		<span class="comment">/** Port DCB Tx configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dcb_tx_conf</span> <span class="title">dcb_tx_conf</span>;</span></span><br><span class="line">		<span class="comment">/** Port VMDq Tx configuration. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_tx_conf</span> <span class="title">vmdq_tx_conf</span>;</span></span><br><span class="line">	} tx_adv_conf; <span class="comment">/**&lt; Port Tx DCB configuration (union). */</span></span><br><span class="line">	<span class="comment">/** Currently,Priority Flow Control(PFC) are supported,if DCB with PFC</span></span><br><span class="line"><span class="comment">	    is needed,and the variable must be set RTE_ETH_DCB_PFC_SUPPORT. */</span></span><br><span class="line">	<span class="type">uint32_t</span> dcb_capability_en;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_intr_conf</span> <span class="title">intr_conf</span>;</span> <span class="comment">/**&lt; Interrupt mode configuration. */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//网卡设置，通过该函数所设置的所有offload特性会应用到该网卡的所有队列上</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_configure</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="type">uint16_t</span> nb_rx_queue,</span></span><br><span class="line"><span class="params">		<span class="type">uint16_t</span> nb_tx_queue, <span class="type">const</span> <span class="keyword">struct</span> rte_eth_conf *eth_conf)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="网卡硬件特性"><a href="#网卡硬件特性" class="headerlink" title="网卡硬件特性"></a>网卡硬件特性</h2><h3 id="RSS-Receiver-Side-Scaling"><a href="#RSS-Receiver-Side-Scaling" class="headerlink" title="RSS(Receiver Side Scaling)"></a>RSS(Receiver Side Scaling)</h3><p>将网卡收到的报文分发至不同的接收队列中，实现了对CPU负载的均衡分配。应用程序可在<code>mbuf.rss</code>中获取硬件对该报文所计算出来的hash值。</p>
<p><a href="/images/rss.png" title="rss" class="gallery-item" style="box-shadow: none;"> <img src="/images/rss.png" alt="rss"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Below macros are defined for RSS offload types, they can be used to</span></span><br><span class="line"><span class="comment"> * fill rte_eth_rss_conf.rss_hf or rte_flow_action_rss.types.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_IPV4               RTE_BIT64(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_FRAG_IPV4          RTE_BIT64(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NONFRAG_IPV4_TCP   RTE_BIT64(4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NONFRAG_IPV4_UDP   RTE_BIT64(5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NONFRAG_IPV4_SCTP  RTE_BIT64(6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NONFRAG_IPV4_OTHER RTE_BIT64(7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_IPV6               RTE_BIT64(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_FRAG_IPV6          RTE_BIT64(9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NONFRAG_IPV6_TCP   RTE_BIT64(10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NONFRAG_IPV6_UDP   RTE_BIT64(11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NONFRAG_IPV6_SCTP  RTE_BIT64(12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NONFRAG_IPV6_OTHER RTE_BIT64(13)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_L2_PAYLOAD         RTE_BIT64(14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_IPV6_EX            RTE_BIT64(15)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_IPV6_TCP_EX        RTE_BIT64(16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_IPV6_UDP_EX        RTE_BIT64(17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_PORT               RTE_BIT64(18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_VXLAN              RTE_BIT64(19)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_GENEVE             RTE_BIT64(20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_NVGRE              RTE_BIT64(21)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_GTPU               RTE_BIT64(23)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_ETH                RTE_BIT64(24)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_S_VLAN             RTE_BIT64(25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_C_VLAN             RTE_BIT64(26)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_ESP                RTE_BIT64(27)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_AH                 RTE_BIT64(28)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_L2TPV3             RTE_BIT64(29)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_PFCP               RTE_BIT64(30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_PPPOE              RTE_BIT64(31)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_ECPRI              RTE_BIT64(32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_MPLS               RTE_BIT64(33)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTE_ETH_RSS_IPV4_CHKSUM        RTE_BIT64(34)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rte_eth_hash_function</span> {</span></span><br><span class="line">	<span class="comment">/** DEFAULT means driver decides which hash algorithm to pick. */</span></span><br><span class="line">	RTE_ETH_HASH_FUNCTION_DEFAULT = <span class="number">0</span>,</span><br><span class="line">	RTE_ETH_HASH_FUNCTION_TOEPLITZ, <span class="comment">/**&lt; Toeplitz */</span></span><br><span class="line">	RTE_ETH_HASH_FUNCTION_SIMPLE_XOR, <span class="comment">/**&lt; Simple XOR */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Symmetric Toeplitz: src, dst will be replaced by</span></span><br><span class="line"><span class="comment">	 * xor(src, dst). For the case with src/dst only,</span></span><br><span class="line"><span class="comment">	 * src or dst address will xor with zero pair.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Symmetric Toeplitz: L3 and L4 fields are sorted prior to</span></span><br><span class="line"><span class="comment">	 * the hash function.</span></span><br><span class="line"><span class="comment">	 *  If src_ip &gt; dst_ip, swap src_ip and dst_ip.</span></span><br><span class="line"><span class="comment">	 *  If src_port &gt; dst_port, swap src_port and dst_port.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT,</span><br><span class="line">	RTE_ETH_HASH_FUNCTION_MAX,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rte_eth_rss_conf {</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * In rte_eth_dev_rss_hash_conf_get(), the *rss_key_len* should be</span></span><br><span class="line"><span class="comment">	 * greater than or equal to the *hash_key_size* which get from</span></span><br><span class="line"><span class="comment">	 * rte_eth_dev_info_get() API. And the *rss_key* should contain at least</span></span><br><span class="line"><span class="comment">	 * *hash_key_size* bytes. If not meet these requirements, the query</span></span><br><span class="line"><span class="comment">	 * result is unreliable even if the operation returns success.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In rte_eth_dev_rss_hash_update() or rte_eth_dev_configure(), if</span></span><br><span class="line"><span class="comment">	 * *rss_key* is not NULL, the *rss_key_len* indicates the length of the</span></span><br><span class="line"><span class="comment">	 * *rss_key* in bytes and it should be equal to *hash_key_size*.</span></span><br><span class="line"><span class="comment">	 * If *rss_key* is NULL, drivers are free to use a random or a default key.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint8_t</span> *rss_key;</span><br><span class="line">	<span class="type">uint8_t</span> rss_key_len; <span class="comment">/**&lt; hash key length in bytes. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicates the type of packets or the specific part of packets to</span></span><br><span class="line"><span class="comment">	 * which RSS hashing is to be applied.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint64_t</span> rss_hf;</span><br><span class="line">    <span class="comment">//选择对称的hash算法可以保证一条流上的双向报文分配到同一个接收队列中</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_eth_hash_function</span> <span class="title">algorithm</span>;</span>	<span class="comment">/**&lt; Hash algorithm. */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h3 id="LRO-Large-Receive-Offload"><a href="#LRO-Large-Receive-Offload" class="headerlink" title="LRO(Large Receive Offload)"></a>LRO(Large Receive Offload)</h3><p>网卡将收到的同一TCP流中连续的分段报文重组成一个大的数据包，返回给用户。用户可通过判断<code>mbuf.ol_flags</code>字段是否设置了<code>RTE_MBUF_F_RX_LRO</code>来确定当前报文是否被网卡合并过。</p>
<h3 id="TSO-TCP-Segmentation-Offloading"><a href="#TSO-TCP-Segmentation-Offloading" class="headerlink" title="TSO(TCP Segmentation Offloading)"></a>TSO(TCP Segmentation Offloading)</h3><p>网卡将发送侧所收到的大的TCP报文（大小超过网卡MTU）拆分成多个小包发送。需要拆分的报文需要在<code>mbuf.ol_flags</code>字段设置<code>RTE_MBUF_F_TX_TCP_SEG</code></p>
<h3 id="VMDq-Virtual-Machine-Device-Queues"><a href="#VMDq-Virtual-Machine-Device-Queues" class="headerlink" title="VMDq(Virtual Machine Device Queues)"></a>VMDq(Virtual Machine Device Queues)</h3><p>虚拟化系统中，为了使每台虚机都能使用网络功能，虚机管理器内置了虚拟交换机，将多台虚机连成一个或多个网络。而这个虚拟交换机就会负责接收从网卡收上来的报文，并进行分类和排序，将其发送给对应的虚机。VMDq实际上实现了一个半软半硬的虚拟交换机，网卡侧用硬件实现了一个分类/排序器，通过识别报文的MAC/VLAN来将收到的数据包发送到指定的pool中（每个pool会对应一个或多个接收队列），VMM侧只需要将收到的报文发送到该pool所对应的虚机网卡中即可。</p>
<p>由于一个pool可能对应多个接收队列，此时如果配置了RSS则会根据报文的hash结果选择其中一个接收队列，没有配置的话默认选择pool中的第一个接收队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A structure used to configure the VMDq feature of an Ethernet port when</span></span><br><span class="line"><span class="comment"> * not combined with the DCB feature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Using this feature, packets are routed to a pool of queues. By default,</span></span><br><span class="line"><span class="comment"> * the pool selection is based on the MAC address, the VLAN ID in the</span></span><br><span class="line"><span class="comment"> * VLAN tag as specified in the pool_map array.</span></span><br><span class="line"><span class="comment"> * Passing the RTE_ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool</span></span><br><span class="line"><span class="comment"> * selection using only the MAC address. MAC address to pool mapping is done</span></span><br><span class="line"><span class="comment"> * using the rte_eth_dev_mac_addr_add function, with the pool parameter</span></span><br><span class="line"><span class="comment"> * corresponding to the pool ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue selection within the selected pool will be done using RSS when</span></span><br><span class="line"><span class="comment"> * it is enabled or revert to the first queue of the pool if not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A default pool may be used, if desired, to route all traffic which</span></span><br><span class="line"><span class="comment"> * does not match the VLAN filter rules or any pool MAC address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_vmdq_rx_conf</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_eth_nb_pools</span> <span class="title">nb_queue_pools</span>;</span> <span class="comment">/**&lt; VMDq only mode, 8 or 64 pools */</span></span><br><span class="line">	<span class="type">uint8_t</span> enable_default_pool; <span class="comment">/**&lt; If non-zero, use a default pool */</span></span><br><span class="line">	<span class="type">uint8_t</span> default_pool; <span class="comment">/**&lt; The default pool, if applicable */</span></span><br><span class="line">	<span class="type">uint8_t</span> enable_loop_back; <span class="comment">/**&lt; Enable VT loop back */</span></span><br><span class="line">	<span class="type">uint8_t</span> nb_pool_maps; <span class="comment">/**&lt; We can have up to 64 filters/mappings */</span></span><br><span class="line">	<span class="type">uint32_t</span> rx_mode; <span class="comment">/**&lt; Flags from RTE_ETH_VMDQ_ACCEPT_* */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">		<span class="type">uint16_t</span> vlan_id; <span class="comment">/**&lt; The VLAN ID of the received frame */</span></span><br><span class="line">		<span class="type">uint64_t</span> pools;   <span class="comment">/**&lt; Bitmask of pools for packet Rx */</span></span><br><span class="line">	} pool_map[RTE_ETH_VMDQ_MAX_VLAN_FILTERS]; <span class="comment">/**&lt; VMDq VLAN pool maps. */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//向网卡添加mac地址时指明该mac地址所对应的pool_index</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_mac_addr_add</span><span class="params">(<span class="type">uint16_t</span> port_id, <span class="keyword">struct</span> rte_ether_addr *addr,</span></span><br><span class="line"><span class="params">			<span class="type">uint32_t</span> pool)</span></span><br></pre></td></tr></table></figure>



<h3 id="DCB-Data-Center-Bridging"><a href="#DCB-Data-Center-Bridging" class="headerlink" title="DCB(Data Center Bridging)"></a>DCB(Data Center Bridging)</h3><p>DCB中的TC(Traffic Class)允许对网络流量进行细粒度的控制和管理，以满足不同应用场景下的性能和可靠性需求。网卡依靠报文中VLAN头的PRI字段（3bit长，也称up字段）来确定其属于哪个TC。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dcb_rx_conf</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_eth_nb_tcs</span> <span class="title">nb_tcs</span>;</span> <span class="comment">/**&lt; Possible DCB TCs, 4 or 8 TCs */</span></span><br><span class="line">	<span class="comment">/** Traffic class each UP mapped to. */</span></span><br><span class="line">	<span class="type">uint8_t</span> dcb_tc[RTE_ETH_DCB_NUM_USER_PRIORITIES];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><p>将流规则下发到网卡中，网卡根据下发的规则对报文去做匹配，并将命中的报文按规则定义的动作改变报文的命运。</p>
<p>流规则由三部分组成：</p>
<ul>
<li>规则属性（struct rte_flow_attr）：定义该规则的一些特性，如规则匹配方向（匹配入口/出口），规则的优先级等。</li>
<li>模式匹配（struct rte_flow_item）：由一系列模式项组成，每个模式项都匹配报文数据的特定部分。</li>
<li>动作（struct rte_flow_action）：由一系列动作组成，指明了流规则命中后对该报文的操作。</li>
</ul>
<h3 id="规则属性"><a href="#规则属性" class="headerlink" title="规则属性"></a>规则属性</h3><ul>
<li>group：用于指明该规则的所属组。网卡默认使用0组的规则对报文进行匹配，可以使用流规则动作中的<code>JUMP</code>动作将命中的报文送到指定组进行再次匹配。</li>
<li>priority：规则优先级，0为最高优先级。若有多个规则命中，仅执行最高优先级的规则的动作。</li>
<li>traffic direction：指明该规则应用于网卡的入口流量还是出口流量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_flow_attr</span> {</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A group is a superset of multiple rules.</span></span><br><span class="line"><span class="comment">	 * The default group is 0 and is processed for all packets.</span></span><br><span class="line"><span class="comment">	 * Rules in other groups are processed only if the group is chained</span></span><br><span class="line"><span class="comment">	 * by a jump action from a previously matched rule.</span></span><br><span class="line"><span class="comment">	 * It means the group hierarchy is made by the flow rules,</span></span><br><span class="line"><span class="comment">	 * and the group 0 is the hierarchy root.</span></span><br><span class="line"><span class="comment">	 * Note there is no automatic dead loop protection.</span></span><br><span class="line"><span class="comment">	 * @see rte_flow_action_jump</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> group;</span><br><span class="line">	<span class="type">uint32_t</span> priority; <span class="comment">/**&lt; Rule priority level within group. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The rule in question applies to ingress traffic (non-"transfer").</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> ingress:<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The rule in question applies to egress traffic (non-"transfer").</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> egress:<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Instead of simply matching the properties of traffic as it would</span></span><br><span class="line"><span class="comment">	 * appear on a given DPDK port ID, enabling this attribute transfers</span></span><br><span class="line"><span class="comment">	 * a flow rule to the lowest possible level of any device endpoints</span></span><br><span class="line"><span class="comment">	 * found in the pattern.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When supported, this effectively enables an application to</span></span><br><span class="line"><span class="comment">	 * re-route traffic not necessarily intended for it (e.g. coming</span></span><br><span class="line"><span class="comment">	 * from or addressed to different physical ports, VFs or</span></span><br><span class="line"><span class="comment">	 * applications) at the device level.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The application should match traffic originating from precise</span></span><br><span class="line"><span class="comment">	 * locations. See items PORT_REPRESENTOR and REPRESENTED_PORT.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Managing "transfer" flows requires that the user communicate them</span></span><br><span class="line"><span class="comment">	 * through a suitable port. @see rte_flow_pick_transfer_proxy().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint32_t</span> transfer:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint32_t</span> reserved:<span class="number">29</span>; <span class="comment">/**&lt; Reserved, must be zero. */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>匹配项通常分为两类：</p>
<ul>
<li>data matching：匹配协议头/报文数据，通常与特定的数据结构相联系</li>
<li>meta：影响后续匹配项的匹配行为</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Matching pattern item definition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A pattern is formed by stacking items starting from the lowest protocol</span></span><br><span class="line"><span class="comment"> * layer to match. This stacking restriction does not apply to meta items</span></span><br><span class="line"><span class="comment"> * which can be placed anywhere in the stack without affecting the meaning</span></span><br><span class="line"><span class="comment"> * of the resulting pattern.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Patterns are terminated by END items.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The spec field should be a valid pointer to a structure of the related</span></span><br><span class="line"><span class="comment"> * item type. It may remain unspecified (NULL) in many cases to request</span></span><br><span class="line"><span class="comment"> * broad (nonspecific) matching. In such cases, last and mask must also be</span></span><br><span class="line"><span class="comment"> * set to NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Optionally, last can point to a structure of the same type to define an</span></span><br><span class="line"><span class="comment"> * inclusive range. This is mostly supported by integer and address fields,</span></span><br><span class="line"><span class="comment"> * may cause errors otherwise. Fields that do not support ranges must be set</span></span><br><span class="line"><span class="comment"> * to 0 or to the same value as the corresponding fields in spec.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Only the fields defined to nonzero values in the default masks (see</span></span><br><span class="line"><span class="comment"> * rte_flow_item_{name}_mask constants) are considered relevant by</span></span><br><span class="line"><span class="comment"> * default. This can be overridden by providing a mask structure of the</span></span><br><span class="line"><span class="comment"> * same type with applicable bits set to one. It can also be used to</span></span><br><span class="line"><span class="comment"> * partially filter out specific fields (e.g. as an alternate mean to match</span></span><br><span class="line"><span class="comment"> * ranges of IP addresses).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Mask is a simple bit-mask applied before interpreting the contents of</span></span><br><span class="line"><span class="comment"> * spec and last, which may yield unexpected results if not used</span></span><br><span class="line"><span class="comment"> * carefully. For example, if for an IPv4 address field, spec provides</span></span><br><span class="line"><span class="comment"> * 10.1.2.3, last provides 10.3.4.5 and mask provides 255.255.0.0, the</span></span><br><span class="line"><span class="comment"> * effective range becomes 10.1.0.0 to 10.3.255.255.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_flow_item</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rte_flow_item_type</span> <span class="title">type</span>;</span> <span class="comment">/**&lt; Item type. */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *spec; <span class="comment">/**&lt; Pointer to item specification structure. */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *last; <span class="comment">/**&lt; Defines an inclusive range (spec to last). */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *mask; <span class="comment">/**&lt; Bit-mask applied to spec and last. */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>



<h4 id="Meta-item"><a href="#Meta-item" class="headerlink" title="Meta item"></a>Meta item</h4><p>常见的item类型：</p>
<ul>
<li>END：放在模式匹配的最后一项，用于指明匹配结束</li>
<li>VOID：占位符，没有任何作用。未来该规则的模式项进行扩展时可以复用该模式项</li>
<li>INVERT：反向匹配，其后面的模式项不与报文匹配才算命中</li>
</ul>
<h4 id="Data-matching-item"><a href="#Data-matching-item" class="headerlink" title="Data matching item"></a>Data matching item</h4><p>常见的item类型：</p>
<ul>
<li>ANY：匹配当前的协议头，无论报文内容是什么都会命中</li>
<li>RAW：在给定偏移处去匹配给定长度的字符串</li>
<li>ETH：匹配以太头，对应<code>struct rte_flow_item_eth</code></li>
</ul>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>动作分为三类：</p>
<ul>
<li>改变报文命运的动作：如丢包，或者将报文送到指定队列中</li>
<li>修改报文内容的动作：如添加/删除协议头</li>
<li>与流规则自身关联的动作：如统计规则命中次数</li>
</ul>
<p>常见的item类型：</p>
<ul>
<li>END：放在动作列表的最后一项，用于指明动作结束</li>
<li>VOID：占位符</li>
<li>PASSTHRU：不终止对该报文的匹配，使其可以继续匹配其他规则</li>
<li>JUMP：将该报文重定向到其他规则组进行匹配</li>
<li>QUEUE：将该报文分配到指定队列</li>
<li>DROP：丢弃该报文</li>
<li>COUNT：更新指定的计数器</li>
</ul>
<h3 id="Flow的使用"><a href="#Flow的使用" class="headerlink" title="Flow的使用"></a>Flow的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证流规则的有效性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_flow_validate</span><span class="params">(<span class="type">uint16_t</span> port_id,</span></span><br><span class="line"><span class="params">		  <span class="type">const</span> <span class="keyword">struct</span> rte_flow_attr *attr,</span></span><br><span class="line"><span class="params">		  <span class="type">const</span> <span class="keyword">struct</span> rte_flow_item pattern[],</span></span><br><span class="line"><span class="params">		  <span class="type">const</span> <span class="keyword">struct</span> rte_flow_action actions[],</span></span><br><span class="line"><span class="params">		  <span class="keyword">struct</span> rte_flow_error *error)</span>;</span><br><span class="line"><span class="comment">//创建流规则</span></span><br><span class="line"><span class="keyword">struct</span> rte_flow *</span><br><span class="line"><span class="title function_">rte_flow_create</span><span class="params">(<span class="type">uint16_t</span> port_id,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> rte_flow_attr *attr,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> rte_flow_item pattern[],</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> rte_flow_action actions[],</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> rte_flow_error *error)</span>;</span><br><span class="line"><span class="comment">//删除该网卡所创建的所有流规则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rte_flow_flush</span><span class="params">(<span class="type">uint16_t</span> port_id,</span></span><br><span class="line"><span class="params">	       <span class="keyword">struct</span> rte_flow_error *error)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">rte_thread_create_internal_control</span><span class="params">(<span class="type">rte_thread_t</span> *id, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		rte_thread_func func, <span class="type">void</span> *arg)</span></span><br></pre></td></tr></table></figure>

<p>该函数用于创建一个控制线程，相比与一般线程，控制线程会设置socket ID为SOCKET_ID_ANY，使得该线程可以在任意numa节点上运行，并设置该线程的cpu亲和性为控制线程的cpuset。</p>
<hr>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-01-01</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>看过大海的人不会忘记海的广阔</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


</html>