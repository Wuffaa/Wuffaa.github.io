<!DOCTYPE html>
<html lang="zh-Hans">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="" />
    <meta name="hexo-theme-A4" content="v1.9.8" />
    <link rel="alternate icon" type="image/webp" href="/images/Neurothingy.jpg">
    <title>Wuffaa | Blog</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    

<meta name="generator" content="Hexo 6.3.0"></head>
    
    

    
    



    

    
    




    
    

    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            
                <div class="left-toc-container">
                    <nav id="toc" class="bs-docs-sidebar"></nav>
                </div>
            
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 50%; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/images/Neurothingy.jpg" 
        />
        <div class="header-content">
            <a class="logo" href="/">Wuffaa</a> 
            <span class="description">el psy congroo</span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2025-06-14</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：7.4k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：27分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RISCV%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="post-toc-text">RISCV相关知识</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">特权模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-text">寄存器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Control-and-Status-Register-%EF%BC%9ACSR%EF%BC%89"><span class="post-toc-text">控制寄存器（Control and Status Register ：CSR）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%88%AB%E5%90%8D%EF%BC%89"><span class="post-toc-text">通用寄存器（别名）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="post-toc-text">中断</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Trap"><span class="post-toc-text">Trap</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B1%87%E7%BC%96"><span class="post-toc-text">汇编</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="post-toc-text">操作系统相关知识</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#xv6%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="post-toc-text">xv6启动流程</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E9%94%81"><span class="post-toc-text">锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="post-toc-text">自旋锁</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%9D%A1%E7%9C%A0%E9%94%81"><span class="post-toc-text">睡眠锁</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%89%93%E5%8D%B0"><span class="post-toc-text">打印</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#UART%EF%BC%88Universal-Asynchronous-Receiver-Transmitter%EF%BC%89"><span class="post-toc-text">UART（Universal Asynchronous Receiver&#x2F;Transmitter）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CONSOLE"><span class="post-toc-text">CONSOLE</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#printf"><span class="post-toc-text">printf</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81"><span class="post-toc-text">内核态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81"><span class="post-toc-text">用户态</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="post-toc-text">内存管理</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84"><span class="post-toc-text">页表映射</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">内核页表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">进程页表</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="post-toc-text">进程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="post-toc-text">进程状态机</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="post-toc-text">进程调度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="post-toc-text">进程创建</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="post-toc-text">第一个用户进程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#fork%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="post-toc-text">fork创建的进程</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="post-toc-text">进程退出</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD"><span class="post-toc-text">程序加载</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TRAP"><span class="post-toc-text">TRAP</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E8%A7%A6%E5%8F%91trap"><span class="post-toc-text">用户态触发trap</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E8%A7%A6%E5%8F%91trap"><span class="post-toc-text">内核态触发trap</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#trap%E5%A4%84%E7%90%86"><span class="post-toc-text">trap处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="post-toc-text">时钟中断</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="post-toc-text">系统调用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="post-toc-text">外部中断</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#uart"><span class="post-toc-text">uart</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#virtio-disk"><span class="post-toc-text">virtio_disk</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="post-toc-text">文件系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BLOCK"><span class="post-toc-text">BLOCK</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LOGGING"><span class="post-toc-text">LOGGING</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="post-toc-text">使用方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BLOCK-ALLOCATOR"><span class="post-toc-text">BLOCK ALLOCATOR</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#INODE"><span class="post-toc-text">INODE</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DIRECTORY"><span class="post-toc-text">DIRECTORY</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FILE-DESCRIPTOR"><span class="post-toc-text">FILE DESCRIPTOR</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">文件类型</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="post-toc-text">用户程序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="post-toc-text">内存管理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#INIT"><span class="post-toc-text">INIT</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SHELL"><span class="post-toc-text">SHELL</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-linux"><span class="post-toc-text">系统调用(linux)</span></a></li></ol>
            
        
        <div class=".article-gallery"><h1 id="RISCV相关知识"><a href="#RISCV相关知识" class="headerlink" title="RISCV相关知识"></a>RISCV相关知识</h1><h2 id="特权模式"><a href="#特权模式" class="headerlink" title="特权模式"></a>特权模式</h2><p>RISCV有三种特权模式：</p>
<ul>
<li>机器模式（<strong>M-mode</strong>）：cpu启动时所处的特权模式，可访问所有的寄存器，通常用于初始化系统</li>
<li>监管模式（<strong>S-mode</strong>）：可处理大多数异常和中断，通常用于运行操作系统</li>
<li>用户模式（<strong>U-mode</strong>）：只能访问部分的CSR，通常用于运行用户程序</li>
</ul>
<p>不同模式下对<code>CSR</code>有着不同的视图，比如在M-mode下，可以看到<code>status</code>寄存器的所有内容（mstatus），而在S-mode下，只能看到<code>status</code>寄存器与该模式相关的位（sstatus）。所以在处于不同特权模式下，对应的汇编指令和寄存器名称有所不同，会带有对应模式的前缀（如监管模式下的sepc和sret）</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="控制寄存器（Control-and-Status-Register-：CSR）"><a href="#控制寄存器（Control-and-Status-Register-：CSR）" class="headerlink" title="控制寄存器（Control and Status Register ：CSR）"></a>控制寄存器（Control and Status Register ：CSR）</h3><ul>
<li>mhartid：cpuid，每个cpu都有唯一的值，从0开始</li>
<li>mstatus：控制特权模式，管理中断和异常，保存上下文信息</li>
<li>mepc：保存trap发生时的pc值。当trap返回时，可通过mret恢复到trap发生前的指令地址</li>
<li>stvec：当中断或异常发生时，cpu会跳转到该寄存器所指向的地址开始执行代码</li>
<li>satp：在<strong>S-mode</strong>下使用，用于设置虚拟内存，启用MMU，指定页表基址，选择地址转换模式（Sv32、Sv39、Sv48等）</li>
</ul>
<blockquote>
<p>Sv39（S-mode virtual address 39bit）：用于将39位va转换为56位pa。采用3级页表，每个页表4K，有512个页表条目，每个页表条目（Page Table Entry：PTE）大小为64字节。PTE的[53-10]位用于物理页号（PPN），PPN的44位+12位全零（2^12&#x3D;4K）组成了下一级的页表基地址。</p>
</blockquote>
<h3 id="通用寄存器（别名）"><a href="#通用寄存器（别名）" class="headerlink" title="通用寄存器（别名）"></a>通用寄存器（别名）</h3><ul>
<li>x0：被硬编码为0，任何读取都会获得0，任何写入都会被丢弃</li>
<li>tp(thread pointer)：常用于存储线程私有数据，在xv6中该寄存器用于存储mhartid</li>
<li>sscratch：临时寄存器，常用于上下文切换</li>
<li>s0~s11：保存寄存器，也称为被调用者寄存器。函数内部如果使用这些寄存器，必须在函数开始时压栈保存，并在返回之前恢复它们的值。</li>
</ul>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>PLIC</strong>是一个用于管理外部中断的硬件模块，<strong>PLIC_SCLAIM</strong>寄存器的作用是声明（claim）和完成（complete）中断处理</p>
<ul>
<li><p>读该寄存器获取最高优先级的未处理中断ID，同时该中断会被标记为”已声明“，屏蔽该中断</p>
</li>
<li><p>在中断处理完成后向该寄存器中写入相同的中断ID，通知<strong>PLIC</strong>该中断处理完成，可以接收同类型的中断</p>
</li>
</ul>
<p>默认RISCV禁止中断嵌套，当RISCV进入异常或中断处理程序时，硬件会自动关闭中断<code>sstatus.SIE</code>，并将该值保存到<code>sstatus.SPIE</code>中。当中断返回时执行<code>sret</code>，硬件会自动恢复中断。</p>
<h2 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h2><p>在riscv中，trap是一个广义术语，用来统称所有会导致程序执行流程跳转到异常处理程序（trap handler）的事件。根据触发方式分为两类：</p>
<ul>
<li>同步trap：与当前执行的指令相关，如主动的陷阱和被动的异常</li>
<li>异步trap：各类中断</li>
</ul>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>函数调用时，使用<code>call</code>伪指令来实现，对应汇编语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jal test			#将pc+4地址存到ra寄存器中，设置pc为test</span><br><span class="line"></span><br><span class="line">test:				#test函数</span><br><span class="line">addi sp, sp, -16	#为该函数分配栈</span><br><span class="line">sd   ra, 8(sp)		#将ra寄存器内容保存到栈中</span><br><span class="line">sd   s0, 0(sp)		#编译器根据当前函数所使用的保存寄存器的个数进行入栈</span><br></pre></td></tr></table></figure>



<p>函数返回时，使用<code>ret</code>伪指令来实现返回操作，对应汇编语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ld ra, 8(sp)		#取待返回的地址到ra寄存器中</span><br><span class="line">ld s0, 0(sp)		#恢复保存寄存器</span><br><span class="line">jalr x0, 0(ra)		#将ra寄存器的内容写入到x0寄存器(实际上会被丢弃)，设置pc为寄存器ra的内容</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>jal</strong>和<strong>jalr</strong>的区别：<strong>jal</strong>的目标地址是来源于当前指令地址+偏移量，<strong>jalr</strong>的目标地址是来源于指定寄存器值+偏移量</p>
</blockquote>
<h1 id="操作系统相关知识"><a href="#操作系统相关知识" class="headerlink" title="操作系统相关知识"></a>操作系统相关知识</h1><ul>
<li>具有独立pid的线程都是可被内核调度的线程，<code>pthread_create()</code>会向内核创建线程，内核都会为其创建独立的线程上下文和内核上下文，所以在linux中，用户线程和内核线程是一一对应的。</li>
</ul>
<h1 id="xv6启动流程"><a href="#xv6启动流程" class="headerlink" title="xv6启动流程"></a>xv6启动流程</h1><p>xv6采用<code>-bios none -kernel kernel/kernel</code>的方式加载xv6内核。qemu启动后，vcpu会默认执行位于<strong>0x80000000</strong>的代码，因此xv6的入口函数位于该地址。需要注意的是，Makefile中<code>OBJS</code>的第一个文件一定得是<code>entry.o</code>文件，因为<code>ld</code>会根据后面指定的输入文件顺序来生成可执行文件的代码段。</p>
<p>xv6的启动流程如下：</p>
<ul>
<li>_entry：为每个cpu设置一页的栈（这里的栈是临时使用的，临时栈处于.data段），设置好后就可以跳到<code>start()</code>执行C代码了</li>
<li>start()：设置一些需要在M-mode下才能设置的配置，然后切换到<strong>S-mode</strong>并跳到<code>main()</code></li>
<li>main()：cpuid为0的cpu执行内核初始化操作，其他cpu等待内核初始化完成。内核初始化完成后，cpuid为0的cpu启动第一个用户进程<code>initcode</code>，所有cpu开始参与进程调度</li>
</ul>
<blockquote>
<p>_entry代码中的spin是为了防止start函数返回。正常情况下start函数永远不会返回</p>
</blockquote>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    uint locked;		<span class="comment">//1表示已上锁，0表示未上锁</span></span><br><span class="line">    <span class="type">char</span> *name;			<span class="comment">//锁名称，调试使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>	<span class="comment">//持有当前锁的cpu</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>acquire()</strong>：上锁，上锁前关闭该cpu中断</p>
<p><strong>release()</strong>：解锁，解锁后恢复该cpu中断</p>
<p>这里对中断采用<code>push_off</code>和<code>pop_off</code>控制，这两个函数对中断嵌套层数进行记录，只有当退出最后一层中断时，才实际恢复中断该cpu的中断。这样做可以使cpu可以同时持有多把自旋锁。</p>
<h2 id="睡眠锁"><a href="#睡眠锁" class="headerlink" title="睡眠锁"></a>睡眠锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">    uint locked;		<span class="comment">//1表示已上锁，0表示未上锁</span></span><br><span class="line">    strut spinlock lk;	<span class="comment">//用于保护locked成员</span></span><br><span class="line">    <span class="type">char</span> *name;			<span class="comment">//锁名称，调试使用</span></span><br><span class="line">    <span class="type">int</span> pid;			<span class="comment">//持有该锁的进程的pid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>acquiresleep()</strong>：如果该锁已经被锁住，则调用sleep()进行休眠，被唤醒后进行上锁</p>
<p><strong>releasesleep()</strong>：解锁，调用wakeup()唤醒因该锁而睡眠的进程</p>
<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><h2 id="UART（Universal-Asynchronous-Receiver-Transmitter）"><a href="#UART（Universal-Asynchronous-Receiver-Transmitter）" class="headerlink" title="UART（Universal Asynchronous Receiver&#x2F;Transmitter）"></a>UART（Universal Asynchronous Receiver&#x2F;Transmitter）</h2><p>uart是一种常见的串行接口，cpu通过uart总线（有些cpu内部集成了uart控制器，通过特定的GPIO引脚复用充当uart总线；有些设备通过系统总线连接到uart控制器，然后通过访问特定的IO地址来访问uart控制器，这时系统总线就是uart总线）与其他设备进行交互。</p>
<p>xv6在启动内核时采用<code>-nographic</code>参数，该参数将禁用图形界面，默认将uart映射为标准输入输出。</p>
<p>中断触发：</p>
<ul>
<li><p>当用户从键盘输入时，会触发uart的输入中断，通知cpu有数据需要读取</p>
</li>
<li><p>当cpu向uart写入数据时，uart会将输入的字符在终端上显示，并触发输出中断。</p>
</li>
</ul>
<p>cpu向uart所写入的数据，都会显示在终端上。</p>
<p><strong>uartinit()</strong>：uart控制器初始化</p>
<p><strong>uartgetc()</strong>：cpu从uart中读取1字节数据，如果当前没有数据可读，返回 -1。只有uart中断才会调用该函数进行数据读取</p>
<p>**uartputc()**：cpu向uart中写入1字节数据。该函数有一个缓冲区<code>uart_tx_buf[UART_TX_BUF_SIZE]</code>用于存储uart未发送的数据，当该缓冲区满的时候，调用<code>sleep()</code>等待缓冲区有空间。而后尝试将该缓冲区的数据都发送出去，如果发送出去了1个字节，则调用<code>wakeup()</code>唤醒其余因缓冲区满而睡眠的进程</p>
<p><strong>uartputc_sync()</strong>：uartputc()的同步版本，阻塞到uart可发送时，将该字符发送出去</p>
<p><strong>uartintr()</strong>：uart中断处理。先调用<code>uartgetc()</code>接收数据，并调用<code>consoleintr()</code>处理接受的数据。然后尝试将该缓冲区的数据都发送出去，如果发送出去，则唤醒因缓冲区满而睡眠的进程</p>
<h2 id="CONSOLE"><a href="#CONSOLE" class="headerlink" title="CONSOLE"></a>CONSOLE</h2><p>对终端设备的抽象，在xv6中对应的物理设备为uart。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>		<span class="comment">//保证每次仅有一个进程读buf</span></span><br><span class="line">    <span class="type">char</span> buf[INPUT_BUF_SIZE];	<span class="comment">//用于缓存用户输入的内容</span></span><br><span class="line">    uint r;						<span class="comment">//记录当前read的索引</span></span><br><span class="line">    uint e;						<span class="comment">//记录当前回显的索引</span></span><br><span class="line">    uint w;						<span class="comment">//记录行尾的索引</span></span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure>



<p><strong>consoleinit()</strong>：初始化console设备</p>
<p><strong>consoleintr()</strong>：处理用户输入的数据，如果是控制字符，则做特殊处理，将处理结果写入到uart中；如果是其他字符，则将该字符写入到uart中进行回显，同时将该字符缓存到<code>cons.buf</code>中，更新<code>cons.e</code>；如果是换行符（或者buf满了），则额外更新<code>cons.w</code>，同时调用<code>wakeup()</code>唤醒因执行<code>console read()</code>时未收到完整一行的输入而休眠的进程</p>
<p><strong>consoleread()</strong>：从<code>cons.buf</code>中读取数据，若未收到指定数量的数据或者未收到完整的一行，则调用<code>sleep()</code>进行休眠</p>
<p><strong>consolewrite()</strong>：调用<code>uartputc()</code>将数据发送到uart</p>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>	<span class="comment">//保证每次只有一个cpu执行printf</span></span><br><span class="line">    <span class="type">int</span> locking;			<span class="comment">//初始化lock后该字段为1</span></span><br><span class="line">&#125; pr;</span><br></pre></td></tr></table></figure>

<p>解析格式化字符串，将解析后的字符串调用<code>uartputc_sync()</code>发送出去。</p>
<h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>解析格式化字符串，将解析后的字符串通过write系统调用，最终调到<code>consolewrite()</code>将字符串发送出去。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>	<span class="comment">//保护freelist</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span>	<span class="comment">//每个节点都对应空闲的一页</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>



<p>xv6将从<code>end</code>到<code>PHYSTOP</code>之间的物理内存，每页为一个节点，插入到<code>freelist</code>链表中进行管理。申请和释放都是以页为单位的。</p>
<ul>
<li><strong>end</strong>：从BSS段末尾开始的地址</li>
<li><strong>PHYSTOP</strong>：0x80000000 + 128 * 1024 * 1024</li>
</ul>
<p><a href="/images/kernel_pa_range.drawio.svg" title="kernel_pa_range" class="gallery-item" style="box-shadow: none;"> <img src="/images/kernel_pa_range.drawio.svg" alt="kernel_pa_range"></a></p>
<p><code>freelist</code>这段地址也可以被称作内核堆。</p>
<h1 id="页表映射"><a href="#页表映射" class="headerlink" title="页表映射"></a>页表映射</h1><p>页表本身的地址使用的是物理地址，而不是虚拟地址。</p>
<p>页表切换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sfence.vma zero, zero	#等待所有内存操作的完成，因为内存操作需要访问页表</span><br><span class="line">csrw stap, t1			#切换页表，t1寄存器的内容为MAKE_SATP(pagetable)</span><br><span class="line">sfence.vma zero, zero	#刷掉TLB中失效的缓存</span><br></pre></td></tr></table></figure>



<h2 id="内核页表"><a href="#内核页表" class="headerlink" title="内核页表"></a>内核页表</h2><p>所有的cpu，在处于内核态时都使用同一张页表<code>kernel_pagetable</code>。</p>
<p>xv6的内核页表采用直接映射，也就是VA和PA是一样的。</p>
<p>具体映射以下内存地址：</p>
<ul>
<li>MMIO地址：直接映射UART、VIRTIO、PLIC，权限为读写</li>
<li>代码段地址：直接映射从<code>.text</code>到<code>etext</code>的这段内存，权限为读执行</li>
<li>数据段+堆地址：直接映射从<code>etext</code>到<code>PHYSTOP</code>的这段内存，权限为读写</li>
<li>trampoline地址：间接映射，把代码段中的<code>trampsec</code>段（一页大小）映射到VA为<code>MAXVA - PGSIZE</code>的地址空间，权限为读执行</li>
<li>进程内核栈地址：间接映射，把所有进程的内核栈（从内核堆中申请出来的）映射到与trampoline相邻的地址，权限为读写</li>
</ul>
<blockquote>
<p>每个进程的内核栈仅用一个页，紧挨着内核栈的上下页未映射任何物理地址，用于检测栈溢出。</p>
</blockquote>
<p>内核VA与PA的映射关系如下图所示：</p>
<p><a href="/images/kernel_pa_va.svg" title="kernel_pa_va" class="gallery-item" style="box-shadow: none;"> <img src="/images/kernel_pa_va.svg" alt="kernel_pa_va"></a></p>
<h2 id="进程页表"><a href="#进程页表" class="headerlink" title="进程页表"></a>进程页表</h2><p>每个进程都有自己的页表，该页表采用间接映射</p>
<p>具体映射以下内存地址：</p>
<ul>
<li>代码段：映射二进制文件的<code>.text</code>和<code>.rodata</code>到内存，权限为读执行</li>
<li>数据段：映射二进制文件的<code>.data</code>到<code>.bss</code>到内存，权限为读写</li>
<li>栈：映射一页到<code>.bss</code>末尾的地址，空一页用于检测栈溢出，权限为读写</li>
<li>堆：通过<code>sbrk()</code>系统调用分配进程内存，映射到栈之后的地址，权限为读写</li>
<li>trampoline：把代码段中的<code>trampsec</code>段（一页大小）映射到VA为<code>MAXVA - PGSIZE</code>的地址空间，权限为读执行</li>
<li>trapframe：映射到trampoline前一页的地址，权限为读写</li>
</ul>
<p>进程VA与PA的映射关系如下图所示：</p>
<p><a href="/images/proc_pa_va.svg" title="proc_pa_va" class="gallery-item" style="box-shadow: none;"> <img src="/images/proc_pa_va.svg" alt="proc_pa_va"></a></p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>xv6使用<code>struct proc</code>记录每个进程的状态信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>			<span class="comment">//保护空行前的这些成员</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>			<span class="comment">//进程当前状态</span></span><br><span class="line">    <span class="type">void</span> *chan;						<span class="comment">//如果非空，则该进程处于SLEEPING状态，且等待chan所指向的内容改变</span></span><br><span class="line">    <span class="type">int</span> killed;						<span class="comment">//如果非0，则该进程已经被kill掉了</span></span><br><span class="line">    <span class="type">int</span> xstate;						<span class="comment">//用于返回给父进程的返回值</span></span><br><span class="line">    <span class="type">int</span> pid;						<span class="comment">//进程id</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>			<span class="comment">//父进程</span></span><br><span class="line">    </span><br><span class="line">    uint64 kstack;					<span class="comment">//该进程内核栈</span></span><br><span class="line">    uint64 sz;						<span class="comment">//该进程所使用的内存大小，以字节为单位</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;			<span class="comment">//用户页表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span>	<span class="comment">//trap上下文所使用的一块内存，主要用于保存用户态寄存器信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>			<span class="comment">//内核态进程切换时使用，用于保存该进程内核态寄存器信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>				<span class="comment">//进程当前目录</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>]					<span class="comment">//进程名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时每个cpu都对应一个<code>struct cpu</code>，用于记录当前cpu所运行的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>				<span class="comment">//当前该cpu运行的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span>;</span>					<span class="comment">//内核态进程切换时使用，用于保存调度程序的上下文信息。当运行的进程需要进行调度时，可通过该上下文返回到调度程序中。</span></span><br><span class="line">    <span class="type">int</span> noff;						<span class="comment">//用于记录当前cpu中断嵌套层数</span></span><br><span class="line">    <span class="type">int</span> intena;						<span class="comment">//记录中断关闭前cpu是否开启中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进程状态机"><a href="#进程状态机" class="headerlink" title="进程状态机"></a>进程状态机</h2><p><a href="/images/proc_state.svg" title="proc_state" class="gallery-item" style="box-shadow: none;"> <img src="/images/proc_state.svg" alt="proc_state"></a></p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>xv6采用的是时间片轮转调度算法，通过调用<code>scheduler()</code>对所有进程进行统一调度。</p>
<p>调度函数循环遍历<code>proc数组</code>，获取就绪队列的进程，并调用<code>swtch()</code>切换到该进程。当该进程需要被调度时调用<code>sched()</code>切换回调度函数继续进行进程调度。当没有进程可以调度时，xv6会处于低功耗模式，直到该cpu触发中断。</p>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>目前xv6通过两种方式创建进程：</p>
<ul>
<li>xv6初始化成功后默认创建第一个用户进程</li>
<li>通过fork系统调用创建新的进程</li>
</ul>
<p>对于新创建的进程，其<code>p-&gt;context.ra</code>为<code>forkret()</code>，当内核执行进程调度时，会调用<code>swtch()</code>将该进程的p-&gt;context加载到当前寄存器中，并调用<code>ret</code>，跳转到<code>forkret()</code>。</p>
<p><strong>forkret()</strong>：所有新创建的进程第一次被调度都会执行该函数，该函数会调用<code>usertrapret()</code>返回到用户态，执行用户程序。</p>
<h3 id="第一个用户进程"><a href="#第一个用户进程" class="headerlink" title="第一个用户进程"></a>第一个用户进程</h3><p><strong>userinit()</strong>：创建一个新进程，设置用户程序为<code>initcode</code>，并设置进程的当前目录为根目录。</p>
<h3 id="fork创建的进程"><a href="#fork创建的进程" class="headerlink" title="fork创建的进程"></a>fork创建的进程</h3><p><strong>fork()</strong>：创建一个新进程，将父进程的内存复制一份到子进程中（父子进程的VA相同，单PA不同），复制<code>p-&gt;trapframe</code>（这里会将子进程的<code>trapframe-&gt;a0</code>设置为0，在调度到子进程的时候会返回0），复制文件描述符，复制当前目录，设置父进程。</p>
<h2 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h2><p><strong>exit()</strong>：关闭所有打开的文件，取消对当前目录的引用，将所有子进程的父进程都设置为<code>init</code>进程。</p>
<p><strong>wait()</strong>：父进程调用，回收退出的子进程的内存资源。</p>
<h2 id="程序加载"><a href="#程序加载" class="headerlink" title="程序加载"></a>程序加载</h2><p><strong>exec()</strong>：读取文件的elf头，加载段到内存中（.text .rodata .data .bss），分配一页用户栈，将入参压入用户栈，设置好用户态寄存器的pc指针和栈指针，及<code>main()</code>的入参寄存器的值。</p>
<h1 id="TRAP"><a href="#TRAP" class="headerlink" title="TRAP"></a>TRAP</h1><p>RISCV支持两种模式的trap跳转：</p>
<ul>
<li>Direct：所有异常都跳转到同一地址处理</li>
<li>Vectored：不同类型的异常跳到不同的偏移地址</li>
</ul>
<p>xv6选用<strong>Direct</strong>模式，统一trap处理入口。</p>
<p>当xv6处于不同模式下，其trap的入口函数也会有所不同</p>
<ul>
<li>在内核态（<strong>S-mode</strong>模式）下，xv6设置trap入口函数为<code>kernelvec</code></li>
<li>在用户态（<strong>U-mode</strong>模式）下，xv6设置trap入口函数为<code>uservec</code></li>
</ul>
<h2 id="用户态触发trap"><a href="#用户态触发trap" class="headerlink" title="用户态触发trap"></a>用户态触发trap</h2><p><strong>uservec</strong>：用户态进入内核态的上下文切换</p>
<ul>
<li>将用户态寄存器保存在该进程的<code>trapframe</code>中</li>
<li>设置内核栈，获取内核态的trap入口函数<code>usertrap()</code>，获取内核页表</li>
<li>设置页表为内核页表</li>
<li>跳到<code>usertrap()</code>进行trap处理</li>
</ul>
<p><strong>usertrapret()</strong>：内核态返回用户态的上下文切换</p>
<ul>
<li><p>保存内核必要信息到<code>trapframe</code>中，设置相关控制寄存器</p>
</li>
<li><p>调用<strong>userret</strong>，切换到进程页表，恢复用户态寄存器，返回到用户程序</p>
</li>
</ul>
<h2 id="内核态触发trap"><a href="#内核态触发trap" class="headerlink" title="内核态触发trap"></a>内核态触发trap</h2><p><strong>kernelvec</strong>：内核态trap上下文切换</p>
<ul>
<li><p>将当前寄存器压栈</p>
</li>
<li><p>调用<code>kerneltrap()</code>进行trap处理（因为处理该trap之前已经处于内核态，所以不考虑trap为系统调用的情况）</p>
</li>
<li><p>出栈并恢复寄存器，返回到被中断前所执行的代码</p>
</li>
</ul>
<h2 id="trap处理"><a href="#trap处理" class="headerlink" title="trap处理"></a>trap处理</h2><h3 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h3><p><strong>yield()</strong>：唤醒正在<strong>sleep</strong>的进程（被唤醒的进程如果sleep时间未到，会再次进入睡眠），将当前进程状态设为<strong>RUNNABLE</strong>，调用<code>swtch()</code>切换回调度函数。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><strong>syscall()</strong>：根据系统调用号调用对应的处理函数，并将返回值写入<code>p-&gt;trapframe-&gt;a0</code>，最终返回给用户。</p>
<h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><h4 id="uart"><a href="#uart" class="headerlink" title="uart"></a>uart</h4><p>触发<strong>uartintr()</strong></p>
<h4 id="virtio-disk"><a href="#virtio-disk" class="headerlink" title="virtio_disk"></a>virtio_disk</h4><p>触发<strong>virtio_disk_intr()</strong></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>扇区：磁盘读写的最小单位</p>
<p>块：文件系统对存储设备管理时所使用的最小逻辑单位，一个块可由多个扇区组成，在xv6中块大小为1024字节</p>
<p>xv6的文件系统格式如下图所示</p>
<p><a href="/images/file_system.drawio.svg" title="file_system" class="gallery-item" style="box-shadow: none;"> <img src="/images/file_system.drawio.svg" alt="file_system"></a> </p>
<ul>
<li><p>引导块：暂时没用</p>
</li>
<li><p>超级块：记录该文件系统信息</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">    uint magic;			<span class="comment">//0x10203040</span></span><br><span class="line">    uint size;			<span class="comment">//文件系统块的数量，默认2000</span></span><br><span class="line">    uint nblocks;		<span class="comment">//data块的数量，默认1954</span></span><br><span class="line">    uint ninodes;		<span class="comment">//inode的数量，默认200（inode块数量为13）</span></span><br><span class="line">    uint nlog;			<span class="comment">//log块的数量（loghdr + log data），默认30</span></span><br><span class="line">    uint logstart;		<span class="comment">//log块起始块号，默认2</span></span><br><span class="line">    uint inodestart;	<span class="comment">//inode块起始块号，默认32</span></span><br><span class="line">    uint bmapstart;		<span class="comment">//bit map块起始块号，默认45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>loghdr块：用于文件系统恢复，待回复的数据在log data块中</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> n;				<span class="comment">//待恢复的块的数量</span></span><br><span class="line">    <span class="type">int</span> block[LOGSIZE];	<span class="comment">//待回复的data块索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>inode块：存储dinode，用于记录目录和文件信息</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> type;				<span class="comment">//文件类型：目录、文件或设备</span></span><br><span class="line">    <span class="type">short</span> major;			<span class="comment">//主设备号（类型为设备时使用）</span></span><br><span class="line">    <span class="type">short</span> minor;			<span class="comment">//次设备号（类型为设备时使用）</span></span><br><span class="line">    <span class="type">short</span> nlink;			<span class="comment">//链接数</span></span><br><span class="line">    uint size;				<span class="comment">//该文件大小（以字节为单位）</span></span><br><span class="line">    uint addrs[NDIRECT+<span class="number">1</span>];	<span class="comment">//数据块索引，存储着文件内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bit map块：记录整个文件系统块使用情况，每一位代表一个块</p>
</li>
</ul>
<p>xv6将文件系统分为多个层次，这里从低到高分别进行讲解</p>
<h2 id="BLOCK"><a href="#BLOCK" class="headerlink" title="BLOCK"></a>BLOCK</h2><p>对块加载，块读写的封装</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> valid;					<span class="comment">//该块数据是否加载</span></span><br><span class="line">    <span class="type">int</span> disk;					<span class="comment">//驱动使用，1表示正在进行硬件操作，0表示操作完成</span></span><br><span class="line">    uint dev;					<span class="comment">//设备号，每个设备号对应一个物理/逻辑设备</span></span><br><span class="line">    uint blockno;				<span class="comment">//块id</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span>		<span class="comment">//一次只允许一个读者或写者</span></span><br><span class="line">    uint refcnt;				<span class="comment">//当前块被引用的次数，被bcache.lock保护</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span>			<span class="comment">//块链表，采用LRU算法调整该块在链表中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span>			<span class="comment">//同上</span></span><br><span class="line">    uchar data[BSIZE];			<span class="comment">//块内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span>		<span class="comment">//缓存块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span>			<span class="comment">//连接所有的块，LRU算法使用</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>xv6使用缓存块来保存从存储设备中读出来的数据，并且使用LRU算法对这些块缓存块进行管理。</p>
<p><strong>LRU算法</strong>：<code>bcache.head</code>中存储着所有的缓存块，链表头节点为最近的使用的缓存块，链表尾节点为最久使用的缓存块。当操作系统需要加载一个<strong>新的块</strong>到内存中时，会从链表尾开始遍历，选择一个没有被引用的块作为缓存块，并将块数据读取到缓冲块中。当操作系统不再引用该缓存块时，将该缓存块调整到链表头位置。</p>
<p><strong>bread()</strong>：根据设备号和块号获取缓存块，获取该块的锁，并将对应的块数据读取到该缓存块中</p>
<p><strong>bwrite()</strong>：将缓存块内容写入到块中（需持有该缓存块的锁）</p>
<p><strong>brelse()</strong>：释放该缓存块的锁，并减少引用计数，如果引用计数为0，则把该块移到链表头位置</p>
<p><strong>bpin()&#x2F;bunpin()</strong>：对该缓存块增加&#x2F;减少引用计数</p>
<h2 id="LOGGING"><a href="#LOGGING" class="headerlink" title="LOGGING"></a>LOGGING</h2><p>因为文件写入并非原子操作，需要同时修改inode块，bitmap块和data块。在写入这些块期间，如果系统发生crash，则文件系统的数据就可能因为部分更新而产生错误。为了避免这个问题，xv6引用log层。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> start;					<span class="comment">//loghdr块索引</span></span><br><span class="line">    <span class="type">int</span> size;					<span class="comment">//log块个数（loghdr + log data）</span></span><br><span class="line">    <span class="type">int</span> outstanding;			<span class="comment">//当前进行文件写入的进程个数，当最后一个进程完成写入操作时，才执行磁盘写入的操作</span></span><br><span class="line">    <span class="type">int</span> committing;				<span class="comment">//是否正在执行磁盘写入操作</span></span><br><span class="line">    <span class="type">int</span> dev;					<span class="comment">//设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span>		<span class="comment">//loghdr块的缓存数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设磁盘保证了写入一个块的操作是原子的。写入流程如下：</p>
<ol>
<li><p>将写入的块都放到内存的<code>log</code>中缓存，随后进行统一的写入</p>
</li>
<li><p>当最后一个写入操作完成时，将log信息写到到磁盘的log data（先写）和loghdr块（后写）中</p>
</li>
<li><p>将待写入的缓存块写入到磁盘的data块中</p>
</li>
<li><p>清除磁盘中loghdr块的log信息</p>
</li>
</ol>
<p>当xv6启动后，会进行文件系统恢复，如果在第二步的loghdr块写入之前出现crash，那么恢复代码将会忽略该log；如果在第三步时出现crash，那么恢复代码将会将log中的数据恢复到data块中；如果在第三步和第四步之间出现crash，那么恢复代码会重新写入一次。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...)</span><br><span class="line">modify bp-&gt;data[]</span><br><span class="line">log_write(bp)</span><br><span class="line">brelse(bp)</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>

<p><strong>begin_op()</strong>：表示一个进程准备执行文件写入操作</p>
<p><strong>log_write()</strong>：将写入操作记录到<code>log</code>中（为了避免缓存块被释放，这里调用<code>bpin()</code>）</p>
<p><strong>end_op()</strong>：完成写入操作，如果该进程是最后一个执行写入的进程，则执行写入操作的第二三四步</p>
<p><strong>initlog()</strong>：系统启动时调用，读取log块内容，恢复文件系统</p>
<h2 id="BLOCK-ALLOCATOR"><a href="#BLOCK-ALLOCATOR" class="headerlink" title="BLOCK ALLOCATOR"></a>BLOCK ALLOCATOR</h2><p>对块分配，块释放的封装</p>
<p><strong>balloc()</strong>：遍历bitmap块的每一位，找到空闲的data块，并分配该块</p>
<p><strong>bfree()</strong>：清除该块在bitmap块中所对应的位</p>
<h2 id="INODE"><a href="#INODE" class="headerlink" title="INODE"></a>INODE</h2><p>inode是用于描述文件信息的数据结构，磁盘中将文件信息以<code>dinode</code>结构存储在inode块中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    uint dev;				<span class="comment">//设备号</span></span><br><span class="line">    uint inum;				<span class="comment">//inode号</span></span><br><span class="line">    <span class="type">int</span> ref;				<span class="comment">//当前正在使用该inode的进程个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> valid;				<span class="comment">//表示该inode数据是否从磁盘加载</span></span><br><span class="line">    <span class="comment">//下面的成员对应于磁盘中inode块中的dinode</span></span><br><span class="line">    <span class="type">short</span> type;</span><br><span class="line">    <span class="type">short</span> major;</span><br><span class="line">    <span class="type">short</span> mintor;</span><br><span class="line">    <span class="type">short</span> nlink;</span><br><span class="line">    uint size;</span><br><span class="line">    uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6的inode保留了0号inode。因为在分配inode时，<code>ialloc()</code>会返回申请的inode号，若为0，表示inode分配失败。</p>
<p>inode利用索引机制，将文件内容存储在data块中。<code>inode-&gt;addrs</code>记录着该文件内容的索引项，前<code>NDIRECT</code>个元素为直接索引，最后一个元素为间接索引，指向的data块中存储着<code>1024/sizeof(uint)</code>个直接索引。</p>
<p><strong>ialloc()</strong>：分配一个inode，并返回inode号</p>
<p><strong>iget()</strong>：获取inode</p>
<p><strong>bmap()</strong>：获取inode的第n个数据块，如果该数据块不存在，则申请一个数据块</p>
<p><strong>itrunc()</strong>：释放该inode的所有数据块</p>
<p><strong>stati()</strong>：获取该inode的属性</p>
<p><strong>readi()&#x2F;writei()</strong>：读写该inode的数据块内容</p>
<h2 id="DIRECTORY"><a href="#DIRECTORY" class="headerlink" title="DIRECTORY"></a>DIRECTORY</h2><p>当inode类型为目录时，其数据块内容为目录条目<code>dirent</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    ushort inum;		<span class="comment">//文件（或目录）所对应的inode号</span></span><br><span class="line">    <span class="type">char</span> name[DIRSIZ];	<span class="comment">//文件名（或目录名）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认inode号为1的inode是根目录。</p>
<p><strong>dirlookup()</strong>：在目录中查找名为name的inode</p>
<p><strong>dirlink()</strong>：在目录中创建一个新的目录条目</p>
<h2 id="FILE-DESCRIPTOR"><a href="#FILE-DESCRIPTOR" class="headerlink" title="FILE DESCRIPTOR"></a>FILE DESCRIPTOR</h2><p>维护当前系统打开的文件，所有打开的文件都保存在<code>ftable</code>中，最多支持同时打开100个文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE,</span><br><span class="line">        FD_PIPE,</span><br><span class="line">        FD_INODE,</span><br><span class="line">        FD_DEVICE</span><br><span class="line">    &#125; type;</span><br><span class="line">    <span class="type">int</span> ref;			<span class="comment">//引用该文件的次数，如dup，fork等</span></span><br><span class="line">    <span class="type">char</span> readable;		<span class="comment">//文件是否可读</span></span><br><span class="line">    <span class="type">char</span> writable;		<span class="comment">//文件是否可写</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span>	<span class="comment">//文件类型为PIPE时使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>	<span class="comment">//文件类型为INODE或DEVICE时使用</span></span><br><span class="line">    uint off;			<span class="comment">//文件类型为INODE时使用</span></span><br><span class="line">    <span class="type">short</span> major;		<span class="comment">//文件类型为DEVICE时使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul>
<li><p>PIPE：匿名文件，只存在内存中，由操作系统维护</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">    uint nread;				<span class="comment">//读字节数，当nread == nwrite时，缓冲区空</span></span><br><span class="line">    uint nwrite;			<span class="comment">//写字节数，当nread + PIPESIZE == nwrite时，缓冲区满</span></span><br><span class="line">    <span class="type">int</span> readopen;			<span class="comment">//表示读文件描述符是否关闭</span></span><br><span class="line">    <span class="type">int</span> writeopen;			<span class="comment">//表示写文件描述符是否关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DEVICE：与常规文件类似，但对应的inode不需要数据块，只需要指定major和minor。操作系统会根据该文件的major来调用对应设备的驱动。目前只支持一种设备CONSOLE</p>
</li>
<li><p>INODE：常规文件，<code>off</code>记录打开文件的当前偏移</p>
</li>
</ul>
<h1 id="用户程序"><a href="#用户程序" class="headerlink" title="用户程序"></a>用户程序</h1><h2 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">header</span> *<span class="title">ptr</span>;</span>	<span class="comment">//指向下一个空闲块的指针</span></span><br><span class="line">        uint size;			<span class="comment">//该内存块大小（包括header），以sizeof(Header)为单位</span></span><br><span class="line">    &#125; s;</span><br><span class="line">    Align x;				<span class="comment">//为了结构体8字节对齐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="/images/malloc.drawio.svg" title="malloc" class="gallery-item" style="box-shadow: none;"> <img src="/images/malloc.drawio.svg" alt="malloc"></a></p>
<p><strong>freep</strong>：指向空闲块链表中的一个空闲块</p>
<p><strong>base</strong>：哨兵节点，<code>size</code>为0，用于简化代码操作</p>
<p>初始化时<code>freep</code>指向<code>base</code>，<code>base</code>块的<code>size</code>为0，且<code>ptr</code>指向自己</p>
<p><strong>malloc()</strong>：</p>
<ul>
<li>确定所需空闲块大小</li>
<li>从空闲块链表中寻找大于需求的空闲块<ul>
<li>如果找到：将该块分配出去，空闲链表跳过该块</li>
<li>如果未找到：调用<code>sbrk()</code>向系统申请堆内存，调用<code>free()</code>将该空闲块插入到空闲块链表中。下次遍历就可以找到该空闲块</li>
</ul>
</li>
</ul>
<p><strong>free()</strong>：</p>
<ul>
<li>遍历空闲块链表，判断该空闲块是否可以和相邻空闲块合并<ul>
<li>如果可以合并：合并空闲块，并调整空闲块链表</li>
<li>如果不可以合并：根据该空闲块所在的地址，将其插入到空闲块链表中</li>
</ul>
</li>
</ul>
<h2 id="INIT"><a href="#INIT" class="headerlink" title="INIT"></a>INIT</h2><ul>
<li><p>打开console设备，输入输出标准输出都指向该设备。</p>
</li>
<li><p>执行<code>fork()</code>创建<code>sh</code>子进程：</p>
<ul>
<li>父进程：循环调用<code>wait()</code>，回收子进程的资源（孤儿进程），如果<code>sh</code>子进程退出，则返回到上一步再次创建<code>sh</code>子进程</li>
<li>子进程：启动一个shell</li>
</ul>
</li>
</ul>
<h2 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h2><p>获取一行输入，如果是cd命令，则执行<code>chdir()</code>系统调用，否则调用<code>fork()</code>，由子进程处理获取的输入（因为执行命令需要<code>exec()</code>，会重新开始执行一个新的命令）。</p>
<p>子进程调用<code>parsecmd()</code>，将输入命令解析为一个语法树，而后调用<code>runcmd()</code>遍历语法树并运行相关命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;	<span class="comment">//命令类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6的shell支持下面的命令类型：</p>
<ul>
<li><p><strong>EXEC</strong>：执行外部命令，例如：<code>echo a</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];	<span class="comment">//命令入参，argv[0]为命令本身，后面为参数，以null结尾</span></span><br><span class="line">    <span class="type">char</span> *eargv[MAXAGRS];	<span class="comment">//指向每个命令入参的结尾，用于设置入参字符串结束符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  直接执行exec系统调用，运行对应的外部命令。</p>
<ul>
<li><strong>REDIR</strong>：重定向，只支持**’&lt;’ ‘&gt;’ ‘&gt;&gt;’**例如：<code>echo a &gt; test.txt</code></li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    <span class="type">char</span> *file;			<span class="comment">//重定向的文件</span></span><br><span class="line">    <span class="type">char</span> *efile;</span><br><span class="line">    <span class="type">int</span> mode;			<span class="comment">//重定向文件的打开权限</span></span><br><span class="line">    					<span class="comment">//&#x27;&lt;&#x27;为O_RDONLY</span></span><br><span class="line">   						<span class="comment">//&#x27;&gt;&#x27;为O_WRONLY|O_CREATE|O_TRUNC</span></span><br><span class="line">    					<span class="comment">//&#x27;&gt;&gt;&#x27;为O_WRONLY|O_CREATE</span></span><br><span class="line">    <span class="type">int</span> fd;				<span class="comment">//被重定向的文件描述符（&#x27;&lt;&#x27;为0，&#x27;&gt;&#x27;和&#x27;&gt;&gt;&#x27;为1）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  关闭该进程的被重定向的文件描述符，将该文件描述符换为重定向的文件，而后执行<code>cmd</code></p>
</li>
<li><p><strong>PIPE</strong>：管道，例如：<code>ls | wc</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  创建一个pipe管道，而后执行两次<code>fork()</code>：</p>
<ul>
<li>子进程1：关闭输出文件描述符<code>1</code>，将pipe的写管道<code>p[1]</code>复制到输出描述符<code>1</code>上，而后关闭pipe的两个文件描述符，执行<code>left</code></li>
<li>子进程2：关闭输入文件描述符<code>0</code>，将pipe的读管道<code>p[0]</code>复制到输入描述符<code>0</code>上，而后关闭pipe的两个文件描述符，执行<code>right</code></li>
</ul>
<p>  父进程关闭pipe的两个文件描述符，并等待两个子进程执行完毕</p>
</li>
<li><p><strong>LIST</strong>：命令分割符，可按顺序运行多个命令，例如：<code>echo a ; ls</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listcmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  执行<code>fork()</code>，子进程执行<code>left</code>，父进程等待子进程执行完毕后执行<code>right</code></p>
</li>
<li><p><strong>BACK</strong>：后台运行，例如：<code>sleep 5 &amp;</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backcmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  执行<code>fork()</code>，父进程不等待子进程执行完毕，直接退出（子进程退出后资源会由<code>init</code>进程回收）</p>
</li>
</ul>
<p>xv6中shell各命令符号的优先级：<code>LIST &lt; BACK &lt; PIPE &lt; REDIR &lt; EXEC &lt; 括号</code></p>
<h1 id="系统调用-linux"><a href="#系统调用-linux" class="headerlink" title="系统调用(linux)"></a>系统调用(linux)</h1><ul>
<li><p>fork和exec分开的原因是为了方便重定向的实现，fork之后关闭标准输入&#x2F;输出，改为重定向的输入&#x2F;输出。</p>
</li>
<li><p>fork之后子进程会复制文件描述符，同时也会复制文件描述符缓冲区的内容，所以，fork之后，输出可能有重复。</p>
</li>
<li><p>dup与fork一样，都会共享文件描述符，包括其偏移信息。</p>
</li>
</ul>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2025-06-14</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2025/04/06/ovs/">ovs</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    wrapEmojis('.paper');
  });
</script>