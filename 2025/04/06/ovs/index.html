<!DOCTYPE html>
<html lang="zh-Hans">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="ovs" />
    <meta name="hexo-theme-A4" content="v1.9.7" />
    <link rel="alternate icon" type="image/webp" href="/images/Neurothingy.jpg">
    <title>Wuffaa | Blog</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    

<meta name="generator" content="Hexo 6.3.0"></head>
    
    

    
    



    

    
    




    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 50%; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/images/Neurothingy.jpg" 
        />
        <div class="header-content">
            <a class="logo" href="/">Wuffaa</a> 
            <span class="description">el psy congroo</span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    ovs
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2025-04-22</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：9.6k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：39分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#POLL"><span class="post-toc-text">POLL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#POLL-API"><span class="post-toc-text">POLL API</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#POLL%E5%8E%9F%E7%90%86"><span class="post-toc-text">POLL原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RCU-Read-Copy-Update"><span class="post-toc-text">RCU(Read-Copy-Update)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RCU-API"><span class="post-toc-text">RCU API</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RCU%E5%BA%94%E7%94%A8"><span class="post-toc-text">RCU应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#rcu-index"><span class="post-toc-text">rcu_index</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#rcu-list"><span class="post-toc-text">rcu_list</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RCU%E5%8E%9F%E7%90%86"><span class="post-toc-text">RCU原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#LATCH"><span class="post-toc-text">LATCH</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LATCH-API"><span class="post-toc-text">LATCH API</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#SEQ"><span class="post-toc-text">SEQ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SEQ-API"><span class="post-toc-text">SEQ API</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#COVERAGE"><span class="post-toc-text">COVERAGE</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="post-toc-text">命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#API"><span class="post-toc-text">API</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8E%9F%E7%90%86"><span class="post-toc-text">原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#PVECTOR-Concurrent-Priority-Vector"><span class="post-toc-text">PVECTOR(Concurrent Priority Vector)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#API-1"><span class="post-toc-text">API</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#CMAP-Concurrent-hash-map"><span class="post-toc-text">CMAP(Concurrent hash map)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#API-2"><span class="post-toc-text">API</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="post-toc-text">原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CCMAP"><span class="post-toc-text">CCMAP</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#HMAP"><span class="post-toc-text">HMAP</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#API-3"><span class="post-toc-text">API</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BA%94%E7%94%A8"><span class="post-toc-text">应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#smap"><span class="post-toc-text">smap</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#simap"><span class="post-toc-text">simap</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#shash"><span class="post-toc-text">shash</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sset"><span class="post-toc-text">sset</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hmapx"><span class="post-toc-text">hmapx</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#id-pool"><span class="post-toc-text">id_pool</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#CLS-CLASSIFIER"><span class="post-toc-text">CLS(CLASSIFIER)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CLS-API"><span class="post-toc-text">CLS API</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CLS%E5%BA%94%E7%94%A8"><span class="post-toc-text">CLS应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#router"><span class="post-toc-text">router</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#tnl%EF%BC%88tunnel%EF%BC%89"><span class="post-toc-text">tnl（tunnel）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#openflow-table"><span class="post-toc-text">openflow table</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CLS%E5%8E%9F%E7%90%86"><span class="post-toc-text">CLS原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%A9%E7%A0%81%E4%BC%98%E5%8C%96"><span class="post-toc-text">掩码优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E6%AE%B5hash%E5%8C%B9%E9%85%8D"><span class="post-toc-text">分段hash匹配</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%89%8D%E7%BC%80%E5%9F%9F%E5%8C%B9%E9%85%8D"><span class="post-toc-text">前缀域匹配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%88Binary-trie%EF%BC%89"><span class="post-toc-text">前置知识（Binary trie）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%89%8D%E7%BC%80%E5%9F%9F"><span class="post-toc-text">自定义前缀域</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%86%85%E7%BD%AEl4-port%E5%89%8D%E7%BC%80%E5%9F%9F"><span class="post-toc-text">内置l4 port前缀域</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A7%84%E5%88%99%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8E%A7%E5%88%B6"><span class="post-toc-text">规则版本号控制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#conjunction%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">conjunction实现</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#SKIPLIST"><span class="post-toc-text">SKIPLIST</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#API-4"><span class="post-toc-text">API</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="post-toc-text">原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#HEAP"><span class="post-toc-text">HEAP</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#API-5"><span class="post-toc-text">API</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#STREAM"><span class="post-toc-text">STREAM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5-stream"><span class="post-toc-text">主动连接(stream)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#API-6"><span class="post-toc-text">API</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#stream-fd"><span class="post-toc-text">stream-fd</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#stream-proto"><span class="post-toc-text">stream-proto</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="post-toc-text">应用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%A2%AB%E5%8A%A8%E8%BF%9E%E6%8E%A5-pstream"><span class="post-toc-text">被动连接(pstream)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#API-7"><span class="post-toc-text">API</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pstream-fd"><span class="post-toc-text">pstream-fd</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pstream-proto"><span class="post-toc-text">pstream-proto</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BA%94%E7%94%A8-2"><span class="post-toc-text">应用</span></a></li></ol></li></ol></li></ol>
            
        
        <div class=".article-gallery"><h1 id="POLL"><a href="#POLL" class="headerlink" title="POLL"></a>POLL</h1><p>对系统调用poll的封装。ovs的IO等待机制，避免忙等待。</p>
<h2 id="POLL-API"><a href="#POLL-API" class="headerlink" title="POLL API"></a>POLL API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册超时时间为msec（相对时间）的定时器，如果msec为负数，则超时时间为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_timer_wait</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> msec)</span>;</span><br><span class="line"><span class="comment">//注册超时时间为when（绝对时间）的定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_timer_wait_until</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> when)</span>;</span><br><span class="line"><span class="comment">//注册超时时间为0（相对时间）的定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_immediate_wake</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//阻塞线程，直到注册的事件(fd or timer)被触发</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_block</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="POLL原理"><a href="#POLL原理" class="headerlink" title="POLL原理"></a>POLL原理</h2><p>每个线程都有自己的<code>poll_loop</code>，里面存储着所有待监听的fd（这些事件是由<code>poll_fd_wait()</code>所注册的）和一个定时器（默认）。</p>
<p>每次执行<code>poll_block()</code>时，调用<code>poll()</code>监听所有待监听的fd，并设置超时时间。<code>poll()</code>返回后，清空重置所有的fd和定时器。因此下次执行<code>poll_block()</code>之前，需要重新将需要监听的事件添加到<code>poll_loop</code>中。</p>
<h1 id="RCU-Read-Copy-Update"><a href="#RCU-Read-Copy-Update" class="headerlink" title="RCU(Read-Copy-Update)"></a>RCU(Read-Copy-Update)</h1><p>ovs用于实现无锁化的一种机制，用于保护指针变量。读写锁模型，多个读者可无锁操作，多个写者需上锁操作（单个写者无需上锁）。</p>
<h2 id="RCU-API"><a href="#RCU-API" class="headerlink" title="RCU API"></a>RCU API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rcu变量类型</span></span><br><span class="line">OVSRCU_TYPE(TYPE)</span><br><span class="line"><span class="comment">//rcu变量初始化，定义时使用</span></span><br><span class="line">OVSRCU_INITIALIZER(VALUE)</span><br><span class="line"><span class="comment">//rcu变量初始化，定义后使用</span></span><br><span class="line">ovsrcu_init(VAR, VALUE)</span><br></pre></td></tr></table></figure>



<p><strong>写者使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置rcu变量，该变量所属的数据结构目前还不能被其他reader看到。比如写者申请一个数据结构并初始化，初始化时该数据结构并不会被其他读者所看见，因为还没有更新到全局数据结构中。此时对该数据结构中的rcu成员设置就可以使用该api</span></span><br><span class="line">ovsrcu_set_hidden(VAR, VALUE)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置rcu变量，设置后该变量就可能被其他reader看到。</span></span><br><span class="line">ovsrcu_set(VAR, VALUE)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取rcu变量，该变量被保护（例如互斥锁）</span></span><br><span class="line">ovsrcu_get_protected(TYPE, VAR)</span><br><span class="line"></span><br><span class="line"><span class="comment">//rcu资源清理函数注册，当所有读者不再引用该变量之后会调用</span></span><br><span class="line">ovsrcu_postpone(FUNCTION, ARG)</span><br></pre></td></tr></table></figure>

<p>例如：写者更新rcu变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ovs_mutex</span> <span class="title">mutex</span> =</span> OVS_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">OVSRCU_TYPE(<span class="keyword">struct</span> flow *) flowp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">change_flow</span><span class="params">(<span class="keyword">struct</span> flow *new_flow)</span></span><br><span class="line">&#123;</span><br><span class="line">             <span class="comment">//多写者时使用互斥机制，防止多个写者获取到相同的rcu变量</span></span><br><span class="line">    ovs_mutex_lock(&amp;mutex);</span><br><span class="line">    ovsrcu_postpone(<span class="built_in">free</span>,</span><br><span class="line">                    ovsrcu_get_protected(<span class="keyword">struct</span> flow *, &amp;flowp));</span><br><span class="line">    ovsrcu_set(&amp;flowp, new_flow);</span><br><span class="line">    ovs_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>读者使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取rcu变量，读者使用</span></span><br><span class="line">ovsrcu_get(TYPE, VAR)</span><br></pre></td></tr></table></figure>



<p><strong>rcu管理函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发静默期，更新当前线程的版本号为global_seqno，并使global_seqno加1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ovsrcu_quiesce</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="comment">//尝试触发静默期，若尝试失败，则返回EBUSY</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ovsrcu_try_quiesce</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//触发静默期，与上面的区别是，在调用start-end期间会将该线程下线，使得管理线程计算宽限期时不考虑该线程</span></span><br><span class="line"><span class="comment">//该线程下线时会使global_seqno加1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ovsrcu_quiesce_start</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//下线</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ovsrcu_quiesce_end</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//上线</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取该线程是否处于静默状态（是否下线）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ovsrcu_is_quiescent</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待宽限期结束（也就是等待所有上线的线程至少触发过一次静默期），这里可以阻塞很久</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ovsrcu_synchronize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//rcu资源回收线程，当ovs处于多线程模式下自动创建</span></span><br><span class="line"><span class="comment">//ovsrcu_quiesce_start和ovsrcu_quiesce会触发，因为这两个函数都将会将要回收的资源同步到全局数据结构中，此时就需要有一个线程来做这些资源的回收</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ovsrcu_postpone_thread</span><span class="params">(<span class="type">void</span> *arg OVS_UNUSED)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//rcu屏障，该函数至少会经历一个宽限期，同时保证所有的旧资源都已经回收完毕。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ovsrcu_barrier</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>rcu屏障的一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rcu_cb</span><span class="params">(<span class="type">void</span> *A)</span> &#123;</span><br><span class="line">    do_something(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_A</span><span class="params">()</span> &#123;</span><br><span class="line">    ovsrcu_postpone(rcu_cb, A); <span class="comment">// will use A later</span></span><br><span class="line">    ovsrcu_barrier(); <span class="comment">// wait for rcu_cb done</span></span><br><span class="line">    do_destroy_A(); <span class="comment">// free A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RCU应用"><a href="#RCU应用" class="headerlink" title="RCU应用"></a>RCU应用</h2><h3 id="rcu-index"><a href="#rcu-index" class="headerlink" title="rcu_index"></a>rcu_index</h3><p>使用整数而不是指针作为rcu变量。在一些需要保护的数据不是指针形式的内容，而是数组成员时很有用。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ovs_mutex</span> <span class="title">mutex</span> =</span> OVS_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">ovsrcu_index port_id;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tx</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id = ovsrcu_index_get(&amp;port_id);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    port_tx(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    ovs_mutex_lock(&amp;mutex);</span><br><span class="line">    id = ovsrcu_index_get_protected(&amp;port_id);</span><br><span class="line">    ovsrcu_index_set(&amp;port_id, <span class="number">-1</span>);</span><br><span class="line">    ovs_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    ovsrcu_synchronize();</span><br><span class="line">    port_delete(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="rcu-list"><a href="#rcu-list" class="headerlink" title="rcu_list"></a>rcu_list</h3><p>与ovs_list使用方法一样</p>
<h2 id="RCU原理"><a href="#RCU原理" class="headerlink" title="RCU原理"></a>RCU原理</h2><ul>
<li>rcu业务线程：每个线程都有一个<code>ovsrcu_perthread</code>，用于记录该线程的版本号和待释放的资源，每当线程触发静默期，都会将该线程的所有待释放的资源放到全局<code>flushed_cbsets</code>中，并更新全局版本号。</li>
<li>rcu管理线程：监控<code>flushed_cbsets</code>的变化（如果有一个非rcu管理线程触发了静默期，则<code>flushed_cbsets</code>发生变化），如果发生了变化，则获取<code>flushed_cbsets</code>上的资源，并等待当前版本的宽限期，宽限期过后进行资源的回收。</li>
</ul>
<blockquote>
<p>如果只有一个rcu业务线程，则不创建rcu管理线程。此时每次线程触发静默期时，相当于经历过了当前的宽限期，该线程直接进行资源的回收</p>
</blockquote>
<p>在进行poll_block时，会触发该线程的静默期：</p>
<ul>
<li>如果poll需要休眠：在休眠前后执行<code>ovsrcu_quiesce_start()</code>和<code>ovsrcu_quiesce_end()</code></li>
<li>如果poll不需要休眠：执行<code>ovsrcu_quiesce()</code></li>
</ul>
<h1 id="LATCH"><a href="#LATCH" class="headerlink" title="LATCH"></a>LATCH</h1><p>一种异步的事件触发机制，用于通知其他线程某个事件发生.</p>
<p>将latch与特定事件绑定，latch通过创建pipe管道，将管道的读侧放到poll中进行监听。当该事件触发时，向管道的写侧写入数据，唤醒poll，监听者就可通过判断读侧是否有数据可读来判断该事件是否发生。</p>
<h2 id="LATCH-API"><a href="#LATCH-API" class="headerlink" title="LATCH API"></a>LATCH API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建pipe管道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">latch_init</span><span class="params">(<span class="keyword">struct</span> latch *)</span>;</span><br><span class="line"><span class="comment">//通过向pipe读侧读取数据来达到重置latch的目的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">latch_poll</span><span class="params">(<span class="keyword">struct</span> latch *)</span>;</span><br><span class="line"><span class="comment">//通过向pipe写侧写入1字节数据来唤醒latch</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">latch_set</span><span class="params">(<span class="keyword">struct</span> latch *)</span>;</span><br><span class="line"><span class="comment">//通过判断pipe读侧是否有数据可读来判断latch是否被唤醒</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">latch_is_set</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> latch *)</span>;</span><br><span class="line"><span class="comment">//将latch放到poll中进行监听</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">latch_wait</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> latch *)</span>;</span><br></pre></td></tr></table></figure>



<p>在ovs中latch一般用于监控线程退出或者功能模块退出这类的事件。</p>
<h1 id="SEQ"><a href="#SEQ" class="headerlink" title="SEQ"></a>SEQ</h1><p>用于监控某类感兴趣的事件或状态的序列号。当事件触发或状态改变时，序列号变化。</p>
<h2 id="SEQ-API"><a href="#SEQ-API" class="headerlink" title="SEQ API"></a>SEQ API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> seq *<span class="title function_">seq_create</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//更新序列号，该行为会唤醒等待序列号更新的监听事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seq_change</span><span class="params">(<span class="keyword">struct</span> seq *seq)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">seq_read</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> seq *seq)</span>;</span><br><span class="line"><span class="comment">//将序列号放到poll中进行监听，当序列号不等于value时被唤醒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">seq_wait</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> seq *seq, <span class="type">uint64_t</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">new_seq = seq_read(seq);</span><br><span class="line"><span class="keyword">if</span> (new_seq != last_seq) &#123;</span><br><span class="line">    ...process changes...</span><br><span class="line">    last_seq = new_seq;</span><br><span class="line">&#125;</span><br><span class="line">seq_wait(seq, new_seq);</span><br><span class="line">pool_block();</span><br></pre></td></tr></table></figure>



<p><code>seq_wait()</code>原理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A sequence number object. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_uint64_t</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">waiters</span> <span class="title">OVS_GUARDED</span>;</span> <span class="comment">/* Contains &#x27;struct seq_waiter&#x27;s. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A thread waiting on a particular seq. */</span></span><br><span class="line"><span class="comment">//在seq中每个线程一个</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_waiter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> <span class="title">hmap_node</span> <span class="title">OVS_GUARDED</span>;</span> <span class="comment">/* In &#x27;seq-&gt;waiters&#x27;. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq</span> *<span class="title">seq</span> <span class="title">OVS_GUARDED</span>;</span>            <span class="comment">/* Seq being waited for. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ovsthread_id OVS_GUARDED;  <span class="comment">/* Key in &#x27;waiters&#x27; hmap. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_thread</span> *<span class="title">thread</span> <span class="title">OVS_GUARDED</span>;</span>  <span class="comment">/* Thread preparing to wait. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_list</span> <span class="title">list_node</span> <span class="title">OVS_GUARDED</span>;</span>  <span class="comment">/* In &#x27;thread-&gt;waiters&#x27;. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> value OVS_GUARDED; <span class="comment">/* seq-&gt;value we&#x27;re waiting to change. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A thread that might be waiting on one or more seqs. */</span></span><br><span class="line"><span class="comment">//每个线程一个，可被多个seq调用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_thread</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_list</span> <span class="title">waiters</span> <span class="title">OVS_GUARDED</span>;</span> <span class="comment">/* Contains &#x27;struct seq_waiter&#x27;s. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">latch</span> <span class="title">latch</span> <span class="title">OVS_GUARDED</span>;</span>  <span class="comment">/* Wakeup latch for this thread. */</span></span><br><span class="line">    <span class="comment">//当waiters为空时，waiting为false</span></span><br><span class="line">    <span class="type">bool</span>  waiting OVS_GUARDED;        <span class="comment">/* True if latch_wait() already called. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>seq_wait()</p>
<ul>
<li>判断该<code>seq</code>中是否存在该线程的<code>seq_waiter</code><ul>
<li>存在：判断此次的<code>value</code>是否等于<code>seq_waiter</code>的<code>value</code><ul>
<li>相等：说明该线程之前已经执行过<code>seq_wait()</code>，直接退出即可</li>
<li>不相等：说明当前需要监听的<code>value</code>已经与之前监听的<code>value</code>不相等，设置poll的超时时间为0，立即唤醒poll</li>
</ul>
</li>
<li>不存在：创建该线程的<code>seq_waiter</code>，将该线程的<code>latch</code>放到poll中进行监听</li>
</ul>
</li>
</ul>
<p>seq_change()</p>
<ul>
<li>更新<code>seq</code></li>
<li>唤醒该<code>seq</code>中所有的<code>waiter</code>(通过向<code>waiter</code>所属线程的<code>latch</code>执行<code>latch_set()</code>达到)</li>
<li>删除该<code>seq</code>中所有的<code>waiter</code></li>
</ul>
<p>poll_block()</p>
<ul>
<li>被唤醒后，删除该线程的所有的<code>waiter</code></li>
<li>将该线程的<code>latch</code>复位，清除<code>waiting</code>标记</li>
</ul>
<h1 id="COVERAGE"><a href="#COVERAGE" class="headerlink" title="COVERAGE"></a>COVERAGE</h1><p>ovs用来追踪事件的更新频率</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ovs-appctl coverage/show</span><br><span class="line">ovs-appctl coverage/read-counter XXX</span><br></pre></td></tr></table></figure>



<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COVERAGE_DEFINE(COUNTER);</span><br><span class="line">COVERAGE_INC(COUNTER);</span><br><span class="line">COVERAGE_ADD(COUNTER);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将该线程的coverage同步到全局变量中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">coverage_clear</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//上锁失败则不同步，用在pmd线程中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">coverage_try_clear</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新counter数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">coverage_run</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>



<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每个counter都会对应一个全局变量和N个每线程变量</p>
<ul>
<li><p>全局变量：<code>struct coverage_counter</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A coverage counter. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coverage_counter</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> name;            <span class="comment">/* Textual name. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*<span class="type">const</span> count)</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* Gets, zeros this thread&#x27;s count. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> total;      <span class="comment">/* Total count. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> last_total;</span><br><span class="line">    <span class="comment">/* The moving average arrays. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> min[MIN_AVG_LEN];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hr[HR_AVG_LEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每线程变量：<code>unsigned int</code></p>
</li>
</ul>
<p>每个线程通过周期性调用<code>coverage_clear()/coverage_try_clear()</code>将线程的私有计数同步到该counter的全局变量中，每<code>COVERAGE_CLEAR_INTERVAL</code>（1秒）执行一次。</p>
<p><code>coverage_run()</code>执行真正的计数统计，每<code>COVERAGE_RUN_INTERVAL</code>（5秒）执行一次，该值可以修改，但必须能够被6000（60秒）整除，因为counter的全局变量中<code>min</code>数组存储着最后一分钟的计数，该数组将一分钟分成<code>6000/COVERAGE_RUN_INTERVAL</code>份，每份存储<code>COVERAGE_RUN_INTERVAL</code>间隔的counter计数。同理<code>hr</code>数组存储着最后一小时的计数，该数组被分为<code>HR_AVG_LEN</code>（60）份，每份存储间隔一分钟的counter计数。</p>
<p><code>idx_count</code>确定了<code>min</code>和<code>hr</code>数组当前的索引，更新的统计会存放在<code>idx_count</code>及其后面的索引中，类似一个环。</p>
<p>例如当<code>COVERAGE_RUN_INTERVAL</code>为12s时，min中数据的分布如下：</p>
<p> <a href="/images/coverage_min.svg" title="coverage_min" class="gallery-item" style="box-shadow: none;"> <img src="/images/coverage_min.svg" alt="coverage_min"></a></p>
<p>poll_block()</p>
<ul>
<li>在执行<code>poll()</code>之前调用<code>coverage_clear()</code>和<code>coverage_run()</code></li>
</ul>
<h1 id="PVECTOR-Concurrent-Priority-Vector"><a href="#PVECTOR-Concurrent-Priority-Vector" class="headerlink" title="PVECTOR(Concurrent Priority Vector)"></a>PVECTOR(Concurrent Priority Vector)</h1><p>单写者，多读者的优先级数组，优先级高的排在数组的前面。因为其数据结构为数组，所以支持成员预取来提升性能。</p>
<p>pvector内部使用两个优先级数组：</p>
<ul>
<li>impl：已发布的数组，该数组被读者可见</li>
<li>temp：临时数组，保存着最新的数据，该数组仅被写者可见。只有当执行<code>pvector_publish()</code>后，该数组才会更新到<code>impl</code>中。</li>
</ul>
<h2 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pvector_init</span><span class="params">(<span class="keyword">struct</span> pvector *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可能将其更新到temp数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pvector_insert</span><span class="params">(<span class="keyword">struct</span> pvector *, <span class="type">void</span> *, <span class="type">int</span> priority)</span>;</span><br><span class="line"><span class="comment">//可能将其更新到temp数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pvector_change_priority</span><span class="params">(<span class="keyword">struct</span> pvector *, <span class="type">void</span> *, <span class="type">int</span> priority)</span>;</span><br><span class="line"><span class="comment">//将其更新到temp数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pvector_remove</span><span class="params">(<span class="keyword">struct</span> pvector *, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将最新修改的temp数组发布到impl中，此后的读者可以遍历到最新的pvector</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">pvector_publish</span><span class="params">(<span class="keyword">struct</span> pvector *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Count.  These operate on the published pvector. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">pvector_count</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pvector *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">pvector_is_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pvector *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按从高到低的优先级遍历</span></span><br><span class="line">PVECTOR_FOR_EACH(PTR, PVECTOR)</span><br><span class="line"><span class="comment">//按从高到低的优先级遍历，其中遍历到的优先级需要大于等于PRIORITY。在遍历过程中预取N个元素，每个元素的大小为SZ</span></span><br><span class="line">PVECTOR_FOR_EACH_PRIORITY(PTR, PRIORITY, N, SZ, PVECTOR)</span><br></pre></td></tr></table></figure>



<h1 id="CMAP-Concurrent-hash-map"><a href="#CMAP-Concurrent-hash-map" class="headerlink" title="CMAP(Concurrent hash map)"></a>CMAP(Concurrent hash map)</h1><p> 单写者，多读者的hash表，一个key可对应多个value（允许重复key的插入）。使用cuckoo hash实现。</p>
<p>cmap的大小是动态扩充的，当cmap的容量大于85%时，将容量扩充为之前的二倍，当小于20%时，将容量缩减为之前的一半。</p>
<h2 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cmap_init</span><span class="params">(<span class="keyword">struct</span> cmap *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">cmap_insert</span><span class="params">(<span class="keyword">struct</span> cmap *, <span class="keyword">struct</span> cmap_node *, <span class="type">uint32_t</span> hash)</span>;</span><br><span class="line"><span class="comment">//调用cmap_replace()，new_node为NULL</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">cmap_remove</span><span class="params">(<span class="keyword">struct</span> cmap *, <span class="keyword">struct</span> cmap_node *,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> hash)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">cmap_replace</span><span class="params">(<span class="keyword">struct</span> cmap *, <span class="keyword">struct</span> cmap_node *old_node,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> cmap_node *new_node, <span class="type">uint32_t</span> hash)</span>;</span><br><span class="line"><span class="comment">//遍历CMAP中key为HASH的所有value</span></span><br><span class="line">CMAP_FOR_EACH_WITH_HASH(NODE, MEMBER, HASH, CMAP)</span><br><span class="line"><span class="comment">//遍历CMAP中所有key的所有value</span></span><br><span class="line">CMAP_FOR_EACH(NODE, MEMBER, CMAP)</span><br></pre></td></tr></table></figure>



<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The implementation of a concurrent hash map. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmap_impl</span> &#123;</span></span><br><span class="line">    <span class="comment">//第一个cacheline，记录基本的cmap信息</span></span><br><span class="line">    PADDED_MEMBERS_CACHELINE_MARKER(CACHE_LINE_SIZE, cacheline0,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> n;             <span class="comment">/* Number of in-use elements. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> max_n;         <span class="comment">/* Max elements before enlarging. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> min_n;         <span class="comment">/* Min elements before shrinking. */</span></span><br><span class="line">        <span class="type">uint32_t</span> mask;              <span class="comment">/* Number of &#x27;buckets&#x27;, minus one. */</span></span><br><span class="line">        <span class="type">uint32_t</span> basis;             <span class="comment">/* Basis for rehashing client&#x27;s</span></span><br><span class="line"><span class="comment">                                       hash values. */</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二个cacheline，用于存储键值对的hash表</span></span><br><span class="line">    PADDED_MEMBERS_CACHELINE_MARKER(CACHE_LINE_SIZE, cacheline1,</span><br><span class="line">        <span class="keyword">struct</span> cmap_bucket buckets[<span class="number">1</span>];</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A cuckoo hash bucket.  Designed to be cache-aligned and exactly one cache</span></span><br><span class="line"><span class="comment"> * line long. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmap_bucket</span> &#123;</span></span><br><span class="line">    <span class="comment">//保证了每个bucket只占用一个cacheline，CMAP_K的选取使得一个cmap_bucket刚好一个cacheline</span></span><br><span class="line">    <span class="comment">/* Padding to make cmap_bucket exactly one cache line long. */</span></span><br><span class="line">    PADDED_MEMBERS(CACHE_LINE_SIZE,</span><br><span class="line">        <span class="comment">/* Allows readers to track in-progress changes.  Initially zero, each</span></span><br><span class="line"><span class="comment">         * writer increments this value just before and just after each change</span></span><br><span class="line"><span class="comment">         * (see cmap_set_bucket()).  Thus, a reader can ensure that it gets a</span></span><br><span class="line"><span class="comment">         * consistent snapshot by waiting for the counter to become even (see</span></span><br><span class="line"><span class="comment">         * read_even_counter()), then checking that its value does not change</span></span><br><span class="line"><span class="comment">         * while examining the bucket (see cmap_find()). */</span></span><br><span class="line">        <span class="comment">//在插入键值对前和插入键值对后都加1，读者在进行hash查找时，等待counter值为偶数（因为一次完整的插入操作会使得counter加2），然后查找前记录counter值，查找后再判断是否与之前记录的counter值相等。如果相等，则查找成功，否则重新查找。</span></span><br><span class="line">        <span class="type">atomic_uint32_t</span> counter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (hash, node) slots.  They are parallel arrays instead of an array of</span></span><br><span class="line"><span class="comment">         * structs to reduce the amount of space lost to padding.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The slots are in no particular order.  A null pointer indicates that</span></span><br><span class="line"><span class="comment">         * a pair is unused.  In-use slots are not necessarily in the earliest</span></span><br><span class="line"><span class="comment">         * slots. */</span></span><br><span class="line">        <span class="comment">//key</span></span><br><span class="line">        <span class="type">uint32_t</span> hashes[CMAP_K];</span><br><span class="line">        <span class="comment">//value</span></span><br><span class="line">        <span class="keyword">struct</span> cmap_node nodes[CMAP_K];</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>hash冲突解决：</p>
<ul>
<li>使用两个hash函数：使用两个hash函数计算hash桶的索引。与dpdk的cuckoo hash不同，这两个hash函数所计算出来的hash值可能相同</li>
<li>多路组相联：每个bucket最多存储<code>CMAP_K</code>个不同的key</li>
</ul>
<p>hash插入：</p>
<ol>
<li><p>若需要扩容（已用key数量&gt;&#x3D;85%）：则对hash进行扩容，扩容期间会将旧的hash表中的所有的条目重新插入到新的hash表中</p>
</li>
<li><p>计算待插入键值对的索引，找到一个有空闲位置的bucket并插入</p>
</li>
<li><p>若找不到空闲位置的bucket：利用BFS查找最短Cuckoo Kick路径，找到后从尾到头移动键值对，最后插入待插入的键值对</p>
</li>
<li><p>若查找Cuckoo Kick路径失败（路径长度大于4）：则修改hash函数种子，并重新生成hash表，跳到第二步</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS路径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmap_path</span> &#123;</span></span><br><span class="line">    	<span class="comment">//kick路径所访问的第一个bucket</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmap_bucket</span> *<span class="title">start</span>;</span> <span class="comment">/* First bucket along the path. */</span></span><br><span class="line">    	<span class="comment">//kick路径所访问的最后一个bucket</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmap_bucket</span> *<span class="title">end</span>;</span>   <span class="comment">/* Last bucket on the path. */</span></span><br><span class="line">    	<span class="comment">//kick路径的记录</span></span><br><span class="line">    	<span class="comment">//该kick路径第一个bucket通过slots[0]访问到第二个bucket,第二个bucket通过slots[1]访问到第三个bucket，以此类推</span></span><br><span class="line">        <span class="type">uint8_t</span> slots[MAX_DEPTH];  <span class="comment">/* Slots used for each hop. */</span></span><br><span class="line">    	<span class="comment">//kick路径的长度，最大路径长度为MAX_DEPTH</span></span><br><span class="line">        <span class="type">int</span> n;                     <span class="comment">/* Number of slots[]. */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS访问队列，用于存储待访问的节点，保证按层级顺序访问。当tail=head时BFS遍历完成</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmap_path</span> <span class="title">queue</span>[<span class="title">MAX_QUEUE</span>];</span></span><br><span class="line"><span class="comment">//队列头部，从头部插入待访问的path节点，每插入一个path节点head+1</span></span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//队列尾部，从尾部遍历已插入的path节点，每访问一个path节点tail+1</span></span><br><span class="line"><span class="type">int</span> tail = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="CCMAP"><a href="#CCMAP" class="headerlink" title="CCMAP"></a>CCMAP</h2><p>cmap的一个变体，单写者，多读者的hash表，其中value只记录插入到ccmap中的该key的个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ccmap_init</span><span class="params">(<span class="keyword">struct</span> ccmap *)</span>;</span><br><span class="line"><span class="comment">//插入到ccmap中的key的个数，包含重复的key</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ccmap_count</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ccmap *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">ccmap_is_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ccmap *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写者调用</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ccmap_inc</span><span class="params">(<span class="keyword">struct</span> ccmap *, <span class="type">uint32_t</span> hash)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ccmap_dec</span><span class="params">(<span class="keyword">struct</span> ccmap *, <span class="type">uint32_t</span> hash)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读者调用</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ccmap_find</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ccmap *, <span class="type">uint32_t</span> hash)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="HMAP"><a href="#HMAP" class="headerlink" title="HMAP"></a>HMAP</h1><p>hash表，线程不安全，需要用锁来保护hash表。使用数组实现。因为hmap的key本身就是hash值，所以其他种类的键值对的hash表会基于hmap去实现。</p>
<p>hash冲突：采用链地址法。</p>
<p>每次调整容量时，都会将hmap设置为当前条目数向上取整至2的指数次方。</p>
<h2 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hmap_init</span><span class="params">(<span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">hmap_count</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">hmap_is_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hmap_contains</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *, <span class="type">const</span> <span class="keyword">struct</span> hmap_node *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量不够会自动扩容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_insert</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="keyword">struct</span> hmap_node *, <span class="type">size_t</span> hash)</span>;</span><br><span class="line"><span class="comment">//不会自动缩容</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hmap_remove</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="keyword">struct</span> hmap_node *)</span>;</span><br><span class="line"><span class="comment">//手动扩容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_reserve</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="type">size_t</span> capacity)</span>;</span><br><span class="line"><span class="comment">//手动缩容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_shrink</span><span class="params">(<span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="comment">//遍历HMAP中key为HASH的所有的value</span></span><br><span class="line">HMAP_FOR_EACH_WITH_HASH(NODE, MEMBER, HASH, HMAP)</span><br><span class="line"><span class="comment">//遍历HMAP中所有的value</span></span><br><span class="line">HMAP_FOR_EACH(NODE, MEMBER, HMAP)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当遍历时可能删除当前获得的条目时，可使用该宏，根据参数个数的不同分为长短两个版本</span></span><br><span class="line"><span class="comment">//长版本4个参数，可获取当前条目的下一个条目，对应HMAP_FOR_EACH_SAFE_LONG(NODE, NEXT, MEMBER, HMAP)</span></span><br><span class="line"><span class="comment">//短版本3个参数，更常用一些对应HMAP_FOR_EACH_SAFE_SHORT(NODE, MEMBER, HMAP)</span></span><br><span class="line">HMAP_FOR_EACH_SAFE(...)</span><br><span class="line"><span class="comment">//从HMAP中将插入的条目依次拿出，直到HMAP为空</span></span><br><span class="line">HMAP_FOR_EACH_POP(NODE, MEMBER, HMAP)</span><br></pre></td></tr></table></figure>



<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h3><p>hash表，key类型为字符串，value类型为字符串。部分api支持不同类型的value，api内部会将其转为字符串。</p>
<h3 id="simap"><a href="#simap" class="headerlink" title="simap"></a>simap</h3><p>hash表，key类型为字符串，value类型为数字。</p>
<h3 id="shash"><a href="#shash" class="headerlink" title="shash"></a>shash</h3><p>hash表，key类型为字符串，value类型为指针。</p>
<h3 id="sset"><a href="#sset" class="headerlink" title="sset"></a>sset</h3><p>集合，用于存储字符串。</p>
<h3 id="hmapx"><a href="#hmapx" class="headerlink" title="hmapx"></a>hmapx</h3><p>集合，用于存储指针。</p>
<h3 id="id-pool"><a href="#id-pool" class="headerlink" title="id_pool"></a>id_pool</h3><p>id池，用于id分配。</p>
<h1 id="CLS-CLASSIFIER"><a href="#CLS-CLASSIFIER" class="headerlink" title="CLS(CLASSIFIER)"></a>CLS(CLASSIFIER)</h1><p>slowpath的报文分类器，根据下发的规则，对输入flow进行匹配，返回命中的规则并设置该次匹配所感兴趣的掩码（如果有需要的话）。这个掩码为fastpath所用，fastpath会根据掩码下发并生成fastpath规则，使后面类似的流量（掩码后命中fastpath规则）进行快转。</p>
<h2 id="CLS-API"><a href="#CLS-API" class="headerlink" title="CLS API"></a>CLS API</h2><p>cls初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">classifier_init</span><span class="params">(<span class="keyword">struct</span> classifier *, <span class="type">const</span> <span class="type">uint8_t</span> *flow_segments)</span>;</span><br></pre></td></tr></table></figure>

<p>flow_segments为一个数组，每个元素表示分段点在flow中的偏移（8字节为一个单位），数组最后一个元素的值一定是整个flow的大小（8字节为一个单位）。</p>
<p>flow_segments会影响cls构建的行为，在构建时通过对flow进行分段，加速了匹配过程，使得对于无法命中规则的flow能够更快速的确定。</p>
<p>cls规则初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cls_rule_init</span><span class="params">(<span class="keyword">struct</span> cls_rule *rule, <span class="type">const</span> <span class="keyword">struct</span> match *match, <span class="type">int</span> priority)</span>；</span><br></pre></td></tr></table></figure>



<p>cls规则插入函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cls_conjunction</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> id;	<span class="comment">//conjunction_id</span></span><br><span class="line">    <span class="type">uint8_t</span> clause;	<span class="comment">//表明该规则为conjunction_id的第几个维度</span></span><br><span class="line">    <span class="type">uint8_t</span> n_clauses;<span class="comment">//表明该conjunction_id总共有几个维度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Inserts &#x27;rule&#x27; into &#x27;cls&#x27;.  Until &#x27;rule&#x27; is removed from &#x27;cls&#x27;, the caller</span></span><br><span class="line"><span class="comment"> * must not modify or free it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;cls&#x27; must not contain an identical rule (including wildcards, values of</span></span><br><span class="line"><span class="comment"> * fixed fields, and priority).  Use classifier_find_rule_exactly() to find</span></span><br><span class="line"><span class="comment"> * such a rule. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">classifier_insert</span><span class="params">(<span class="keyword">struct</span> classifier *, <span class="type">const</span> <span class="keyword">struct</span> cls_rule *,</span></span><br><span class="line"><span class="params">                       <span class="type">ovs_version_t</span>, <span class="type">const</span> <span class="keyword">struct</span> cls_conjunction *,</span></span><br><span class="line"><span class="params">                       <span class="type">size_t</span> n_conjunctions)</span>;</span><br></pre></td></tr></table></figure>

<p>conjunction是可选功能，用于ovs的conjunction功能实现</p>
<p>cls规则匹配函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Finds and returns the highest-priority rule in &#x27;cls&#x27; that matches &#x27;flow&#x27; and</span></span><br><span class="line"><span class="comment"> * that is visible in &#x27;version&#x27;.  Returns a null pointer if no rules in &#x27;cls&#x27;</span></span><br><span class="line"><span class="comment"> * match &#x27;flow&#x27;.  If multiple rules of equal priority match &#x27;flow&#x27;, returns one</span></span><br><span class="line"><span class="comment"> * arbitrarily.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If a rule is found and &#x27;wc&#x27; is non-null, bitwise-OR&#x27;s &#x27;wc&#x27; with the</span></span><br><span class="line"><span class="comment"> * set of bits that were significant in the lookup.  At some point</span></span><br><span class="line"><span class="comment"> * earlier, &#x27;wc&#x27; should have been initialized (e.g., by</span></span><br><span class="line"><span class="comment"> * flow_wildcards_init_catchall()).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;flow&#x27; is non-const to allow for temporary modifications during the lookup.</span></span><br><span class="line"><span class="comment"> * Any changes are restored before returning.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;conj_flows&#x27; is an optional parameter.  If it is non-null, the matching</span></span><br><span class="line"><span class="comment"> * conjunctive flows are inserted. */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> cls_rule *</span><br><span class="line"><span class="title function_">classifier_lookup</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> classifier *cls, <span class="type">ovs_version_t</span> version,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> flow *flow, <span class="keyword">struct</span> flow_wildcards *wc,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> hmapx *conj_flows)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="CLS应用"><a href="#CLS应用" class="headerlink" title="CLS应用"></a>CLS应用</h2><h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>使用cls来存储<code>router</code>规则。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ovs_router_entry</span> &#123;</span></span><br><span class="line">    <span class="comment">//router规则，匹配目的ip地址和pkt_mark</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cls_rule</span> <span class="title">cr</span>;</span></span><br><span class="line">    <span class="type">char</span> output_netdev[IFNAMSIZ];	<span class="comment">//出接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">gw</span>;</span>				<span class="comment">//下一跳ip</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">nw_addr</span>;</span>		<span class="comment">//目的ip</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">src_addr</span>;</span>		<span class="comment">//源ip，是出接口上地址（ovs进行路由转发时，如果未指定源ip，则使用该ip作为源。比如构造隧道流量时未指定源隧道ip）</span></span><br><span class="line">    <span class="type">uint8_t</span> plen;					<span class="comment">//前缀掩码长度</span></span><br><span class="line">    <span class="type">uint8_t</span> priority;				<span class="comment">//plen+32，若为local路由，则plen+64</span></span><br><span class="line">    <span class="type">bool</span> local;						<span class="comment">//是否为local路由</span></span><br><span class="line">    <span class="type">uint32_t</span> mark;					<span class="comment">//pkt_mark，可用于策略路由的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>router规则插入</strong>：</p>
<p><code>router</code>规则添加有下面两种触发方式：</p>
<ul>
<li><p>由system触发：使用netlink周期性获取kernel的路由表，转换为<code>router</code>规则并同步到cls中</p>
</li>
<li><p>由user触发：下发<code>ovs-appctl ovs/route/add</code>命令，将路由信息转换为<code>router</code>规则并同步到cls中</p>
</li>
</ul>
<p><strong>router规则查找</strong>：</p>
<p>当slowpath执行output动作时：</p>
<ul>
<li><p>如果output接口为tunnel接口（比如vxlan接口），对flow进行预处理</p>
<ul>
<li>如果tunnel接口配置了local_ip（非flow），设置隧道源ip</li>
<li>如果tunnel接口配置了remote_ip（非flow），设置隧道目的ip</li>
<li>如果tunnel接口配置了out_ley（非flow），则设置vni</li>
<li>……</li>
</ul>
</li>
<li><p>若配置了隧道源ip，将其作为目的ip进行router查找，如果未找到或者找到的路由表项不是local的，则路由查找失败。（这一步保证了隧道源ip的有效性）</p>
<blockquote>
<p>路由表项为local的，表明该路由可送往本机</p>
</blockquote>
</li>
<li><p>获取隧道目的ip进行router查找</p>
</li>
<li><p>若找到路由表项，如果没有设置隧道源ip，则设置隧道源ip为路由表项的源ip</p>
</li>
<li><p>构建隧道信息（外层头源目的mac，出接口，隧道类型等），设置fastpath的action为tunnel_push，由fastpath进行隧道的封装</p>
</li>
</ul>
<h3 id="tnl（tunnel）"><a href="#tnl（tunnel）" class="headerlink" title="tnl（tunnel）"></a>tnl（tunnel）</h3><p>使用cls来存储<code>tnl_port_map</code>规则，该规则是根据下面两个链表中的信息相互组合所形成的</p>
<ul>
<li><p>addr_list：存储着所有路由出接口的ip和mac信息（出接口一般为桥接口）</p>
</li>
<li><p>port_list：存储着所有的tunnel接口信息（包括tunnel的l4协议，l4目的端口）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnl_port_in</span> &#123;</span></span><br><span class="line">    <span class="comment">//tnl_port_map规则，匹配下面的flow字段：</span></span><br><span class="line">    <span class="comment">//目的mac、目的ip（addr_list中获取）</span></span><br><span class="line">    <span class="comment">//l4协议号及l4目的端口（port_list中获取）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cls_rule</span> <span class="title">cr</span>;</span></span><br><span class="line">    <span class="type">odp_port_t</span> portno;			<span class="comment">//tunnel接口的id</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_refcount</span> <span class="title">ref_cnt</span>;</span></span><br><span class="line">    <span class="type">char</span> dev_name[IFNAMSIZ];	<span class="comment">//tunnel接口名称，show命令用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>tnl_port_map规则插入</strong>：</p>
<p><code>tnl_port_map</code>规则添加有下面两种触发方式：</p>
<ul>
<li><p>添加路由时，将路由出接口信息（ip、mac）更新到<code>addr_list</code>中，触发<code>tnl_port_map</code>规则的更新</p>
</li>
<li><p>添加tnl接口时，将tnl接口信息（l4 proto_no， l4 dst_port）更新到<code>port_list</code>中，触发<code>tnl_port_map</code>规则的更新</p>
</li>
</ul>
<p><strong>tnl_port_map规则查找</strong>：</p>
<p>当slowpath执行output动作时：</p>
<ul>
<li><p>如果output接口存在ip（比如LOCAL），且存在tunnel口，则进行<code>tnl_port_map</code>查找</p>
</li>
<li><p>查找到对应的<code>tnl_port_map</code>规则，说明是隧道流量，设置fastpath的action为tunnel_pop，由fastpath进行隧道的解封装</p>
</li>
</ul>
<h3 id="openflow-table"><a href="#openflow-table" class="headerlink" title="openflow table"></a>openflow table</h3><p>使用cls来实现openflow table</p>
<h2 id="CLS原理"><a href="#CLS原理" class="headerlink" title="CLS原理"></a>CLS原理</h2><p>cls主要是利用hash表来进行规则的插入和查找。</p>
<p><strong>cls规则分为三部分组成</strong>：</p>
<ul>
<li>cls_flow：记录规则匹配的内容</li>
<li>cls_mask：记录规则感兴趣的匹配项</li>
<li>cls_priority：记录规则优先级</li>
</ul>
<p>当一个flow送入cls中进行规则匹配时，首先需要将flow与cls规则中的<code>cls_mask</code>相与，得到的匹配串再与<code>cls_flow &amp; cls_mask</code>进行比较，若相等，则命中该规则，若不相等，则未命中该规则。</p>
<p>由于规则匹配时，flow必须与<code>cls_mask</code>相与后才能进行下一步匹配，所以cls将cls规则按照<code>cls_mask</code>分到不同的组中。这样，每组中的<code>cls_mask</code>都相同，flow只需要与<code>cls_mask</code>相与一次，就可以与该组中所有的cls规则进行比较了。这个组在cls中被称为subtable。</p>
<p><strong>subtable构成</strong>：</p>
<ul>
<li>max_priority：表示该subtable中优先级最高的规则的优先级</li>
<li>index_maps：整个数组存储着该subtable的mask（至于为什么使用数组存，后面的分段hash匹配有讲到）</li>
<li>rules：hash表，key为<code>cls_flow &amp; cls_mask</code>的hash值，value为cls规则</li>
</ul>
<p>下面是cls中subtable的具体实现，其大部分字段为之后所介绍的掩码优化所用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cls_subtable</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmap_node</span> <span class="title">cmap_node</span>;</span>    <span class="comment">/* Within classifier&#x27;s &#x27;subtables_map&#x27;. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These fields are only used by writers. */</span></span><br><span class="line">    <span class="type">int</span> max_priority;              <span class="comment">/* Max priority of any rule in subtable. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_count;        <span class="comment">/* Count of max_priority rules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accessed by iterators. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rculist</span> <span class="title">rules_list</span>;</span>              <span class="comment">/* Unordered. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Identical, but lower priority rules are not inserted to any of the</span></span><br><span class="line"><span class="comment">     * following data structures. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These fields are accessed by readers who care about wildcarding. */</span></span><br><span class="line">    <span class="comment">//subtable将mask_flow分为多个不为0的分段掩码，每个分段掩码对应一个index_maps</span></span><br><span class="line">    <span class="comment">//查找时按照分段掩码进行分段hash查找，该字段就表明了该subtable需要进行几次的分段查找</span></span><br><span class="line">    <span class="comment">//(这里的查找次数为分段掩码个数-1)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> n_indices;                   <span class="comment">/* How many indices to use. */</span></span><br><span class="line">    <span class="comment">//存储分段掩码</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">flowmap</span> <span class="title">index_maps</span>[<span class="title">CLS_MAX_INDICES</span> + 1];</span> <span class="comment">/* Stage maps. */</span></span><br><span class="line">    <span class="comment">//该subtable的mask在trie树的前缀掩码长度，如果不是前缀掩码，则为0，该trie不生效</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> trie_plen[CLS_MAX_TRIES];  <span class="comment">/* Trie prefix length in &#x27;mask&#x27;</span></span><br><span class="line"><span class="comment">                                             * (runtime configurable). */</span></span><br><span class="line">    <span class="comment">//l4层的port_src + port_dst</span></span><br><span class="line">    <span class="comment">//因为前缀掩码可能不连续，因此在插入和匹配时与掩码相与，保证trie的正确性</span></span><br><span class="line">    <span class="comment">//前缀长度为MSB到LSB set之间长度（例：0b001000的前缀长度为3）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ports_mask_len;</span><br><span class="line">    <span class="comment">//用于存储分段hash，每个分段所计算出来的hash值包含前面分段的部分的hash值</span></span><br><span class="line">    <span class="comment">//因此最后一个分段的hash值在这里并没有存储，因为最后一个分段的hash值就是整个miniflow的hash值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ccmap</span> <span class="title">indices</span>[<span class="title">CLS_MAX_INDICES</span>];</span>  <span class="comment">/* Staged lookup indices. */</span></span><br><span class="line">    <span class="comment">//port的掩码可能非前缀，所以这里将插入和匹配的数据与掩码相与，保证非前缀掩码不会影响到trie的使用</span></span><br><span class="line">    rcu_trie_ptr ports_trie;                <span class="comment">/* NULL if none. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These fields are accessed by all readers. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmap</span> <span class="title">rules</span>;</span>                      <span class="comment">/* Contains &#x27;cls_match&#x27;es. */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">minimask</span> <span class="title">mask</span>;</span>             <span class="comment">/* Wildcards for fields. */</span></span><br><span class="line">    <span class="comment">/* &#x27;mask&#x27; must be the last field. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>cls规则插入流程</strong>：</p>
<ul>
<li>根据cls_mask查找对应的subtable，若未找到，则创建一个新的subtable</li>
<li>若找到subtable，则计算该cls的hash值，并将其插入到subtable中。如果该cls规则是该subtable中优先级最高的规则，则更新subtable的<code>max_priority</code></li>
</ul>
<p><strong>cls匹配流程</strong>：</p>
<ul>
<li>设置local_priority为最小</li>
<li>按照优先级从高到低遍历subtable，其中subtable的最小优先级要大于local_priority</li>
<li>将待匹配的flow跟subtable的mask相与，而后计算hash值，在<code>rules</code>中进行hash查找</li>
<li>若找到规则，且优先级比local_priority大，则记录所命中的cls规则，更新local_priority为所命中的cls规则的优先级</li>
<li>跳到第二步，直到没有可访问的subtable为止</li>
<li>此时所记录的cls规则为最终所命中的cls规则</li>
</ul>
<h3 id="掩码优化"><a href="#掩码优化" class="headerlink" title="掩码优化"></a>掩码优化</h3><p>主要用于规则匹配失败时wc掩码的设置（基于subtable的，因为该flow可能在某个低优先级的subtable中命中，而在比他高优先级的subtable中未命中）。</p>
<h4 id="分段hash匹配"><a href="#分段hash匹配" class="headerlink" title="分段hash匹配"></a>分段hash匹配</h4><p>根据flow结构体的成员分布，将flow分为4段：</p>
<ul>
<li>Metadata数据段</li>
<li>L2数据段</li>
<li>L3数据段</li>
<li>L4数据段</li>
</ul>
<p>在subtable创建时，将该subtable的掩码按照上面的描述分为n段（跳过掩码为0的数据段，最多4段），存到<code>index_maps</code>中</p>
<p><strong>规则插入时</strong>：</p>
<ul>
<li>根据规则的mask找到对应的subtable</li>
<li>依次计算前n段的hash，并插入到<code>indices</code>中（这里不包括最后一段，因为包括了最后一段就是整个flow的hash，而这个hash值已经作为key被插入到subtable的<code>rules</code>中）</li>
</ul>
<p><strong>规则查找时</strong>：</p>
<ul>
<li>根据flow的mask找到对应的subtable</li>
<li>通过前缀域检查（优化2）</li>
<li>根据该subtable的分段掩码，计算该flow前n段掩码后的hash，并在<code>indices</code>中查找<ul>
<li>若查找失败，则将wc设置为该subtable前n段的掩码</li>
<li>若查找成功，则将wc设置为该subtable的掩码，并返回命中的cls规则</li>
</ul>
</li>
</ul>
<h4 id="前缀域匹配"><a href="#前缀域匹配" class="headerlink" title="前缀域匹配"></a>前缀域匹配</h4><h5 id="前置知识（Binary-trie）"><a href="#前置知识（Binary-trie）" class="headerlink" title="前置知识（Binary trie）"></a>前置知识（Binary trie）</h5><p>前缀二叉树，一种用于快速检索的二叉树结构，其基本性质如下：</p>
<ul>
<li>节点存储最多32位的前缀信息和该节点可命中的规则数</li>
<li>节点指向左孩子的边代表下一个节点的前缀信息的最高位为0，指向右孩子的边代表下一个节点的前缀信息的最高位为1</li>
<li>根节点中的前缀信息为前缀串的第一位为MSB，叶节点中的前缀信息的最后一位为LSB</li>
<li>根节点的前缀信息可能为空</li>
<li>从根节点到某一结点，路径上经过节点的前缀信息连接起来，为该节点对应的完整的前缀串</li>
</ul>
<p>例：添加三条规则到trie中</p>
<table>
<thead>
<tr>
<th>rule1</th>
<th>rule2</th>
<th>rule3</th>
</tr>
</thead>
<tbody><tr>
<td>0b1011&#x2F;0b1111</td>
<td>0b1011&#x2F;0b1000</td>
<td>0b0100&#x2F;0b1100</td>
</tr>
</tbody></table>
<p>构建的binary trie如下：</p>
<p><a href="/images/binary_trie.svg" title="binary_trie" class="gallery-item" style="box-shadow: none;"> <img src="/images/binary_trie.svg" alt="binary_trie"></a></p>
<h5 id="自定义前缀域"><a href="#自定义前缀域" class="headerlink" title="自定义前缀域"></a>自定义前缀域</h5><p>通过API来设置cls的trie，在规则匹配时用于生成匹配失败的wc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cls自定义前缀域设置，这些前缀域可以使得匹配后所生成的掩码更小，保证了所下发的fastpath规则尽可能的聚合。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">classifier_set_prefix_fields</span><span class="params">(<span class="keyword">struct</span> classifier *,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="keyword">enum</span> mf_field_id *trie_fields,</span></span><br><span class="line"><span class="params">                                  <span class="type">unsigned</span> <span class="type">int</span> n_trie_fields)</span>;</span><br></pre></td></tr></table></figure>

<p>trie是基于cls的，每个trie对应一个meta-flow field，目前最多支持4个trie，一般为<code>ipv4_src、ipv4_dst、ipv6_src、ipv6_dst</code>。</p>
<blockquote>
<p>trie所对应的field在规则中一定要使用前缀掩码，否则该规则所处的subtable中的trie的前缀长度为0，无法生成聚合的wc</p>
</blockquote>
<p><strong>规则插入时对trie的操作</strong>：</p>
<ul>
<li>根据规则的mask，查找对应的subtable。subtable中存储着该trie的前缀长度（因为subtable中所有的规则的掩码都相同，所以trie的前缀长度是由subtable存储）</li>
<li>根据subtable中对该trie的前缀长度，获取该规则对应前缀域的前缀串，并插入trie中</li>
</ul>
<p><strong>规则匹配时对trie的操作</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prefix tree context.  Valid when &#x27;lookup_done&#x27; is true.  Can skip all</span></span><br><span class="line"><span class="comment"> * subtables which have a prefix match on the trie field, but whose prefix</span></span><br><span class="line"><span class="comment"> * length is not indicated in &#x27;match_plens&#x27;.  For example, a subtable that</span></span><br><span class="line"><span class="comment"> * has a 8-bit trie field prefix match can be skipped if</span></span><br><span class="line"><span class="comment"> * !be_get_bit_at(&amp;match_plens, 8 - 1).  If skipped, &#x27;maskbits&#x27; prefix bits</span></span><br><span class="line"><span class="comment"> * must be unwildcarded to make datapath flow only match packets it should. */</span></span><br><span class="line"><span class="comment">//规则匹配时所使用的trie的上下文</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie_ctx</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cls_trie</span> *<span class="title">trie</span>;</span></span><br><span class="line">    <span class="type">bool</span> lookup_done;        <span class="comment">/* Status of the lookup. */</span></span><br><span class="line">    <span class="comment">//对flow的field仅需要匹配maskbits长度的前缀就可以得到所有的匹配结果</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> maskbits;   <span class="comment">/* Prefix length needed to avoid false matches. */</span></span><br><span class="line">    <span class="comment">//记录该flow所命中的前缀长度，第n位为1表示命中了前缀长度为n+1的规则。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">trie_prefix</span> <span class="title">match_plens</span>;</span>  <span class="comment">/* Bitmask of prefix lengths with possible</span></span><br><span class="line"><span class="comment">                                     * matches. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>根据trie所对应的前缀域，从待匹配的flow中提取该字段所对应的匹配串</p>
</li>
<li><p>将该匹配串送入trie中进行匹配，将匹配结果存在<code>trie_ctx</code>中</p>
</li>
<li><p>判断是否可能命中了该subtable中的规则（设该subtable对该trie的前缀长度为n）：也就是判断<code>match_plens</code>的第n-1位是否为1。若为1，则说明可能命中了该subtable的规则，若为0，则说明一定没有命中该subtable的规则</p>
<blockquote>
<p> 这里说可能命中，是因为不同subtable对该trie的前缀长度可能相同，若为1，也可能命中了其他subtable中的规则</p>
</blockquote>
<ul>
<li><p>若可能命中该subtable中的规则：不做任何操作。因为trie只对未命中规则的wc做优化。</p>
</li>
<li><p>若未命中该subtable中的规则：</p>
<ul>
<li><p>如果该subtable对该trie的前缀长度大于等于maskbits，则设置wc中对应trie的前缀域的前缀掩码，掩码长度为<code>maskbits</code>。并跳过该subtable的规则匹配。</p>
<blockquote>
<p>因为maskbits长度的掩码已经能确定了对于该field，flow和wc掩码后一定没有命中该subtable的规则。</p>
<p>但为什么要对wc设置maskbits的前缀长度，而不是subtable对该trie的前缀长度呢？</p>
</blockquote>
</li>
<li><p>如果该subtable对该trie的前缀长度小于<code>maskbits</code>，则判断wc中是否设置了掩码长度为<code>maskbits</code>的掩码，如果设置了，则跳过该subtable的规则匹配。如果没设置，则继续该subtable的规则匹配。</p>
<blockquote>
<p>当subtable对该trie的前缀长度小于maskbits时，为什么不设置wc为subtable对该trie的前缀长度，并跳过该subtable的规则匹配呢？这样做不是能达到掩码的最小化吗？不理解</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>个人认为，当trie若未命中该subtable中的规则时，直接对wc设置该subtable对该trie的前缀长度，并跳过该subtable的规则匹配。maskbits不再需要。</p>
</blockquote>
<h5 id="内置l4-port前缀域"><a href="#内置l4-port前缀域" class="headerlink" title="内置l4 port前缀域"></a>内置l4 port前缀域</h5><p>与优化2类似，使用trie构建，因为port的前缀掩码可能不连续，因此在插入和匹配时与掩码相与，保证trie的正确性。l4 port的前缀长度为<strong>MSB</strong>到<strong>LSB 1</strong>之间长度（0b001000的前缀长度为3）</p>
<p>该port_trie是基于subtable的。在subtable中，对该flow进行全量匹配后，仍未命中规则，则对该port_trie进行查找，根据查找结果确定<code>port_mask</code>，并将其设置到wc的l4 port前缀域中。</p>
<p><strong>规则插入时对port_trie的操作</strong>：</p>
<ul>
<li>根据规则的mask，查找对应的subtable。subtable中存储着该port_trie及port_trie的前缀长度</li>
<li>根据subtable中对该port_trie的前缀长度，获取该规则中l4 port的前缀串（<code>[port_src, port_dst] &amp; cls_mask</code>），并插入trie中</li>
</ul>
<p><strong>规则匹配时对port_trie的操作</strong>：</p>
<ul>
<li>当subtable对该flow进行全量匹配且未命中后，提取flow的port信息（<code>[port_src, port_dst] &amp; subtable_mask</code>），在port_trie中进行查找，并返回匹配长度（这个匹配长度跟trie_ctx中的<code>maskbits</code>一个含义）</li>
<li>将这个长度作为前缀掩码长度，并设置到wc的l4 port中</li>
</ul>
<h3 id="规则版本号控制"><a href="#规则版本号控制" class="headerlink" title="规则版本号控制"></a>规则版本号控制</h3><p>版本号可控制cls中的cls规则是否对用户可见，在cls规则插入和cls规则匹配时，都会带有当前版本号信息。版本号的控制是以cls规则为单位的，因此可以通过API对特定的规则的版本号进行控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">versions</span> &#123;</span></span><br><span class="line">    <span class="type">ovs_version_t</span> add_version;              <span class="comment">/* Version object was added in. */</span></span><br><span class="line">    ATOMIC(<span class="type">ovs_version_t</span>) remove_version;   <span class="comment">/* Version object is removed in. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Makes &#x27;rule&#x27; invisible in &#x27;remove_version&#x27;.  Once that version is used in</span></span><br><span class="line"><span class="comment"> * lookups, the caller should remove &#x27;rule&#x27; via ovsrcu_postpone().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;rule&#x27; must be in a classifier.</span></span><br><span class="line"><span class="comment"> * This may only be called by the exclusive writer. */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cls_rule_make_invisible_in_version</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cls_rule *rule,</span></span><br><span class="line"><span class="params">                                   <span class="type">ovs_version_t</span> remove_version)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This undoes the change made by cls_rule_make_invisible_in_version().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;rule&#x27; must be in a classifier.</span></span><br><span class="line"><span class="comment"> * This may only be called by the exclusive writer. */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cls_rule_restore_visibility</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cls_rule *rule)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">cls_rule_visible_in_version</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cls_rule *rule, <span class="type">ovs_version_t</span> version)</span>;</span><br></pre></td></tr></table></figure>



<p>在规则插入时，<code>add_version</code>和<code>remove_version</code>相等，当插入完成后，<code>remove_version</code>设置为<code>OVS_VERSION_NOT_REMOVED</code>（ovs_version_t的最大值）。</p>
<p>在规则查找时会指定当前的版本号，只有<code>add_version &lt;= cur_version &lt; remove_version</code>的版本号才对调用者可见。</p>
<h3 id="conjunction实现"><a href="#conjunction实现" class="headerlink" title="conjunction实现"></a>conjunction实现</h3><p>略</p>
<h1 id="SKIPLIST"><a href="#SKIPLIST" class="headerlink" title="SKIPLIST"></a>SKIPLIST</h1><p>跳表，是一个有序链表，通过组织多级链表，可实现插入查找的高效操作。层级越高，链表数量越少。若每层节点的数量是前一层的1&#x2F;2，则查找插入的时间复杂度为O(logn)</p>
<h2 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> skiplist *<span class="title function_">skiplist_create</span><span class="params">(skiplist_comparator *object_comparator,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> *configuration)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplist_insert</span><span class="params">(<span class="keyword">struct</span> skiplist *sl, <span class="type">const</span> <span class="type">void</span> *object)</span>;</span><br><span class="line"></span><br><span class="line">SKIPLIST_FOR_EACH (SKIPLIST_NODE, SKIPLIST)</span><br></pre></td></tr></table></figure>



<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Skiplist node container */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skiplist_node</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *data;                 <span class="comment">/* Pointer to saved data. */</span></span><br><span class="line">    <span class="comment">//根据跳表所支持的层数来申请，默认32层，需申请大小为33的数组。</span></span><br><span class="line">    <span class="comment">//forward[0]所组成的有序链表，存储着所有的元素</span></span><br><span class="line">    <span class="comment">//forward[1]所组成的有序链表，存储着1/2的元素，以此类推</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplist_node</span> *<span class="title">forward</span>[];</span>  <span class="comment">/* Links to the next nodes. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skiplist container */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">//头节点，头节点指向插入的最小的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplist_node</span> *<span class="title">header</span>;</span> <span class="comment">/* Pointer to head node (not first</span></span><br><span class="line"><span class="comment">                                   * data node). */</span></span><br><span class="line">    skiplist_comparator *cmp;     <span class="comment">/* Pointer to the skiplist&#x27;s comparison</span></span><br><span class="line"><span class="comment">                                   * function. */</span></span><br><span class="line">    <span class="type">void</span> *cfg;                    <span class="comment">/* Pointer to optional comparison</span></span><br><span class="line"><span class="comment">                                   * configuration, used by the comparator. */</span></span><br><span class="line">    <span class="comment">//大于该层级的链表为空。</span></span><br><span class="line">    <span class="type">int</span> level;                    <span class="comment">/* Maximum level currently in use. */</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                <span class="comment">/* Current number of nodes in skiplist. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数是实现跳表的核心函数，该函数会向前找到第一个小于value的节点，并将其存在update（包含所有层级链表）里，并返回update[0]-&gt;forward[0],也就是第一个大于等于value的节点。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> skiplist_node *</span><br><span class="line"><span class="title function_">skiplist_forward_to_</span><span class="params">(<span class="keyword">struct</span> skiplist *sl, <span class="type">const</span> <span class="type">void</span> *value,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> skiplist_node **update)</span></span><br></pre></td></tr></table></figure>



<h1 id="HEAP"><a href="#HEAP" class="headerlink" title="HEAP"></a>HEAP</h1><p>最大堆，使用优先队列实现。</p>
<p>堆的两个特性：</p>
<ul>
<li>结构性：用数组表示的完全二叉树</li>
<li>偏序性：任意节点的优先级都大于（小于）其子树节点的优先级</li>
</ul>
<p>为了更好的获取父节点索引，优先级队列数组从1开始存储节点。</p>
<h2 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">heap_init</span><span class="params">(<span class="keyword">struct</span> heap *)</span>;</span><br><span class="line"><span class="comment">//插入一个优先级为priority的节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_insert</span><span class="params">(<span class="keyword">struct</span> heap *, <span class="keyword">struct</span> heap_node *, <span class="type">uint64_t</span> priority)</span>;</span><br><span class="line"><span class="comment">//修改一个节点的优先级</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_change</span><span class="params">(<span class="keyword">struct</span> heap *, <span class="keyword">struct</span> heap_node *, <span class="type">uint64_t</span> priority)</span>;</span><br><span class="line"><span class="comment">//删除一个节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_remove</span><span class="params">(<span class="keyword">struct</span> heap *, <span class="keyword">struct</span> heap_node *)</span>;</span><br><span class="line"><span class="comment">//取出最高优先级的节点</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> heap_node *<span class="title function_">heap_pop</span><span class="params">(<span class="keyword">struct</span> heap *)</span>;</span><br><span class="line"></span><br><span class="line">HEAP_FOR_EACH(NODE, MEMBER, HEAP)</span><br></pre></td></tr></table></figure>



<h1 id="STREAM"><a href="#STREAM" class="headerlink" title="STREAM"></a>STREAM</h1><p>在ovs中，连接被分为主动连接（active）和被动连接（passive）。</p>
<table>
<thead>
<tr>
<th align="center">proto</th>
<th align="center">active</th>
<th align="center">passive</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tcp</td>
<td align="center">tcp_stream_class</td>
<td align="center">ptcp_pstream_class</td>
</tr>
<tr>
<td align="center">unix</td>
<td align="center">unix_stream_class</td>
<td align="center">punix_pstream_class</td>
</tr>
<tr>
<td align="center">ssl</td>
<td align="center">ssl_stream_class</td>
<td align="center">pssl_pstream_class</td>
</tr>
</tbody></table>
<p>ovs将<code>stream</code>抽象成为协议无关的实现。其抽象层次如下图所示：</p>
<p><a href="/images/stream.svg" title="stream" class="gallery-item" style="box-shadow: none;"> <img src="/images/stream.svg" alt="stream"></a></p>
<p><code>stream</code>根据不同的协议类型，调用不同的<code>stream-proto</code>（e.g. stream-tcp）进行<code>stream</code>的初始化，这些<code>stream-proto</code>类仅实现<code>open()</code>方法用于<code>stream</code>的初始化。初始化后，后续对该<code>stream</code>的所有操作，都使用<code>stream-fd</code>类的实现。</p>
<p>被动连接与主动连接在其实现上略有区别，下面就分别介绍这两类连接的实现原理及应用</p>
<h2 id="主动连接-stream"><a href="#主动连接-stream" class="headerlink" title="主动连接(stream)"></a>主动连接(stream)</h2><p>主动连接作为客户端，只与服务端建立一条连接。</p>
<p>stream对连接有状态跟踪，连接可能的状态如下：</p>
<ul>
<li>SCS_CONNECTING：表示该<code>stream</code>正在连接。因为该连接为非阻塞模式，连接可能需要较长时间完成。此时设置为该状态</li>
<li>SCS_CONNECTED：表示该<code>stream</code>已经连接成功</li>
<li>SCS_DISCONNECTED：表示该<code>stream</code>连接错误或者断开连接</li>
</ul>
<h3 id="API-6"><a href="#API-6" class="headerlink" title="API"></a>API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建stream并连接目标地址（connect过程是非阻塞的，状态可能为SCS_CONNECTING）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> stream **, <span class="type">uint8_t</span> dscp)</span>;</span><br><span class="line"><span class="comment">//阻塞等待该stream连接成功，或超时</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_open_block</span><span class="params">(<span class="type">int</span> error, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> timeout, <span class="keyword">struct</span> stream **)</span>;</span><br><span class="line"><span class="comment">//非阻塞查询连接状态，若未连接成功则返回EAGAIN</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_connect</span><span class="params">(<span class="keyword">struct</span> stream *)</span>;</span><br><span class="line"><span class="comment">//接受数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_recv</span><span class="params">(<span class="keyword">struct</span> stream *, <span class="type">void</span> *buffer, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_send</span><span class="params">(<span class="keyword">struct</span> stream *, <span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">//周期性执行，用于维护该stream的一些行为。目前该函数默认什么都不做</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stream_run</span><span class="params">(<span class="keyword">struct</span> stream *)</span>;</span><br><span class="line"><span class="comment">//放入poll中等待被唤醒，唤醒后可立即执行stream_run。目前该函数默认什么都不做</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stream_run_wait</span><span class="params">(<span class="keyword">struct</span> stream *)</span>;</span><br><span class="line"><span class="comment">//放入poll中等待该stream连接成功，唤醒后可调用stream_connect()来更新stream状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stream_connect_wait</span><span class="params">(<span class="keyword">struct</span> stream *)</span>;</span><br><span class="line"><span class="comment">//放入poll中等待该stream处于可读状态，唤醒后可调用stream_recv()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stream_recv_wait</span><span class="params">(<span class="keyword">struct</span> stream *)</span>;</span><br><span class="line"><span class="comment">//放入poll中等待该stream处于可写状态，唤醒后可调用stream_send()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stream_send_wait</span><span class="params">(<span class="keyword">struct</span> stream *)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="stream-fd"><a href="#stream-fd" class="headerlink" title="stream-fd"></a>stream-fd</h3><p>用于管理linux的fd，由于linux对各类连接的底层抽象都是fd，所以不同协议类型的连接，除了open操作不同，其余操作都可使用该类来完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建stream，fd为已经创建好的描述符，connect_status表示该fd执行connect后的errno。	</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">new_fd_stream</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> fd, <span class="type">int</span> connect_status,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> fd_type, <span class="keyword">struct</span> stream **streamp)</span>;</span><br></pre></td></tr></table></figure>

<p>该stream所绑定的类为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">stream_class</span> <span class="title">stream_fd_class</span> =</span> &#123;</span><br><span class="line">    <span class="string">&quot;fd&quot;</span>,                       <span class="comment">/* name */</span></span><br><span class="line">    <span class="literal">false</span>,                      <span class="comment">/* needs_probes */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* open */</span></span><br><span class="line">    fd_close,                   <span class="comment">/* close */</span></span><br><span class="line">    fd_connect,                 <span class="comment">/* connect */</span></span><br><span class="line">    fd_recv,                    <span class="comment">/* recv */</span></span><br><span class="line">    fd_send,                    <span class="comment">/* send */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* run */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* run_wait */</span></span><br><span class="line">    <span class="comment">//stream_connect_wait(), stream_recv_wait(), stream_send_wait()调用</span></span><br><span class="line">    fd_wait,                    <span class="comment">/* wait */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>上层抽象通过调用<code>new_fd_stream</code>来创建<code>stream</code>，<code>stream</code>的状态根据<code>connect_status</code>来决定：</p>
<ul>
<li>connect_status &#x3D;&#x3D; EAGAIN：说明该fd未连接成功，状态置为<code>SCS_CONNECTING</code></li>
<li>connect_status &#x3D;&#x3D; 0：说明该fd连接成功，状态置为<code>SCS_CONNECTED</code></li>
<li>connect_status &#x3D;&#x3D; 其他：说明该fd连接错误，无法连接，状态置为<code>SCS_DISCONNECTED</code></li>
</ul>
<h3 id="stream-proto"><a href="#stream-proto" class="headerlink" title="stream-proto"></a>stream-proto</h3><p>根据所连接的协议的不同实现不同的open函数，其余操作实现使用<code>stream_fd</code>类。</p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul>
<li>vconn</li>
<li>jsonrpc</li>
</ul>
<h2 id="被动连接-pstream"><a href="#被动连接-pstream" class="headerlink" title="被动连接(pstream)"></a>被动连接(pstream)</h2><p>作为服务端，等待客户端与之建立连接。</p>
<p>每新建一个连接，创建并返回一个连接成功的<code>stream</code>。</p>
<h3 id="API-7"><a href="#API-7" class="headerlink" title="API"></a>API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建stream并监听地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pstream_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> pstream **, <span class="type">uint8_t</span> dscp)</span>;</span><br><span class="line"><span class="comment">//非阻塞接收新建连接，新建连接初始化为stream，并返回给入参</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pstream_accept</span><span class="params">(<span class="keyword">struct</span> pstream *, <span class="keyword">struct</span> stream **)</span>;</span><br><span class="line"><span class="comment">//阻塞接收新建连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pstream_accept_block</span><span class="params">(<span class="keyword">struct</span> pstream *, <span class="keyword">struct</span> stream **)</span>;</span><br><span class="line"><span class="comment">//放入poll中等待该pstream的新建连接</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pstream_wait</span><span class="params">(<span class="keyword">struct</span> pstream *)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="pstream-fd"><a href="#pstream-fd" class="headerlink" title="pstream-fd"></a>pstream-fd</h3><p>用于管理linux的fd，由于linux对各类连接的底层抽象都是fd，所以不同协议类型的连接，除了<code>listen()</code>操作不同，其余操作都可使用该类来完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建pstream，fd为已经创建好的描述符，accept_cb为接收到一个新建连接的回调函数，该函数用于创建一个新建连接所对应的stream。</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">new_fd_pstream</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> (*accept_cb)(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr_storage *ss,</span></span><br><span class="line"><span class="params">                                <span class="type">size_t</span> ss_len, <span class="keyword">struct</span> stream **streamp),</span></span><br><span class="line"><span class="params">               <span class="type">char</span> *unlink_path, <span class="keyword">struct</span> pstream **pstreamp)</span></span><br></pre></td></tr></table></figure>

<p>该<code>pstream</code>所绑定的类为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pstream_class</span> <span class="title">fd_pstream_class</span> =</span> &#123;</span><br><span class="line">    <span class="string">&quot;pstream&quot;</span>,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    pfd_close,</span><br><span class="line">    pfd_accept,</span><br><span class="line">    pfd_wait,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上层抽象通过调用<code>new_fd_pstream</code>来创建<code>pstream</code>。</p>
<h3 id="pstream-proto"><a href="#pstream-proto" class="headerlink" title="pstream-proto"></a>pstream-proto</h3><p>根据所连接的协议的不同实现不同的<code>listen()</code>，并注册<code>accept()</code>的回调函数。其余操作实现使用<code>pstream_fd</code>类。</p>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ul>
<li>pvconn</li>
<li>jsonrpc</li>
</ul>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2025-04-06</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2024/01/01/dpdk/">dpdk</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    wrapEmojis('.paper');
  });
</script>